{"ast":null,"code":"import _asyncToGenerator from \"C:/projects/KidsToyHive/src/KidsToyHive.App/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { LogLevel } from \"./ILogger\";\nimport { NullLogger } from \"./Loggers\";\nimport { VERSION } from \"./pkg-version\";\n// Version token that will be replaced by the prepack command\n/** The version of the SignalR client. */\nexport { VERSION };\n/** @private */\nexport class Arg {\n  static isRequired(val, name) {\n    if (val === null || val === undefined) {\n      throw new Error(`The '${name}' argument is required.`);\n    }\n  }\n  static isNotEmpty(val, name) {\n    if (!val || val.match(/^\\s*$/)) {\n      throw new Error(`The '${name}' argument should not be empty.`);\n    }\n  }\n  static isIn(val, values, name) {\n    // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\n    if (!(val in values)) {\n      throw new Error(`Unknown ${name} value: ${val}.`);\n    }\n  }\n}\n/** @private */\nexport class Platform {\n  // react-native has a window but no document so we should check both\n  static get isBrowser() {\n    return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"object\";\n  }\n  // WebWorkers don't have a window object so the isBrowser check would fail\n  static get isWebWorker() {\n    return !Platform.isNode && typeof self === \"object\" && \"importScripts\" in self;\n  }\n  // react-native has a window but no document\n  static get isReactNative() {\n    return !Platform.isNode && typeof window === \"object\" && typeof window.document === \"undefined\";\n  }\n  // Node apps shouldn't have a window object, but WebWorkers don't either\n  // so we need to check for both WebWorker and window\n  static get isNode() {\n    return typeof process !== \"undefined\" && process.release && process.release.name === \"node\";\n  }\n}\n/** @private */\nexport function getDataDetail(data, includeContent) {\n  let detail = \"\";\n  if (isArrayBuffer(data)) {\n    detail = `Binary data of length ${data.byteLength}`;\n    if (includeContent) {\n      detail += `. Content: '${formatArrayBuffer(data)}'`;\n    }\n  } else if (typeof data === \"string\") {\n    detail = `String data of length ${data.length}`;\n    if (includeContent) {\n      detail += `. Content: '${data}'`;\n    }\n  }\n  return detail;\n}\n/** @private */\nexport function formatArrayBuffer(data) {\n  const view = new Uint8Array(data);\n  // Uint8Array.map only supports returning another Uint8Array?\n  let str = \"\";\n  view.forEach(num => {\n    const pad = num < 16 ? \"0\" : \"\";\n    str += `0x${pad}${num.toString(16)} `;\n  });\n  // Trim of trailing space.\n  return str.substring(0, str.length - 1);\n}\n// Also in signalr-protocol-msgpack/Utils.ts\n/** @private */\nexport function isArrayBuffer(val) {\n  return val && typeof ArrayBuffer !== \"undefined\" && (val instanceof ArrayBuffer ||\n  // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n  val.constructor && val.constructor.name === \"ArrayBuffer\");\n}\n/** @private */\nexport function sendMessage(_x, _x2, _x3, _x4, _x5, _x6) {\n  return _sendMessage.apply(this, arguments);\n}\n/** @private */\nfunction _sendMessage() {\n  _sendMessage = _asyncToGenerator(function* (logger, transportName, httpClient, url, content, options) {\n    const headers = {};\n    const [name, value] = getUserAgentHeader();\n    headers[name] = value;\n    logger.log(LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);\n    const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\n    const response = yield httpClient.post(url, {\n      content,\n      headers: {\n        ...headers,\n        ...options.headers\n      },\n      responseType,\n      timeout: options.timeout,\n      withCredentials: options.withCredentials\n    });\n    logger.log(LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\n  });\n  return _sendMessage.apply(this, arguments);\n}\nexport function createLogger(logger) {\n  if (logger === undefined) {\n    return new ConsoleLogger(LogLevel.Information);\n  }\n  if (logger === null) {\n    return NullLogger.instance;\n  }\n  if (logger.log !== undefined) {\n    return logger;\n  }\n  return new ConsoleLogger(logger);\n}\n/** @private */\nexport class SubjectSubscription {\n  constructor(subject, observer) {\n    this._subject = subject;\n    this._observer = observer;\n  }\n  dispose() {\n    const index = this._subject.observers.indexOf(this._observer);\n    if (index > -1) {\n      this._subject.observers.splice(index, 1);\n    }\n    if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\n      this._subject.cancelCallback().catch(_ => {});\n    }\n  }\n}\n/** @private */\nexport class ConsoleLogger {\n  constructor(minimumLogLevel) {\n    this._minLevel = minimumLogLevel;\n    this.out = console;\n  }\n  log(logLevel, message) {\n    if (logLevel >= this._minLevel) {\n      const msg = `[${new Date().toISOString()}] ${LogLevel[logLevel]}: ${message}`;\n      switch (logLevel) {\n        case LogLevel.Critical:\n        case LogLevel.Error:\n          this.out.error(msg);\n          break;\n        case LogLevel.Warning:\n          this.out.warn(msg);\n          break;\n        case LogLevel.Information:\n          this.out.info(msg);\n          break;\n        default:\n          // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\n          this.out.log(msg);\n          break;\n      }\n    }\n  }\n}\n/** @private */\nexport function getUserAgentHeader() {\n  let userAgentHeaderName = \"X-SignalR-User-Agent\";\n  if (Platform.isNode) {\n    userAgentHeaderName = \"User-Agent\";\n  }\n  return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\n}\n/** @private */\nexport function constructUserAgent(version, os, runtime, runtimeVersion) {\n  // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\n  let userAgent = \"Microsoft SignalR/\";\n  const majorAndMinor = version.split(\".\");\n  userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\n  userAgent += ` (${version}; `;\n  if (os && os !== \"\") {\n    userAgent += `${os}; `;\n  } else {\n    userAgent += \"Unknown OS; \";\n  }\n  userAgent += `${runtime}`;\n  if (runtimeVersion) {\n    userAgent += `; ${runtimeVersion}`;\n  } else {\n    userAgent += \"; Unknown Runtime Version\";\n  }\n  userAgent += \")\";\n  return userAgent;\n}\n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/\nfunction getOsName() {\n  if (Platform.isNode) {\n    switch (process.platform) {\n      case \"win32\":\n        return \"Windows NT\";\n      case \"darwin\":\n        return \"macOS\";\n      case \"linux\":\n        return \"Linux\";\n      default:\n        return process.platform;\n    }\n  } else {\n    return \"\";\n  }\n}\n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/\nfunction getRuntimeVersion() {\n  if (Platform.isNode) {\n    return process.versions.node;\n  }\n  return undefined;\n}\nfunction getRuntime() {\n  if (Platform.isNode) {\n    return \"NodeJS\";\n  } else {\n    return \"Browser\";\n  }\n}\n/** @private */\nexport function getErrorString(e) {\n  if (e.stack) {\n    return e.stack;\n  } else if (e.message) {\n    return e.message;\n  }\n  return `${e}`;\n}\n/** @private */\nexport function getGlobalThis() {\n  // globalThis is semi-new and not available in Node until v12\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"could not find global\");\n}\n//# sourceMappingURL=Utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}