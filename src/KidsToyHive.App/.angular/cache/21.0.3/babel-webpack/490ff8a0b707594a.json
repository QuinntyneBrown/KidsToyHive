{"ast":null,"code":"/*!\n * Signature Pad v5.1.3 | https://github.com/szimek/signature_pad\n * (c) 2025 Szymon Nowak | Released under the MIT license\n */\n\n// src/point.ts\nvar Point = class {\n  x;\n  y;\n  pressure;\n  time;\n  constructor(x, y, pressure, time) {\n    if (isNaN(x) || isNaN(y)) {\n      throw new Error(`Point is invalid: (${x}, ${y})`);\n    }\n    this.x = +x;\n    this.y = +y;\n    this.pressure = pressure || 0;\n    this.time = time || Date.now();\n  }\n  distanceTo(start) {\n    return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.pressure === other.pressure && this.time === other.time;\n  }\n  velocityFrom(start) {\n    return this.time !== start.time ? this.distanceTo(start) / (this.time - start.time) : 0;\n  }\n};\n\n// src/bezier.ts\nvar Bezier = class _Bezier {\n  constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {\n    this.startPoint = startPoint;\n    this.control2 = control2;\n    this.control1 = control1;\n    this.endPoint = endPoint;\n    this.startWidth = startWidth;\n    this.endWidth = endWidth;\n  }\n  static fromPoints(points, widths) {\n    const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;\n    const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;\n    return new _Bezier(points[1], c2, c3, points[2], widths.start, widths.end);\n  }\n  static calculateControlPoints(s1, s2, s3) {\n    const dx1 = s1.x - s2.x;\n    const dy1 = s1.y - s2.y;\n    const dx2 = s2.x - s3.x;\n    const dy2 = s2.y - s3.y;\n    const m1 = {\n      x: (s1.x + s2.x) / 2,\n      y: (s1.y + s2.y) / 2\n    };\n    const m2 = {\n      x: (s2.x + s3.x) / 2,\n      y: (s2.y + s3.y) / 2\n    };\n    const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n    const dxm = m1.x - m2.x;\n    const dym = m1.y - m2.y;\n    const k = l1 + l2 == 0 ? 0 : l2 / (l1 + l2);\n    const cm = {\n      x: m2.x + dxm * k,\n      y: m2.y + dym * k\n    };\n    const tx = s2.x - cm.x;\n    const ty = s2.y - cm.y;\n    return {\n      c1: new Point(m1.x + tx, m1.y + ty),\n      c2: new Point(m2.x + tx, m2.y + ty)\n    };\n  }\n  // Returns approximated length. Code taken from https://www.lemoda.net/maths/bezier-length/index.html.\n  length() {\n    const steps = 10;\n    let length = 0;\n    let px;\n    let py;\n    for (let i = 0; i <= steps; i += 1) {\n      const t = i / steps;\n      const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);\n      const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);\n      if (i > 0) {\n        const xdiff = cx - px;\n        const ydiff = cy - py;\n        length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);\n      }\n      px = cx;\n      py = cy;\n    }\n    return length;\n  }\n  // Calculate parametric value of x or y given t and the four point coordinates of a cubic bezier curve.\n  point(t, start, c1, c2, end) {\n    return start * (1 - t) * (1 - t) * (1 - t) + 3 * c1 * (1 - t) * (1 - t) * t + 3 * c2 * (1 - t) * t * t + end * t * t * t;\n  }\n};\n\n// src/signature_event_target.ts\nvar SignatureEventTarget = class {\n  /* tslint:disable: variable-name */\n  _et;\n  /* tslint:enable: variable-name */\n  constructor() {\n    try {\n      this._et = new EventTarget();\n    } catch {\n      this._et = document;\n    }\n  }\n  addEventListener(type, listener, options) {\n    this._et.addEventListener(type, listener, options);\n  }\n  dispatchEvent(event) {\n    return this._et.dispatchEvent(event);\n  }\n  removeEventListener(type, callback, options) {\n    this._et.removeEventListener(type, callback, options);\n  }\n};\n\n// src/throttle.ts\nfunction throttle(fn, wait = 250) {\n  let previous = 0;\n  let timeout = null;\n  let result;\n  let storedContext;\n  let storedArgs;\n  const later = () => {\n    previous = Date.now();\n    timeout = null;\n    result = fn.apply(storedContext, storedArgs);\n    if (!timeout) {\n      storedContext = null;\n      storedArgs = [];\n    }\n  };\n  return function wrapper(...args) {\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n    storedContext = this;\n    storedArgs = args;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = fn.apply(storedContext, storedArgs);\n      if (!timeout) {\n        storedContext = null;\n        storedArgs = [];\n      }\n    } else if (!timeout) {\n      timeout = window.setTimeout(later, remaining);\n    }\n    return result;\n  };\n}\n\n// src/signature_pad.ts\nvar SignaturePad = class _SignaturePad extends SignatureEventTarget {\n  /* tslint:enable: variable-name */\n  constructor(canvas, options = {}) {\n    super();\n    this.canvas = canvas;\n    this.velocityFilterWeight = options.velocityFilterWeight || 0.7;\n    this.minWidth = options.minWidth || 0.5;\n    this.maxWidth = options.maxWidth || 2.5;\n    this.throttle = options.throttle ?? 16;\n    this.minDistance = options.minDistance ?? 5;\n    this.dotSize = options.dotSize || 0;\n    this.penColor = options.penColor || \"black\";\n    this.backgroundColor = options.backgroundColor || \"rgba(0,0,0,0)\";\n    this.compositeOperation = options.compositeOperation || \"source-over\";\n    this.canvasContextOptions = options.canvasContextOptions ?? {};\n    this._strokeMoveUpdate = this.throttle ? throttle(_SignaturePad.prototype._strokeUpdate, this.throttle) : _SignaturePad.prototype._strokeUpdate;\n    this._handleMouseDown = this._handleMouseDown.bind(this);\n    this._handleMouseMove = this._handleMouseMove.bind(this);\n    this._handleMouseUp = this._handleMouseUp.bind(this);\n    this._handleTouchStart = this._handleTouchStart.bind(this);\n    this._handleTouchMove = this._handleTouchMove.bind(this);\n    this._handleTouchEnd = this._handleTouchEnd.bind(this);\n    this._handlePointerDown = this._handlePointerDown.bind(this);\n    this._handlePointerMove = this._handlePointerMove.bind(this);\n    this._handlePointerUp = this._handlePointerUp.bind(this);\n    this._handlePointerCancel = this._handlePointerCancel.bind(this);\n    this._handleTouchCancel = this._handleTouchCancel.bind(this);\n    this._ctx = canvas.getContext(\"2d\", this.canvasContextOptions);\n    this.clear();\n    this.on();\n  }\n  // Public stuff\n  dotSize;\n  minWidth;\n  maxWidth;\n  penColor;\n  minDistance;\n  velocityFilterWeight;\n  compositeOperation;\n  backgroundColor;\n  throttle;\n  canvasContextOptions;\n  // Private stuff\n  /* tslint:disable: variable-name */\n  _ctx;\n  _drawingStroke = false;\n  _isEmpty = true;\n  _dataUrl;\n  _dataUrlOptions;\n  _lastPoints = [];\n  // Stores up to 4 most recent points; used to generate a new curve\n  _data = [];\n  // Stores all points in groups (one group per line or dot)\n  _lastVelocity = 0;\n  _lastWidth = 0;\n  _strokeMoveUpdate;\n  _strokePointerId;\n  clear() {\n    const {\n      _ctx: ctx,\n      canvas\n    } = this;\n    ctx.fillStyle = this.backgroundColor;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    this._data = [];\n    this._reset(this._getPointGroupOptions());\n    this._isEmpty = true;\n    this._dataUrl = void 0;\n    this._dataUrlOptions = void 0;\n    this._strokePointerId = void 0;\n  }\n  redraw() {\n    const data = this._data;\n    const dataUrl = this._dataUrl;\n    const dataUrlOptions = this._dataUrlOptions;\n    this.clear();\n    if (dataUrl) {\n      this.fromDataURL(dataUrl, dataUrlOptions);\n    }\n    this.fromData(data, {\n      clear: false\n    });\n  }\n  fromDataURL(dataUrl, options = {}) {\n    return new Promise((resolve, reject) => {\n      const image = new Image();\n      const ratio = options.ratio || window.devicePixelRatio || 1;\n      const width = options.width || this.canvas.width / ratio;\n      const height = options.height || this.canvas.height / ratio;\n      const xOffset = options.xOffset || 0;\n      const yOffset = options.yOffset || 0;\n      this._reset(this._getPointGroupOptions());\n      image.onload = () => {\n        this._ctx.drawImage(image, xOffset, yOffset, width, height);\n        resolve();\n      };\n      image.onerror = error => {\n        reject(error);\n      };\n      image.crossOrigin = \"anonymous\";\n      image.src = dataUrl;\n      this._isEmpty = false;\n      this._dataUrl = dataUrl;\n      this._dataUrlOptions = {\n        ...options\n      };\n    });\n  }\n  toDataURL(type = \"image/png\", encoderOptions) {\n    switch (type) {\n      case \"image/svg+xml\":\n        if (typeof encoderOptions !== \"object\") {\n          encoderOptions = void 0;\n        }\n        return `data:image/svg+xml;base64,${btoa(this.toSVG(encoderOptions))}`;\n      default:\n        if (typeof encoderOptions !== \"number\") {\n          encoderOptions = void 0;\n        }\n        return this.canvas.toDataURL(type, encoderOptions);\n    }\n  }\n  on() {\n    this.canvas.style.touchAction = \"none\";\n    this.canvas.style.msTouchAction = \"none\";\n    this.canvas.style.userSelect = \"none\";\n    this.canvas.style.webkitUserSelect = \"none\";\n    const isIOS = /Macintosh/.test(navigator.userAgent) && \"ontouchstart\" in document;\n    if (window.PointerEvent && !isIOS) {\n      this._handlePointerEvents();\n    } else {\n      this._handleMouseEvents();\n      if (\"ontouchstart\" in window) {\n        this._handleTouchEvents();\n      }\n    }\n  }\n  off() {\n    this.canvas.style.touchAction = \"auto\";\n    this.canvas.style.msTouchAction = \"auto\";\n    this.canvas.style.userSelect = \"auto\";\n    this.canvas.style.webkitUserSelect = \"auto\";\n    this.canvas.removeEventListener(\"pointerdown\", this._handlePointerDown);\n    this.canvas.removeEventListener(\"mousedown\", this._handleMouseDown);\n    this.canvas.removeEventListener(\"touchstart\", this._handleTouchStart);\n    this._removeMoveUpEventListeners();\n  }\n  _getListenerFunctions() {\n    const canvasWindow = window.document === this.canvas.ownerDocument ? window : this.canvas.ownerDocument.defaultView ?? this.canvas.ownerDocument;\n    return {\n      addEventListener: canvasWindow.addEventListener.bind(canvasWindow),\n      removeEventListener: canvasWindow.removeEventListener.bind(canvasWindow)\n    };\n  }\n  _removeMoveUpEventListeners() {\n    const {\n      removeEventListener\n    } = this._getListenerFunctions();\n    removeEventListener(\"pointermove\", this._handlePointerMove);\n    removeEventListener(\"pointerup\", this._handlePointerUp);\n    removeEventListener(\"pointercancel\", this._handlePointerCancel);\n    removeEventListener(\"mousemove\", this._handleMouseMove);\n    removeEventListener(\"mouseup\", this._handleMouseUp);\n    removeEventListener(\"touchmove\", this._handleTouchMove);\n    removeEventListener(\"touchend\", this._handleTouchEnd);\n    removeEventListener(\"touchcancel\", this._handleTouchCancel);\n  }\n  isEmpty() {\n    return this._isEmpty;\n  }\n  fromData(pointGroups, {\n    clear = true\n  } = {}) {\n    if (clear) {\n      this.clear();\n    }\n    this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));\n    this._data = this._data.concat(pointGroups);\n  }\n  toData() {\n    return this._data;\n  }\n  _isLeftButtonPressed(event, only) {\n    if (only) {\n      return event.buttons === 1;\n    }\n    return (event.buttons & 1) === 1;\n  }\n  _pointerEventToSignatureEvent(event) {\n    return {\n      event,\n      type: event.type,\n      x: event.clientX,\n      y: event.clientY,\n      pressure: \"pressure\" in event ? event.pressure : 0\n    };\n  }\n  _touchEventToSignatureEvent(event) {\n    const touch = event.changedTouches[0];\n    return {\n      event,\n      type: event.type,\n      x: touch.clientX,\n      y: touch.clientY,\n      pressure: touch.force\n    };\n  }\n  // Event handlers\n  _handleMouseDown(event) {\n    if (!this._isLeftButtonPressed(event, true) || this._drawingStroke) {\n      return;\n    }\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  }\n  _handleMouseMove(event) {\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  }\n  _handleMouseUp(event) {\n    if (this._isLeftButtonPressed(event)) {\n      return;\n    }\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  }\n  _handleTouchStart(event) {\n    if (event.targetTouches.length !== 1 || this._drawingStroke) {\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this._strokeBegin(this._touchEventToSignatureEvent(event));\n  }\n  _handleTouchMove(event) {\n    if (event.targetTouches.length !== 1) {\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    if (!this._drawingStroke) {\n      this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n      return;\n    }\n    this._strokeMoveUpdate(this._touchEventToSignatureEvent(event));\n  }\n  _handleTouchEnd(event) {\n    if (event.targetTouches.length !== 0) {\n      return;\n    }\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this._strokeEnd(this._touchEventToSignatureEvent(event));\n  }\n  _handlePointerCancel(event) {\n    if (!this._allowPointerId(event)) {\n      return;\n    }\n    event.preventDefault();\n    this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n  }\n  _handleTouchCancel(event) {\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n    this._strokeEnd(this._touchEventToSignatureEvent(event), false);\n  }\n  _getPointerId(event) {\n    return event.persistentDeviceId || event.pointerId;\n  }\n  _allowPointerId(event, allowUndefined = false) {\n    if (typeof this._strokePointerId === \"undefined\") {\n      return allowUndefined;\n    }\n    return this._getPointerId(event) === this._strokePointerId;\n  }\n  _handlePointerDown(event) {\n    if (this._drawingStroke || !this._isLeftButtonPressed(event) || !this._allowPointerId(event, true)) {\n      return;\n    }\n    this._strokePointerId = this._getPointerId(event);\n    event.preventDefault();\n    this._strokeBegin(this._pointerEventToSignatureEvent(event));\n  }\n  _handlePointerMove(event) {\n    if (!this._allowPointerId(event)) {\n      return;\n    }\n    if (!this._isLeftButtonPressed(event, true) || !this._drawingStroke) {\n      this._strokeEnd(this._pointerEventToSignatureEvent(event), false);\n      return;\n    }\n    event.preventDefault();\n    this._strokeMoveUpdate(this._pointerEventToSignatureEvent(event));\n  }\n  _handlePointerUp(event) {\n    if (this._isLeftButtonPressed(event) || !this._allowPointerId(event)) {\n      return;\n    }\n    event.preventDefault();\n    this._strokeEnd(this._pointerEventToSignatureEvent(event));\n  }\n  _getPointGroupOptions(group) {\n    return {\n      penColor: group && \"penColor\" in group ? group.penColor : this.penColor,\n      dotSize: group && \"dotSize\" in group ? group.dotSize : this.dotSize,\n      minWidth: group && \"minWidth\" in group ? group.minWidth : this.minWidth,\n      maxWidth: group && \"maxWidth\" in group ? group.maxWidth : this.maxWidth,\n      velocityFilterWeight: group && \"velocityFilterWeight\" in group ? group.velocityFilterWeight : this.velocityFilterWeight,\n      compositeOperation: group && \"compositeOperation\" in group ? group.compositeOperation : this.compositeOperation\n    };\n  }\n  // Private methods\n  _strokeBegin(event) {\n    const cancelled = !this.dispatchEvent(new CustomEvent(\"beginStroke\", {\n      detail: event,\n      cancelable: true\n    }));\n    if (cancelled) {\n      return;\n    }\n    const {\n      addEventListener\n    } = this._getListenerFunctions();\n    switch (event.event.type) {\n      case \"mousedown\":\n        addEventListener(\"mousemove\", this._handleMouseMove, {\n          passive: false\n        });\n        addEventListener(\"mouseup\", this._handleMouseUp, {\n          passive: false\n        });\n        break;\n      case \"touchstart\":\n        addEventListener(\"touchmove\", this._handleTouchMove, {\n          passive: false\n        });\n        addEventListener(\"touchend\", this._handleTouchEnd, {\n          passive: false\n        });\n        addEventListener(\"touchcancel\", this._handleTouchCancel, {\n          passive: false\n        });\n        break;\n      case \"pointerdown\":\n        addEventListener(\"pointermove\", this._handlePointerMove, {\n          passive: false\n        });\n        addEventListener(\"pointerup\", this._handlePointerUp, {\n          passive: false\n        });\n        addEventListener(\"pointercancel\", this._handlePointerCancel, {\n          passive: false\n        });\n        break;\n      default:\n    }\n    this._drawingStroke = true;\n    const pointGroupOptions = this._getPointGroupOptions();\n    const newPointGroup = {\n      ...pointGroupOptions,\n      points: []\n    };\n    this._data.push(newPointGroup);\n    this._reset(pointGroupOptions);\n    this._strokeUpdate(event);\n  }\n  _strokeUpdate(event) {\n    if (!this._drawingStroke) {\n      return;\n    }\n    if (this._data.length === 0) {\n      this._strokeBegin(event);\n      return;\n    }\n    this.dispatchEvent(new CustomEvent(\"beforeUpdateStroke\", {\n      detail: event\n    }));\n    const point = this._createPoint(event.x, event.y, event.pressure);\n    const lastPointGroup = this._data[this._data.length - 1];\n    const lastPoints = lastPointGroup.points;\n    const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];\n    const isLastPointTooClose = lastPoint ? point.distanceTo(lastPoint) <= this.minDistance : false;\n    const pointGroupOptions = this._getPointGroupOptions(lastPointGroup);\n    if (!lastPoint || !(lastPoint && isLastPointTooClose)) {\n      const curve = this._addPoint(point, pointGroupOptions);\n      if (!lastPoint) {\n        this._drawDot(point, pointGroupOptions);\n      } else if (curve) {\n        this._drawCurve(curve, pointGroupOptions);\n      }\n      lastPoints.push({\n        time: point.time,\n        x: point.x,\n        y: point.y,\n        pressure: point.pressure\n      });\n    }\n    this.dispatchEvent(new CustomEvent(\"afterUpdateStroke\", {\n      detail: event\n    }));\n  }\n  _strokeEnd(event, shouldUpdate = true) {\n    this._removeMoveUpEventListeners();\n    if (!this._drawingStroke) {\n      return;\n    }\n    if (shouldUpdate) {\n      this._strokeUpdate(event);\n    }\n    this._drawingStroke = false;\n    this._strokePointerId = void 0;\n    this.dispatchEvent(new CustomEvent(\"endStroke\", {\n      detail: event\n    }));\n  }\n  _handlePointerEvents() {\n    this._drawingStroke = false;\n    this.canvas.addEventListener(\"pointerdown\", this._handlePointerDown, {\n      passive: false\n    });\n  }\n  _handleMouseEvents() {\n    this._drawingStroke = false;\n    this.canvas.addEventListener(\"mousedown\", this._handleMouseDown, {\n      passive: false\n    });\n  }\n  _handleTouchEvents() {\n    this.canvas.addEventListener(\"touchstart\", this._handleTouchStart, {\n      passive: false\n    });\n  }\n  // Called when a new line is started\n  _reset(options) {\n    this._lastPoints = [];\n    this._lastVelocity = 0;\n    this._lastWidth = (options.minWidth + options.maxWidth) / 2;\n    this._ctx.fillStyle = options.penColor;\n    this._ctx.globalCompositeOperation = options.compositeOperation;\n  }\n  _createPoint(x, y, pressure) {\n    const rect = this.canvas.getBoundingClientRect();\n    return new Point(x - rect.left, y - rect.top, pressure, (/* @__PURE__ */new Date()).getTime());\n  }\n  // Add point to _lastPoints array and generate a new curve if there are enough points (i.e. 3)\n  _addPoint(point, options) {\n    const {\n      _lastPoints\n    } = this;\n    _lastPoints.push(point);\n    if (_lastPoints.length > 2) {\n      if (_lastPoints.length === 3) {\n        _lastPoints.unshift(_lastPoints[0]);\n      }\n      const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2], options);\n      const curve = Bezier.fromPoints(_lastPoints, widths);\n      _lastPoints.shift();\n      return curve;\n    }\n    return null;\n  }\n  _calculateCurveWidths(startPoint, endPoint, options) {\n    const velocity = options.velocityFilterWeight * endPoint.velocityFrom(startPoint) + (1 - options.velocityFilterWeight) * this._lastVelocity;\n    const newWidth = this._strokeWidth(velocity, options);\n    const widths = {\n      end: newWidth,\n      start: this._lastWidth\n    };\n    this._lastVelocity = velocity;\n    this._lastWidth = newWidth;\n    return widths;\n  }\n  _strokeWidth(velocity, options) {\n    return Math.max(options.maxWidth / (velocity + 1), options.minWidth);\n  }\n  _drawCurveSegment(x, y, width) {\n    const ctx = this._ctx;\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, width, 0, 2 * Math.PI, false);\n    this._isEmpty = false;\n  }\n  _drawCurve(curve, options) {\n    const ctx = this._ctx;\n    const widthDelta = curve.endWidth - curve.startWidth;\n    const drawSteps = Math.ceil(curve.length()) * 2;\n    ctx.beginPath();\n    ctx.fillStyle = options.penColor;\n    for (let i = 0; i < drawSteps; i += 1) {\n      const t = i / drawSteps;\n      const tt = t * t;\n      const ttt = tt * t;\n      const u = 1 - t;\n      const uu = u * u;\n      const uuu = uu * u;\n      let x = uuu * curve.startPoint.x;\n      x += 3 * uu * t * curve.control1.x;\n      x += 3 * u * tt * curve.control2.x;\n      x += ttt * curve.endPoint.x;\n      let y = uuu * curve.startPoint.y;\n      y += 3 * uu * t * curve.control1.y;\n      y += 3 * u * tt * curve.control2.y;\n      y += ttt * curve.endPoint.y;\n      const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);\n      this._drawCurveSegment(x, y, width);\n    }\n    ctx.closePath();\n    ctx.fill();\n  }\n  _drawDot(point, options) {\n    const ctx = this._ctx;\n    const width = options.dotSize > 0 ? options.dotSize : (options.minWidth + options.maxWidth) / 2;\n    ctx.beginPath();\n    this._drawCurveSegment(point.x, point.y, width);\n    ctx.closePath();\n    ctx.fillStyle = options.penColor;\n    ctx.fill();\n  }\n  _fromData(pointGroups, drawCurve, drawDot) {\n    for (const group of pointGroups) {\n      const {\n        points\n      } = group;\n      const pointGroupOptions = this._getPointGroupOptions(group);\n      if (points.length > 1) {\n        for (let j = 0; j < points.length; j += 1) {\n          const basicPoint = points[j];\n          const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);\n          if (j === 0) {\n            this._reset(pointGroupOptions);\n          }\n          const curve = this._addPoint(point, pointGroupOptions);\n          if (curve) {\n            drawCurve(curve, pointGroupOptions);\n          }\n        }\n      } else {\n        this._reset(pointGroupOptions);\n        drawDot(points[0], pointGroupOptions);\n      }\n    }\n  }\n  toSVG({\n    includeBackgroundColor = false,\n    includeDataUrl = false\n  } = {}) {\n    const pointGroups = this._data;\n    const ratio = Math.max(window.devicePixelRatio || 1, 1);\n    const minX = 0;\n    const minY = 0;\n    const maxX = this.canvas.width / ratio;\n    const maxY = this.canvas.height / ratio;\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n    svg.setAttribute(\"viewBox\", `${minX} ${minY} ${maxX} ${maxY}`);\n    svg.setAttribute(\"width\", maxX.toString());\n    svg.setAttribute(\"height\", maxY.toString());\n    if (includeBackgroundColor && this.backgroundColor) {\n      const rect = document.createElement(\"rect\");\n      rect.setAttribute(\"width\", \"100%\");\n      rect.setAttribute(\"height\", \"100%\");\n      rect.setAttribute(\"fill\", this.backgroundColor);\n      svg.appendChild(rect);\n    }\n    if (includeDataUrl && this._dataUrl) {\n      const ratio2 = this._dataUrlOptions?.ratio || window.devicePixelRatio || 1;\n      const width = this._dataUrlOptions?.width || this.canvas.width / ratio2;\n      const height = this._dataUrlOptions?.height || this.canvas.height / ratio2;\n      const xOffset = this._dataUrlOptions?.xOffset || 0;\n      const yOffset = this._dataUrlOptions?.yOffset || 0;\n      const image = document.createElement(\"image\");\n      image.setAttribute(\"x\", xOffset.toString());\n      image.setAttribute(\"y\", yOffset.toString());\n      image.setAttribute(\"width\", width.toString());\n      image.setAttribute(\"height\", height.toString());\n      image.setAttribute(\"preserveAspectRatio\", \"none\");\n      image.setAttribute(\"href\", this._dataUrl);\n      svg.appendChild(image);\n    }\n    this._fromData(pointGroups, (curve, {\n      penColor\n    }) => {\n      const path = document.createElement(\"path\");\n      if (!isNaN(curve.control1.x) && !isNaN(curve.control1.y) && !isNaN(curve.control2.x) && !isNaN(curve.control2.y)) {\n        const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;\n        path.setAttribute(\"d\", attr);\n        path.setAttribute(\"stroke-width\", (curve.endWidth * 2.25).toFixed(3));\n        path.setAttribute(\"stroke\", penColor);\n        path.setAttribute(\"fill\", \"none\");\n        path.setAttribute(\"stroke-linecap\", \"round\");\n        svg.appendChild(path);\n      }\n    }, (point, {\n      penColor,\n      dotSize,\n      minWidth,\n      maxWidth\n    }) => {\n      const circle = document.createElement(\"circle\");\n      const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;\n      circle.setAttribute(\"r\", size.toString());\n      circle.setAttribute(\"cx\", point.x.toString());\n      circle.setAttribute(\"cy\", point.y.toString());\n      circle.setAttribute(\"fill\", penColor);\n      svg.appendChild(circle);\n    });\n    return svg.outerHTML;\n  }\n};\nexport { SignaturePad as default };\n//# sourceMappingURL=signature_pad.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}