{"ast":null,"code":"/******/(function () {\n  // webpackBootstrap\n  /******/\n  \"use strict\";\n\n  /******/\n  var __webpack_modules__ = {\n    /***/\"./client-src/modules/logger/tapable.js\": (\n    /*!**********************************************!*\\\n      !*** ./client-src/modules/logger/tapable.js ***!\n      \\**********************************************/\n    /***/\n    function (__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n      __webpack_require__.r(__webpack_exports__);\n      /* harmony export */\n      __webpack_require__.d(__webpack_exports__, {\n        /* harmony export */SyncBailHook: function () {\n          return /* binding */SyncBailHook;\n        }\n        /* harmony export */\n      });\n      function SyncBailHook() {\n        return {\n          call: function call() {}\n        };\n      }\n\n      /**\n       * Client stub for tapable SyncBailHook\n       */\n      // eslint-disable-next-line import/prefer-default-export\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/Logger.js\": (\n    /*!****************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/Logger.js ***!\n      \\****************************************************/\n    /***/\n    function (module) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _typeof(o) {\n        \"@babel/helpers - typeof\";\n\n        return _typeof = \"function\" == typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) && \"symbol\" == typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator ? function (o) {\n          return typeof o;\n        } : function (o) {\n          return o && \"function\" == typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n            return i;\n          }) && o.constructor === (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n            return i;\n          }) && o !== (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n            return i;\n          }).prototype ? \"symbol\" : typeof o;\n        }, _typeof(o);\n      }\n      function _toConsumableArray(r) {\n        return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n      }\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _unsupportedIterableToArray(r, a) {\n        if (r) {\n          if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n          var t = {}.toString.call(r).slice(8, -1);\n          return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n        }\n      }\n      function _iterableToArray(r) {\n        if (\"undefined\" != typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) && null != r[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n      }\n      function _arrayWithoutHoles(r) {\n        if (Array.isArray(r)) return _arrayLikeToArray(r);\n      }\n      function _arrayLikeToArray(r, a) {\n        (null == a || a > r.length) && (a = r.length);\n        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n        return n;\n      }\n      function _classCallCheck(a, n) {\n        if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n      }\n      function _defineProperties(e, r) {\n        for (var t = 0; t < r.length; t++) {\n          var o = r[t];\n          o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n        }\n      }\n      function _createClass(e, r, t) {\n        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n          writable: !1\n        }), e;\n      }\n      function _toPropertyKey(t) {\n        var i = _toPrimitive(t, \"string\");\n        return \"symbol\" == _typeof(i) ? i : i + \"\";\n      }\n      function _toPrimitive(t, r) {\n        if (\"object\" != _typeof(t) || !t) return t;\n        var e = t[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).toPrimitive];\n        if (void 0 !== e) {\n          var i = e.call(t, r || \"default\");\n          if (\"object\" != _typeof(i)) return i;\n          throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (\"string\" === r ? String : Number)(t);\n      }\n      var LogType = Object.freeze({\n        error: (/** @type {\"error\"} */\"error\"),\n        // message, c style arguments\n        warn: (/** @type {\"warn\"} */\"warn\"),\n        // message, c style arguments\n        info: (/** @type {\"info\"} */\"info\"),\n        // message, c style arguments\n        log: (/** @type {\"log\"} */\"log\"),\n        // message, c style arguments\n        debug: (/** @type {\"debug\"} */\"debug\"),\n        // message, c style arguments\n\n        trace: (/** @type {\"trace\"} */\"trace\"),\n        // no arguments\n\n        group: (/** @type {\"group\"} */\"group\"),\n        // [label]\n        groupCollapsed: (/** @type {\"groupCollapsed\"} */\"groupCollapsed\"),\n        // [label]\n        groupEnd: (/** @type {\"groupEnd\"} */\"groupEnd\"),\n        // [label]\n\n        profile: (/** @type {\"profile\"} */\"profile\"),\n        // [profileName]\n        profileEnd: (/** @type {\"profileEnd\"} */\"profileEnd\"),\n        // [profileName]\n\n        time: (/** @type {\"time\"} */\"time\"),\n        // name, time as [seconds, nanoseconds]\n\n        clear: (/** @type {\"clear\"} */\"clear\"),\n        // no arguments\n        status: (/** @type {\"status\"} */\"status\") // message, arguments\n      });\n      module.exports.LogType = LogType;\n\n      /** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */\n\n      var LOG_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger raw log method\");\n      var TIMERS_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger times\");\n      var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n        return i;\n      })(\"webpack logger aggregated times\");\n      var WebpackLogger = /*#__PURE__*/function () {\n        /**\n         * @param {(type: LogTypeEnum, args?: EXPECTED_ANY[]) => void} log log function\n         * @param {(name: string | (() => string)) => WebpackLogger} getChildLogger function to create child logger\n         */\n        function WebpackLogger(log, getChildLogger) {\n          _classCallCheck(this, WebpackLogger);\n          this[LOG_SYMBOL] = log;\n          this.getChildLogger = getChildLogger;\n        }\n\n        /**\n         * @param {...EXPECTED_ANY} args args\n         */\n        return _createClass(WebpackLogger, [{\n          key: \"error\",\n          value: function error() {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            this[LOG_SYMBOL](LogType.error, args);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"warn\",\n          value: function warn() {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n            this[LOG_SYMBOL](LogType.warn, args);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"info\",\n          value: function info() {\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n            this[LOG_SYMBOL](LogType.info, args);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"log\",\n          value: function log() {\n            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n              args[_key4] = arguments[_key4];\n            }\n            this[LOG_SYMBOL](LogType.log, args);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"debug\",\n          value: function debug() {\n            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n              args[_key5] = arguments[_key5];\n            }\n            this[LOG_SYMBOL](LogType.debug, args);\n          }\n\n          /**\n           * @param {EXPECTED_ANY} assertion assertion\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"assert\",\n          value: function assert(assertion) {\n            if (!assertion) {\n              for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n                args[_key6 - 1] = arguments[_key6];\n              }\n              this[LOG_SYMBOL](LogType.error, args);\n            }\n          }\n        }, {\n          key: \"trace\",\n          value: function trace() {\n            this[LOG_SYMBOL](LogType.trace, [\"Trace\"]);\n          }\n        }, {\n          key: \"clear\",\n          value: function clear() {\n            this[LOG_SYMBOL](LogType.clear);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"status\",\n          value: function status() {\n            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n              args[_key7] = arguments[_key7];\n            }\n            this[LOG_SYMBOL](LogType.status, args);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"group\",\n          value: function group() {\n            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n              args[_key8] = arguments[_key8];\n            }\n            this[LOG_SYMBOL](LogType.group, args);\n          }\n\n          /**\n           * @param {...EXPECTED_ANY} args args\n           */\n        }, {\n          key: \"groupCollapsed\",\n          value: function groupCollapsed() {\n            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n              args[_key9] = arguments[_key9];\n            }\n            this[LOG_SYMBOL](LogType.groupCollapsed, args);\n          }\n        }, {\n          key: \"groupEnd\",\n          value: function groupEnd() {\n            this[LOG_SYMBOL](LogType.groupEnd);\n          }\n\n          /**\n           * @param {string=} label label\n           */\n        }, {\n          key: \"profile\",\n          value: function profile(label) {\n            this[LOG_SYMBOL](LogType.profile, [label]);\n          }\n\n          /**\n           * @param {string=} label label\n           */\n        }, {\n          key: \"profileEnd\",\n          value: function profileEnd(label) {\n            this[LOG_SYMBOL](LogType.profileEnd, [label]);\n          }\n\n          /**\n           * @param {string} label label\n           */\n        }, {\n          key: \"time\",\n          value: function time(label) {\n            /** @type {Map<string | undefined, [number, number]>} */\n            this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();\n            this[TIMERS_SYMBOL].set(label, process.hrtime());\n          }\n\n          /**\n           * @param {string=} label label\n           */\n        }, {\n          key: \"timeLog\",\n          value: function timeLog(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeLog()\"));\n            }\n            var time = process.hrtime(prev);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n\n          /**\n           * @param {string=} label label\n           */\n        }, {\n          key: \"timeEnd\",\n          value: function timeEnd(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeEnd()\"));\n            }\n            var time = process.hrtime(prev);\n            /** @type {Map<string | undefined, [number, number]>} */\n            this[TIMERS_SYMBOL].delete(label);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n\n          /**\n           * @param {string=} label label\n           */\n        }, {\n          key: \"timeAggregate\",\n          value: function timeAggregate(label) {\n            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);\n            if (!prev) {\n              throw new Error(\"No such label '\".concat(label, \"' for WebpackLogger.timeAggregate()\"));\n            }\n            var time = process.hrtime(prev);\n            /** @type {Map<string | undefined, [number, number]>} */\n            this[TIMERS_SYMBOL].delete(label);\n            /** @type {Map<string | undefined, [number, number]>} */\n            this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();\n            var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n            if (current !== undefined) {\n              if (time[1] + current[1] > 1e9) {\n                time[0] += current[0] + 1;\n                time[1] = time[1] - 1e9 + current[1];\n              } else {\n                time[0] += current[0];\n                time[1] += current[1];\n              }\n            }\n            this[TIMERS_AGGREGATES_SYMBOL].set(label, time);\n          }\n\n          /**\n           * @param {string=} label label\n           */\n        }, {\n          key: \"timeAggregateEnd\",\n          value: function timeAggregateEnd(label) {\n            if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;\n            var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);\n            if (time === undefined) return;\n            this[TIMERS_AGGREGATES_SYMBOL].delete(label);\n            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));\n          }\n        }]);\n      }();\n      module.exports.Logger = WebpackLogger;\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/createConsoleLogger.js\": (\n    /*!*****************************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!\n      \\*****************************************************************/\n    /***/\n    function (module, __unused_webpack_exports, __webpack_require__) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _slicedToArray(r, e) {\n        return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n      }\n      function _nonIterableRest() {\n        throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _iterableToArrayLimit(r, l) {\n        var t = null == r ? null : \"undefined\" != typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) && r[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] || r[\"@@iterator\"];\n        if (null != t) {\n          var e,\n            n,\n            i,\n            u,\n            a = [],\n            f = !0,\n            o = !1;\n          try {\n            if (i = (t = t.call(r)).next, 0 === l) {\n              if (Object(t) !== t) return;\n              f = !1;\n            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n          } catch (r) {\n            o = !0, n = r;\n          } finally {\n            try {\n              if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n            } finally {\n              if (o) throw n;\n            }\n          }\n          return a;\n        }\n      }\n      function _arrayWithHoles(r) {\n        if (Array.isArray(r)) return r;\n      }\n      function _toConsumableArray(r) {\n        return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n      }\n      function _nonIterableSpread() {\n        throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n      }\n      function _unsupportedIterableToArray(r, a) {\n        if (r) {\n          if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n          var t = {}.toString.call(r).slice(8, -1);\n          return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n        }\n      }\n      function _iterableToArray(r) {\n        if (\"undefined\" != typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) && null != r[(typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n      }\n      function _arrayWithoutHoles(r) {\n        if (Array.isArray(r)) return _arrayLikeToArray(r);\n      }\n      function _arrayLikeToArray(r, a) {\n        (null == a || a > r.length) && (a = r.length);\n        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n        return n;\n      }\n      function _typeof(o) {\n        \"@babel/helpers - typeof\";\n\n        return _typeof = \"function\" == typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }) && \"symbol\" == typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n          return i;\n        }).iterator ? function (o) {\n          return typeof o;\n        } : function (o) {\n          return o && \"function\" == typeof (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n            return i;\n          }) && o.constructor === (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n            return i;\n          }) && o !== (typeof Symbol !== \"undefined\" ? Symbol : function (i) {\n            return i;\n          }).prototype ? \"symbol\" : typeof o;\n        }, _typeof(o);\n      }\n      var _require = __webpack_require__(/*! ./Logger */\"./node_modules/webpack/lib/logging/Logger.js\"),\n        LogType = _require.LogType;\n\n      /** @typedef {import(\"../../declarations/WebpackOptions\").FilterItemTypes} FilterItemTypes */\n      /** @typedef {import(\"../../declarations/WebpackOptions\").FilterTypes} FilterTypes */\n      /** @typedef {import(\"./Logger\").LogTypeEnum} LogTypeEnum */\n\n      /** @typedef {(item: string) => boolean} FilterFunction */\n      /** @typedef {(value: string, type: LogTypeEnum, args?: EXPECTED_ANY[]) => void} LoggingFunction */\n\n      /**\n       * @typedef {object} LoggerConsole\n       * @property {() => void} clear\n       * @property {() => void} trace\n       * @property {(...args: EXPECTED_ANY[]) => void} info\n       * @property {(...args: EXPECTED_ANY[]) => void} log\n       * @property {(...args: EXPECTED_ANY[]) => void} warn\n       * @property {(...args: EXPECTED_ANY[]) => void} error\n       * @property {(...args: EXPECTED_ANY[]) => void=} debug\n       * @property {(...args: EXPECTED_ANY[]) => void=} group\n       * @property {(...args: EXPECTED_ANY[]) => void=} groupCollapsed\n       * @property {(...args: EXPECTED_ANY[]) => void=} groupEnd\n       * @property {(...args: EXPECTED_ANY[]) => void=} status\n       * @property {(...args: EXPECTED_ANY[]) => void=} profile\n       * @property {(...args: EXPECTED_ANY[]) => void=} profileEnd\n       * @property {(...args: EXPECTED_ANY[]) => void=} logTime\n       */\n\n      /**\n       * @typedef {object} LoggerOptions\n       * @property {false|true|\"none\"|\"error\"|\"warn\"|\"info\"|\"log\"|\"verbose\"} level loglevel\n       * @property {FilterTypes|boolean} debug filter for debug logging\n       * @property {LoggerConsole} console the console to log to\n       */\n\n      /**\n       * @param {FilterItemTypes} item an input item\n       * @returns {FilterFunction | undefined} filter function\n       */\n      var filterToFunction = function filterToFunction(item) {\n        if (typeof item === \"string\") {\n          var regExp = new RegExp(\"[\\\\\\\\/]\".concat(item.replace(/[-[\\]{}()*+?.\\\\^$|]/g, \"\\\\$&\"), \"([\\\\\\\\/]|$|!|\\\\?)\"));\n          return function (ident) {\n            return regExp.test(ident);\n          };\n        }\n        if (item && _typeof(item) === \"object\" && typeof item.test === \"function\") {\n          return function (ident) {\n            return item.test(ident);\n          };\n        }\n        if (typeof item === \"function\") {\n          return item;\n        }\n        if (typeof item === \"boolean\") {\n          return function () {\n            return item;\n          };\n        }\n      };\n\n      /**\n       * @enum {number}\n       */\n      var LogLevel = {\n        none: 6,\n        false: 6,\n        error: 5,\n        warn: 4,\n        info: 3,\n        log: 2,\n        true: 2,\n        verbose: 1\n      };\n\n      /**\n       * @param {LoggerOptions} options options object\n       * @returns {LoggingFunction} logging function\n       */\n      module.exports = function (_ref) {\n        var _ref$level = _ref.level,\n          level = _ref$level === void 0 ? \"info\" : _ref$level,\n          _ref$debug = _ref.debug,\n          debug = _ref$debug === void 0 ? false : _ref$debug,\n          console = _ref.console;\n        var debugFilters = /** @type {FilterFunction[]} */\n\n        typeof debug === \"boolean\" ? [function () {\n          return debug;\n        }] : /** @type {FilterItemTypes[]} */[].concat(debug).map(filterToFunction);\n        var loglevel = LogLevel[\"\".concat(level)] || 0;\n\n        /**\n         * @param {string} name name of the logger\n         * @param {LogTypeEnum} type type of the log entry\n         * @param {EXPECTED_ANY[]=} args arguments of the log entry\n         * @returns {void}\n         */\n        var logger = function logger(name, type, args) {\n          var labeledArgs = function labeledArgs() {\n            if (Array.isArray(args)) {\n              if (args.length > 0 && typeof args[0] === \"string\") {\n                return [\"[\".concat(name, \"] \").concat(args[0])].concat(_toConsumableArray(args.slice(1)));\n              }\n              return [\"[\".concat(name, \"]\")].concat(_toConsumableArray(args));\n            }\n            return [];\n          };\n          var debug = debugFilters.some(function (f) {\n            return f(name);\n          });\n          switch (type) {\n            case LogType.debug:\n              if (!debug) return;\n              if (typeof console.debug === \"function\") {\n                console.debug.apply(console, _toConsumableArray(labeledArgs()));\n              } else {\n                console.log.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.log:\n              if (!debug && loglevel > LogLevel.log) return;\n              console.log.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.info:\n              if (!debug && loglevel > LogLevel.info) return;\n              console.info.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.warn:\n              if (!debug && loglevel > LogLevel.warn) return;\n              console.warn.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.error:\n              if (!debug && loglevel > LogLevel.error) return;\n              console.error.apply(console, _toConsumableArray(labeledArgs()));\n              break;\n            case LogType.trace:\n              if (!debug) return;\n              console.trace();\n              break;\n            case LogType.groupCollapsed:\n              if (!debug && loglevel > LogLevel.log) return;\n              if (!debug && loglevel > LogLevel.verbose) {\n                if (typeof console.groupCollapsed === \"function\") {\n                  console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));\n                } else {\n                  console.log.apply(console, _toConsumableArray(labeledArgs()));\n                }\n                break;\n              }\n            // falls through\n            case LogType.group:\n              if (!debug && loglevel > LogLevel.log) return;\n              if (typeof console.group === \"function\") {\n                console.group.apply(console, _toConsumableArray(labeledArgs()));\n              } else {\n                console.log.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.groupEnd:\n              if (!debug && loglevel > LogLevel.log) return;\n              if (typeof console.groupEnd === \"function\") {\n                console.groupEnd();\n              }\n              break;\n            case LogType.time:\n              {\n                if (!debug && loglevel > LogLevel.log) return;\n                var _args = _slicedToArray(/** @type {[string, number, number]} */\n                  args, 3),\n                  label = _args[0],\n                  start = _args[1],\n                  end = _args[2];\n                var ms = start * 1000 + end / 1000000;\n                var msg = \"[\".concat(name, \"] \").concat(label, \": \").concat(ms, \" ms\");\n                if (typeof console.logTime === \"function\") {\n                  console.logTime(msg);\n                } else {\n                  console.log(msg);\n                }\n                break;\n              }\n            case LogType.profile:\n              if (typeof console.profile === \"function\") {\n                console.profile.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.profileEnd:\n              if (typeof console.profileEnd === \"function\") {\n                console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            case LogType.clear:\n              if (!debug && loglevel > LogLevel.log) return;\n              if (typeof console.clear === \"function\") {\n                console.clear();\n              }\n              break;\n            case LogType.status:\n              if (!debug && loglevel > LogLevel.info) return;\n              if (typeof console.status === \"function\") {\n                if (!args || args.length === 0) {\n                  console.status();\n                } else {\n                  console.status.apply(console, _toConsumableArray(labeledArgs()));\n                }\n              } else if (args && args.length !== 0) {\n                console.info.apply(console, _toConsumableArray(labeledArgs()));\n              }\n              break;\n            default:\n              throw new Error(\"Unexpected LogType \".concat(type));\n          }\n        };\n        return logger;\n      };\n\n      /***/\n    }),\n    /***/\"./node_modules/webpack/lib/logging/runtime.js\": (\n    /*!*****************************************************!*\\\n      !*** ./node_modules/webpack/lib/logging/runtime.js ***!\n      \\*****************************************************/\n    /***/\n    function (module, __unused_webpack_exports, __webpack_require__) {\n      /*\n      \tMIT License http://www.opensource.org/licenses/mit-license.php\n      \tAuthor Tobias Koppers @sokra\n      */\n\n      function _extends() {\n        return _extends = Object.assign ? Object.assign.bind() : function (n) {\n          for (var e = 1; e < arguments.length; e++) {\n            var t = arguments[e];\n            for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n          }\n          return n;\n        }, _extends.apply(null, arguments);\n      }\n      var _require = __webpack_require__(/*! tapable */\"./client-src/modules/logger/tapable.js\"),\n        SyncBailHook = _require.SyncBailHook;\n      var _require2 = __webpack_require__(/*! ./Logger */\"./node_modules/webpack/lib/logging/Logger.js\"),\n        Logger = _require2.Logger;\n      var createConsoleLogger = __webpack_require__(/*! ./createConsoleLogger */\"./node_modules/webpack/lib/logging/createConsoleLogger.js\");\n\n      /** @type {createConsoleLogger.LoggerOptions} */\n      var currentDefaultLoggerOptions = {\n        level: \"info\",\n        debug: false,\n        console: console\n      };\n      var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n\n      /**\n       * @param {string} name name of the logger\n       * @returns {Logger} a logger\n       */\n      module.exports.getLogger = function (name) {\n        return new Logger(function (type, args) {\n          if (module.exports.hooks.log.call(name, type, args) === undefined) {\n            currentDefaultLogger(name, type, args);\n          }\n        }, function (childName) {\n          return module.exports.getLogger(\"\".concat(name, \"/\").concat(childName));\n        });\n      };\n\n      /**\n       * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options\n       * @returns {void}\n       */\n      module.exports.configureDefaultLogger = function (options) {\n        _extends(currentDefaultLoggerOptions, options);\n        currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);\n      };\n      module.exports.hooks = {\n        log: new SyncBailHook([\"origin\", \"type\", \"args\"])\n      };\n\n      /***/\n    })\n\n    /******/\n  };\n  /************************************************************************/\n  /******/ // The module cache\n  /******/\n  var __webpack_module_cache__ = {};\n  /******/\n  /******/ // The require function\n  /******/\n  function __webpack_require__(moduleId) {\n    /******/ // Check if module is in cache\n    /******/var cachedModule = __webpack_module_cache__[moduleId];\n    /******/\n    if (cachedModule !== undefined) {\n      /******/return cachedModule.exports;\n      /******/\n    }\n    /******/ // Create a new module (and put it into the cache)\n    /******/\n    var module = __webpack_module_cache__[moduleId] = {\n      /******/ // no module.id needed\n      /******/ // no module.loaded needed\n      /******/exports: {}\n      /******/\n    };\n    /******/\n    /******/ // Execute the module function\n    /******/\n    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n    /******/\n    /******/ // Return the exports of the module\n    /******/\n    return module.exports;\n    /******/\n  }\n  /******/\n  /************************************************************************/\n  /******/ /* webpack/runtime/define property getters */\n  /******/\n  !function () {\n    /******/ // define getter functions for harmony exports\n    /******/__webpack_require__.d = function (exports, definition) {\n      /******/for (var key in definition) {\n        /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n          /******/Object.defineProperty(exports, key, {\n            enumerable: true,\n            get: definition[key]\n          });\n          /******/\n        }\n        /******/\n      }\n      /******/\n    };\n    /******/\n  }();\n  /******/\n  /******/ /* webpack/runtime/hasOwnProperty shorthand */\n  /******/\n  !function () {\n    /******/__webpack_require__.o = function (obj, prop) {\n      return Object.prototype.hasOwnProperty.call(obj, prop);\n    };\n    /******/\n  }();\n  /******/\n  /******/ /* webpack/runtime/make namespace object */\n  /******/\n  !function () {\n    /******/ // define __esModule on exports\n    /******/__webpack_require__.r = function (exports) {\n      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n        /******/Object.defineProperty(exports, Symbol.toStringTag, {\n          value: 'Module'\n        });\n        /******/\n      }\n      /******/\n      Object.defineProperty(exports, '__esModule', {\n        value: true\n      });\n      /******/\n    };\n    /******/\n  }();\n  /******/\n  /************************************************************************/\n  var __webpack_exports__ = {};\n  // This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.\n  !function () {\n    /*!********************************************!*\\\n      !*** ./client-src/modules/logger/index.js ***!\n      \\********************************************/\n    __webpack_require__.r(__webpack_exports__);\n    /* harmony export */\n    __webpack_require__.d(__webpack_exports__, {\n      /* harmony export */\"default\": function () {\n        return /* reexport default export from named module */webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__;\n      }\n      /* harmony export */\n    });\n    /* harmony import */\n    var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/lib/logging/runtime.js */\"./node_modules/webpack/lib/logging/runtime.js\");\n  }();\n  var __webpack_export_target__ = exports;\n  for (var __webpack_i__ in __webpack_exports__) __webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];\n  if (__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", {\n    value: true\n  });\n  /******/\n})();","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}