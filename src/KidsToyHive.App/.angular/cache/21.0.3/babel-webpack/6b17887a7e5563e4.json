{"ast":null,"code":"import _asyncToGenerator from \"C:/projects/KidsToyHive/src/KidsToyHive.App/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v21.0.5\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nexport { AsyncPipe, CommonModule, CurrencyPipe, DATE_PIPE_DEFAULT_OPTIONS, DATE_PIPE_DEFAULT_TIMEZONE, DatePipe, DecimalPipe, FormStyle, FormatWidth, HashLocationStrategy, I18nPluralPipe, I18nSelectPipe, JsonPipe, KeyValuePipe, LowerCasePipe, NgClass, NgComponentOutlet, NgForOf as NgFor, NgForOf, NgForOfContext, NgIf, NgIfContext, NgLocaleLocalization, NgLocalization, NgPlural, NgPluralCase, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgTemplateOutlet, NumberFormatStyle, NumberSymbol, PercentPipe, Plural, SlicePipe, TitleCasePipe, TranslationWidth, UpperCasePipe, WeekDay, formatCurrency, formatDate, formatNumber, formatPercent, getCurrencySymbol, getLocaleCurrencyCode, getLocaleCurrencyName, getLocaleCurrencySymbol, getLocaleDateFormat, getLocaleDateTimeFormat, getLocaleDayNames, getLocaleDayPeriods, getLocaleDirection, getLocaleEraNames, getLocaleExtraDayPeriodRules, getLocaleExtraDayPeriods, getLocaleFirstDayOfWeek, getLocaleId, getLocaleMonthNames, getLocaleNumberFormat, getLocaleNumberSymbol, getLocalePluralCase, getLocaleTimeFormat, getLocaleWeekEndRange, getNumberOfCurrencyDigits } from './_common_module-chunk.mjs';\nimport * as i0 from '@angular/core';\nimport { inject, DestroyRef, Injectable, ɵregisterLocaleData as _registerLocaleData, Version, ɵɵdefineInjectable as __defineInjectable, DOCUMENT, ɵformatRuntimeError as _formatRuntimeError, InjectionToken, ɵRuntimeError as _RuntimeError, ɵIMAGE_CONFIG as _IMAGE_CONFIG, Renderer2, ElementRef, Injector, ɵperformanceMarkFeature as _performanceMarkFeature, NgZone, ApplicationRef, numberAttribute, booleanAttribute, Directive, Input, ɵIMAGE_CONFIG_DEFAULTS as _IMAGE_CONFIG_DEFAULTS, ɵunwrapSafeValue as _unwrapSafeValue, ChangeDetectorRef } from '@angular/core';\nexport { DOCUMENT, ɵIMAGE_CONFIG as IMAGE_CONFIG } from '@angular/core';\nimport { PlatformNavigation } from './_platform_navigation-chunk.mjs';\nexport { XhrFactory, parseCookieValue as ɵparseCookieValue } from './_xhr-chunk.mjs';\nimport { Location, LocationStrategy, normalizeQueryParams } from './_location-chunk.mjs';\nexport { APP_BASE_HREF, PathLocationStrategy } from './_location-chunk.mjs';\nexport { BrowserPlatformLocation, LOCATION_INITIALIZED, PlatformLocation, DomAdapter as ɵDomAdapter, getDOM as ɵgetDOM, setRootDomAdapter as ɵsetRootDomAdapter } from './_platform_location-chunk.mjs';\nimport 'rxjs';\nlet NavigationAdapterForLocation = /*#__PURE__*/(() => {\n  class NavigationAdapterForLocation extends Location {\n    navigation = inject(PlatformNavigation);\n    destroyRef = inject(DestroyRef);\n    constructor() {\n      super(inject(LocationStrategy));\n      this.registerNavigationListeners();\n    }\n    registerNavigationListeners() {\n      const currentEntryChangeListener = () => {\n        this._notifyUrlChangeListeners(this.path(true), this.getState());\n      };\n      this.navigation.addEventListener('currententrychange', currentEntryChangeListener);\n      this.destroyRef.onDestroy(() => {\n        this.navigation.removeEventListener('currententrychange', currentEntryChangeListener);\n      });\n    }\n    getState() {\n      return this.navigation.currentEntry?.getState();\n    }\n    replaceState(path, query = '', state = null) {\n      const url = this.prepareExternalUrl(path + normalizeQueryParams(query));\n      this.navigation.navigate(url, {\n        state,\n        history: 'replace'\n      });\n    }\n    go(path, query = '', state = null) {\n      const url = this.prepareExternalUrl(path + normalizeQueryParams(query));\n      this.navigation.navigate(url, {\n        state,\n        history: 'push'\n      });\n    }\n    back() {\n      this.navigation.back();\n    }\n    forward() {\n      this.navigation.forward();\n    }\n    onUrlChange(fn) {\n      this._urlChangeListeners.push(fn);\n      return () => {\n        const fnIndex = this._urlChangeListeners.indexOf(fn);\n        this._urlChangeListeners.splice(fnIndex, 1);\n      };\n    }\n    static ɵfac = function NavigationAdapterForLocation_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NavigationAdapterForLocation)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NavigationAdapterForLocation,\n      factory: NavigationAdapterForLocation.ɵfac\n    });\n  }\n  return NavigationAdapterForLocation;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction registerLocaleData(data, localeId, extraData) {\n  return _registerLocaleData(data, localeId, extraData);\n}\nconst PLATFORM_BROWSER_ID = 'browser';\nconst PLATFORM_SERVER_ID = 'server';\nfunction isPlatformBrowser(platformId) {\n  return platformId === PLATFORM_BROWSER_ID;\n}\nfunction isPlatformServer(platformId) {\n  return platformId === PLATFORM_SERVER_ID;\n}\nconst VERSION = /* @__PURE__ */new Version('21.0.5');\nlet ViewportScroller = /*#__PURE__*/(() => {\n  class ViewportScroller {\n    static ɵprov = /* @__PURE__ */\n    __defineInjectable({\n      token: ViewportScroller,\n      providedIn: 'root',\n      factory: () => typeof ngServerMode !== 'undefined' && ngServerMode ? new NullViewportScroller() : new BrowserViewportScroller(inject(DOCUMENT), window)\n    });\n  }\n  return ViewportScroller;\n})();\nclass BrowserViewportScroller {\n  document;\n  window;\n  offset = () => [0, 0];\n  constructor(document, window) {\n    this.document = document;\n    this.window = window;\n  }\n  setOffset(offset) {\n    if (Array.isArray(offset)) {\n      this.offset = () => offset;\n    } else {\n      this.offset = offset;\n    }\n  }\n  getScrollPosition() {\n    return [this.window.scrollX, this.window.scrollY];\n  }\n  scrollToPosition(position, options) {\n    this.window.scrollTo({\n      ...options,\n      left: position[0],\n      top: position[1]\n    });\n  }\n  scrollToAnchor(target, options) {\n    const elSelected = findAnchorFromDocument(this.document, target);\n    if (elSelected) {\n      this.scrollToElement(elSelected, options);\n      elSelected.focus();\n    }\n  }\n  setHistoryScrollRestoration(scrollRestoration) {\n    try {\n      this.window.history.scrollRestoration = scrollRestoration;\n    } catch {\n      console.warn(_formatRuntimeError(2400, ngDevMode && 'Failed to set `window.history.scrollRestoration`. ' + 'This may occur when:\\n' + '• The script is running inside a sandboxed iframe\\n' + '• The window is partially navigated or inactive\\n' + '• The script is executed in an untrusted or special context (e.g., test runners, browser extensions, or content previews)\\n' + 'Scroll position may not be preserved across navigation.'));\n    }\n  }\n  scrollToElement(el, options) {\n    const rect = el.getBoundingClientRect();\n    const left = rect.left + this.window.pageXOffset;\n    const top = rect.top + this.window.pageYOffset;\n    const offset = this.offset();\n    this.window.scrollTo({\n      ...options,\n      left: left - offset[0],\n      top: top - offset[1]\n    });\n  }\n}\nfunction findAnchorFromDocument(document, target) {\n  const documentResult = document.getElementById(target) || document.getElementsByName(target)[0];\n  if (documentResult) {\n    return documentResult;\n  }\n  if (typeof document.createTreeWalker === 'function' && document.body && typeof document.body.attachShadow === 'function') {\n    const treeWalker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);\n    let currentNode = treeWalker.currentNode;\n    while (currentNode) {\n      const shadowRoot = currentNode.shadowRoot;\n      if (shadowRoot) {\n        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name=\"${target}\"]`);\n        if (result) {\n          return result;\n        }\n      }\n      currentNode = treeWalker.nextNode();\n    }\n  }\n  return null;\n}\nclass NullViewportScroller {\n  setOffset(offset) {}\n  getScrollPosition() {\n    return [0, 0];\n  }\n  scrollToPosition(position) {}\n  scrollToAnchor(anchor) {}\n  setHistoryScrollRestoration(scrollRestoration) {}\n}\nconst PLACEHOLDER_QUALITY = '20';\nfunction getUrl(src, win) {\n  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);\n}\nfunction isAbsoluteUrl(src) {\n  return /^https?:\\/\\//.test(src);\n}\nfunction extractHostname(url) {\n  return isAbsoluteUrl(url) ? new URL(url).hostname : url;\n}\nfunction isValidPath(path) {\n  const isString = typeof path === 'string';\n  if (!isString || path.trim() === '') {\n    return false;\n  }\n  try {\n    const url = new URL(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction normalizePath(path) {\n  return path.endsWith('/') ? path.slice(0, -1) : path;\n}\nfunction normalizeSrc(src) {\n  return src.startsWith('/') ? src.slice(1) : src;\n}\nconst noopImageLoader = config => config.src;\nconst IMAGE_LOADER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ImageLoader' : '', {\n  factory: () => noopImageLoader\n});\nfunction createImageLoader(buildUrlFn, exampleUrls) {\n  return function provideImageLoader(path) {\n    if (!isValidPath(path)) {\n      throwInvalidPathError(path, exampleUrls || []);\n    }\n    path = normalizePath(path);\n    const loaderFn = config => {\n      if (isAbsoluteUrl(config.src)) {\n        throwUnexpectedAbsoluteUrlError(path, config.src);\n      }\n      return buildUrlFn(path, {\n        ...config,\n        src: normalizeSrc(config.src)\n      });\n    };\n    const providers = [{\n      provide: IMAGE_LOADER,\n      useValue: loaderFn\n    }];\n    return providers;\n  };\n}\nfunction throwInvalidPathError(path, exampleUrls) {\n  throw new _RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\\`${path}\\`). ` + `To fix this, supply a path using one of the following formats: ${exampleUrls.join(' or ')}`);\n}\nfunction throwUnexpectedAbsoluteUrlError(path, url) {\n  throw new _RuntimeError(2959, ngDevMode && `Image loader has detected a \\`<img>\\` tag with an invalid \\`ngSrc\\` attribute: ${url}. ` + `This image loader expects \\`ngSrc\\` to be a relative URL - ` + `however the provided value is an absolute URL. ` + `To fix this, provide \\`ngSrc\\` as a path relative to the base URL ` + `configured for this loader (\\`${path}\\`).`);\n}\nconst provideCloudflareLoader = /*#__PURE__*/createImageLoader(createCloudflareUrl, ngDevMode ? ['https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>'] : undefined);\nfunction createCloudflareUrl(path, config) {\n  let params = `format=auto`;\n  if (config.width) {\n    params += `,width=${config.width}`;\n  }\n  if (config.isPlaceholder) {\n    params += `,quality=${PLACEHOLDER_QUALITY}`;\n  }\n  return `${path}/cdn-cgi/image/${params}/${config.src}`;\n}\nconst cloudinaryLoaderInfo = {\n  name: 'Cloudinary',\n  testUrl: isCloudinaryUrl\n};\nconst CLOUDINARY_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.cloudinary\\.com\\/.+/;\nfunction isCloudinaryUrl(url) {\n  return CLOUDINARY_LOADER_REGEX.test(url);\n}\nconst provideCloudinaryLoader = /*#__PURE__*/createImageLoader(createCloudinaryUrl, ngDevMode ? ['https://res.cloudinary.com/mysite', 'https://mysite.cloudinary.com', 'https://subdomain.mysite.com'] : undefined);\nfunction createCloudinaryUrl(path, config) {\n  const quality = config.isPlaceholder ? 'q_auto:low' : 'q_auto';\n  let params = `f_auto,${quality}`;\n  if (config.width) {\n    params += `,w_${config.width}`;\n  }\n  if (config.loaderParams?.['rounded']) {\n    params += `,r_max`;\n  }\n  return `${path}/image/upload/${params}/${config.src}`;\n}\nconst imageKitLoaderInfo = {\n  name: 'ImageKit',\n  testUrl: isImageKitUrl\n};\nconst IMAGE_KIT_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.imagekit\\.io\\/.+/;\nfunction isImageKitUrl(url) {\n  return IMAGE_KIT_LOADER_REGEX.test(url);\n}\nconst provideImageKitLoader = /*#__PURE__*/createImageLoader(createImagekitUrl, ngDevMode ? ['https://ik.imagekit.io/mysite', 'https://subdomain.mysite.com'] : undefined);\nfunction createImagekitUrl(path, config) {\n  const {\n    src,\n    width\n  } = config;\n  const params = [];\n  if (width) {\n    params.push(`w-${width}`);\n  }\n  if (config.isPlaceholder) {\n    params.push(`q-${PLACEHOLDER_QUALITY}`);\n  }\n  const urlSegments = params.length ? [path, `tr:${params.join(',')}`, src] : [path, src];\n  const url = new URL(urlSegments.join('/'));\n  return url.href;\n}\nconst imgixLoaderInfo = {\n  name: 'Imgix',\n  testUrl: isImgixUrl\n};\nconst IMGIX_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.imgix\\.net\\/.+/;\nfunction isImgixUrl(url) {\n  return IMGIX_LOADER_REGEX.test(url);\n}\nconst provideImgixLoader = /*#__PURE__*/createImageLoader(createImgixUrl, ngDevMode ? ['https://somepath.imgix.net/'] : undefined);\nfunction createImgixUrl(path, config) {\n  const url = new URL(`${path}/${config.src}`);\n  url.searchParams.set('auto', 'format');\n  if (config.width) {\n    url.searchParams.set('w', config.width.toString());\n  }\n  if (config.isPlaceholder) {\n    url.searchParams.set('q', PLACEHOLDER_QUALITY);\n  }\n  return url.href;\n}\nconst netlifyLoaderInfo = {\n  name: 'Netlify',\n  testUrl: isNetlifyUrl\n};\nconst NETLIFY_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.netlify\\.app\\/.+/;\nfunction isNetlifyUrl(url) {\n  return NETLIFY_LOADER_REGEX.test(url);\n}\nfunction provideNetlifyLoader(path) {\n  if (path && !isValidPath(path)) {\n    throw new _RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\\`${path}\\`). ` + `To fix this, supply either the full URL to the Netlify site, or leave it empty to use the current site.`);\n  }\n  if (path) {\n    const url = new URL(path);\n    path = url.origin;\n  }\n  const loaderFn = config => {\n    return createNetlifyUrl(config, path);\n  };\n  const providers = [{\n    provide: IMAGE_LOADER,\n    useValue: loaderFn\n  }];\n  return providers;\n}\nconst validParams = /*#__PURE__*/new Map([['height', 'h'], ['fit', 'fit'], ['quality', 'q'], ['q', 'q'], ['position', 'position']]);\nfunction createNetlifyUrl(config, path) {\n  const url = new URL(path ?? 'https://a/');\n  url.pathname = '/.netlify/images';\n  if (!isAbsoluteUrl(config.src) && !config.src.startsWith('/')) {\n    config.src = '/' + config.src;\n  }\n  url.searchParams.set('url', config.src);\n  if (config.width) {\n    url.searchParams.set('w', config.width.toString());\n  }\n  const configQuality = config.loaderParams?.['quality'] ?? config.loaderParams?.['q'];\n  if (config.isPlaceholder && !configQuality) {\n    url.searchParams.set('q', PLACEHOLDER_QUALITY);\n  }\n  for (const [param, value] of Object.entries(config.loaderParams ?? {})) {\n    if (validParams.has(param)) {\n      url.searchParams.set(validParams.get(param), value.toString());\n    } else {\n      if (ngDevMode) {\n        console.warn(_formatRuntimeError(2959, `The Netlify image loader has detected an \\`<img>\\` tag with the unsupported attribute \"\\`${param}\\`\".`));\n      }\n    }\n  }\n  return url.hostname === 'a' ? url.href.replace(url.origin, '') : url.href;\n}\nfunction imgDirectiveDetails(ngSrc, includeNgSrc = true) {\n  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \\`ngSrc=\"${ngSrc}\"\\`) ` : '';\n  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;\n}\nfunction assertDevMode(checkName) {\n  if (!ngDevMode) {\n    throw new _RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. ` + `Please make sure that the prod mode is enabled for production builds.`);\n  }\n}\nlet LCPImageObserver = /*#__PURE__*/(() => {\n  class LCPImageObserver {\n    images = new Map();\n    window = inject(DOCUMENT).defaultView;\n    observer = null;\n    constructor() {\n      assertDevMode('LCP checker');\n      if ((typeof ngServerMode === 'undefined' || !ngServerMode) && typeof PerformanceObserver !== 'undefined') {\n        this.observer = this.initPerformanceObserver();\n      }\n    }\n    initPerformanceObserver() {\n      const observer = new PerformanceObserver(entryList => {\n        const entries = entryList.getEntries();\n        if (entries.length === 0) return;\n        const lcpElement = entries[entries.length - 1];\n        const imgSrc = lcpElement.element?.src ?? '';\n        if (imgSrc.startsWith('data:') || imgSrc.startsWith('blob:')) return;\n        const img = this.images.get(imgSrc);\n        if (!img) return;\n        if (!img.priority && !img.alreadyWarnedPriority) {\n          img.alreadyWarnedPriority = true;\n          logMissingPriorityError(imgSrc);\n        }\n        if (img.modified && !img.alreadyWarnedModified) {\n          img.alreadyWarnedModified = true;\n          logModifiedWarning(imgSrc);\n        }\n      });\n      observer.observe({\n        type: 'largest-contentful-paint',\n        buffered: true\n      });\n      return observer;\n    }\n    registerImage(rewrittenSrc, originalNgSrc, isPriority) {\n      if (!this.observer) return;\n      const newObservedImageState = {\n        priority: isPriority,\n        modified: false,\n        alreadyWarnedModified: false,\n        alreadyWarnedPriority: false\n      };\n      this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);\n    }\n    unregisterImage(rewrittenSrc) {\n      if (!this.observer) return;\n      this.images.delete(getUrl(rewrittenSrc, this.window).href);\n    }\n    updateImage(originalSrc, newSrc) {\n      if (!this.observer) return;\n      const originalUrl = getUrl(originalSrc, this.window).href;\n      const img = this.images.get(originalUrl);\n      if (img) {\n        img.modified = true;\n        this.images.set(getUrl(newSrc, this.window).href, img);\n        this.images.delete(originalUrl);\n      }\n    }\n    ngOnDestroy() {\n      if (!this.observer) return;\n      this.observer.disconnect();\n      this.images.clear();\n    }\n    static ɵfac = function LCPImageObserver_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || LCPImageObserver)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LCPImageObserver,\n      factory: LCPImageObserver.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return LCPImageObserver;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction logMissingPriorityError(ngSrc) {\n  const directiveDetails = imgDirectiveDetails(ngSrc);\n  console.error(_formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) ` + `element but was not marked \"priority\". This image should be marked ` + `\"priority\" in order to prioritize its loading. ` + `To fix this, add the \"priority\" attribute.`));\n}\nfunction logModifiedWarning(ngSrc) {\n  const directiveDetails = imgDirectiveDetails(ngSrc);\n  console.warn(_formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) ` + `element and has had its \"ngSrc\" attribute modified. This can cause ` + `slower loading performance. It is recommended not to modify the \"ngSrc\" ` + `property on any image which could be the LCP element.`));\n}\nconst INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /*#__PURE__*/new Set(['localhost', '127.0.0.1', '0.0.0.0', '[::1]']);\nconst PRECONNECT_CHECK_BLOCKLIST = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'PRECONNECT_CHECK_BLOCKLIST' : '');\nlet PreconnectLinkChecker = /*#__PURE__*/(() => {\n  class PreconnectLinkChecker {\n    document = inject(DOCUMENT);\n    preconnectLinks = null;\n    alreadySeen = new Set();\n    window = this.document.defaultView;\n    blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);\n    constructor() {\n      assertDevMode('preconnect link checker');\n      const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {\n        optional: true\n      });\n      if (blocklist) {\n        this.populateBlocklist(blocklist);\n      }\n    }\n    populateBlocklist(origins) {\n      if (Array.isArray(origins)) {\n        deepForEach(origins, origin => {\n          this.blocklist.add(extractHostname(origin));\n        });\n      } else {\n        this.blocklist.add(extractHostname(origins));\n      }\n    }\n    assertPreconnect(rewrittenSrc, originalNgSrc) {\n      if (typeof ngServerMode !== 'undefined' && ngServerMode) return;\n      const imgUrl = getUrl(rewrittenSrc, this.window);\n      if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;\n      this.alreadySeen.add(imgUrl.origin);\n      this.preconnectLinks ??= this.queryPreconnectLinks();\n      if (!this.preconnectLinks.has(imgUrl.origin)) {\n        console.warn(_formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this ` + `image. Preconnecting to the origin(s) that serve priority images ensures that these ` + `images are delivered as soon as possible. To fix this, please add the following ` + `element into the <head> of the document:\\n` + `  <link rel=\"preconnect\" href=\"${imgUrl.origin}\">`));\n      }\n    }\n    queryPreconnectLinks() {\n      const preconnectUrls = new Set();\n      const links = this.document.querySelectorAll('link[rel=preconnect]');\n      for (const link of links) {\n        const url = getUrl(link.href, this.window);\n        preconnectUrls.add(url.origin);\n      }\n      return preconnectUrls;\n    }\n    ngOnDestroy() {\n      this.preconnectLinks?.clear();\n      this.alreadySeen.clear();\n    }\n    static ɵfac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PreconnectLinkChecker)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PreconnectLinkChecker,\n      factory: PreconnectLinkChecker.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PreconnectLinkChecker;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction deepForEach(input, fn) {\n  for (let value of input) {\n    Array.isArray(value) ? deepForEach(value, fn) : fn(value);\n  }\n}\nconst DEFAULT_PRELOADED_IMAGES_LIMIT = 5;\nconst PRELOADED_IMAGES = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'NG_OPTIMIZED_PRELOADED_IMAGES' : '', {\n  factory: () => new Set()\n});\nlet PreloadLinkCreator = /*#__PURE__*/(() => {\n  class PreloadLinkCreator {\n    preloadedImages = inject(PRELOADED_IMAGES);\n    document = inject(DOCUMENT);\n    errorShown = false;\n    createPreloadLinkTag(renderer, src, srcset, sizes) {\n      if (ngDevMode && !this.errorShown && this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {\n        this.errorShown = true;\n        console.warn(_formatRuntimeError(2961, `The \\`NgOptimizedImage\\` directive has detected that more than ` + `${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. ` + `This might negatively affect an overall performance of the page. ` + `To fix this, remove the \"priority\" attribute from images with less priority.`));\n      }\n      if (this.preloadedImages.has(src)) {\n        return;\n      }\n      this.preloadedImages.add(src);\n      const preload = renderer.createElement('link');\n      renderer.setAttribute(preload, 'as', 'image');\n      renderer.setAttribute(preload, 'href', src);\n      renderer.setAttribute(preload, 'rel', 'preload');\n      renderer.setAttribute(preload, 'fetchpriority', 'high');\n      if (sizes) {\n        renderer.setAttribute(preload, 'imageSizes', sizes);\n      }\n      if (srcset) {\n        renderer.setAttribute(preload, 'imageSrcset', srcset);\n      }\n      renderer.appendChild(this.document.head, preload);\n    }\n    static ɵfac = function PreloadLinkCreator_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || PreloadLinkCreator)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: PreloadLinkCreator,\n      factory: PreloadLinkCreator.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return PreloadLinkCreator;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;\nconst VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\\s*\\d+w\\s*(,|$)){1,})$/;\nconst VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\\s*\\d+(\\.\\d+)?x\\s*(,|$)){1,})$/;\nconst ABSOLUTE_SRCSET_DENSITY_CAP = 3;\nconst RECOMMENDED_SRCSET_DENSITY_CAP = 2;\nconst DENSITY_SRCSET_MULTIPLIERS = [1, 2];\nconst VIEWPORT_BREAKPOINT_CUTOFF = 640;\nconst ASPECT_RATIO_TOLERANCE = 0.1;\nconst OVERSIZED_IMAGE_TOLERANCE = 1000;\nconst FIXED_SRCSET_WIDTH_LIMIT = 1920;\nconst FIXED_SRCSET_HEIGHT_LIMIT = 1080;\nconst PLACEHOLDER_DIMENSION_LIMIT = 1000;\nconst DATA_URL_WARN_LIMIT = 4000;\nconst DATA_URL_ERROR_LIMIT = 10000;\nconst BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];\nconst PRIORITY_COUNT_THRESHOLD = 10;\nlet IMGS_WITH_PRIORITY_ATTR_COUNT = 0;\nlet NgOptimizedImage = /*#__PURE__*/(() => {\n  class NgOptimizedImage {\n    imageLoader = inject(IMAGE_LOADER);\n    config = processConfig(inject(_IMAGE_CONFIG));\n    renderer = inject(Renderer2);\n    imgElement = inject(ElementRef).nativeElement;\n    injector = inject(Injector);\n    destroyRef = inject(DestroyRef);\n    lcpObserver;\n    _renderedSrc = null;\n    ngSrc;\n    ngSrcset;\n    sizes;\n    width;\n    height;\n    decoding;\n    loading;\n    priority = false;\n    loaderParams;\n    disableOptimizedSrcset = false;\n    fill = false;\n    placeholder;\n    placeholderConfig;\n    src;\n    srcset;\n    constructor() {\n      if (ngDevMode) {\n        this.lcpObserver = this.injector.get(LCPImageObserver);\n        this.destroyRef.onDestroy(() => {\n          if (!this.priority && this._renderedSrc !== null) {\n            this.lcpObserver.unregisterImage(this._renderedSrc);\n          }\n        });\n      }\n    }\n    ngOnInit() {\n      _performanceMarkFeature('NgOptimizedImage');\n      if (ngDevMode) {\n        const ngZone = this.injector.get(NgZone);\n        assertNonEmptyInput(this, 'ngSrc', this.ngSrc);\n        assertValidNgSrcset(this, this.ngSrcset);\n        assertNoConflictingSrc(this);\n        if (this.ngSrcset) {\n          assertNoConflictingSrcset(this);\n        }\n        assertNotBase64Image(this);\n        assertNotBlobUrl(this);\n        if (this.fill) {\n          assertEmptyWidthAndHeight(this);\n          ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer, this.destroyRef));\n        } else {\n          assertNonEmptyWidthAndHeight(this);\n          if (this.height !== undefined) {\n            assertGreaterThanZero(this, this.height, 'height');\n          }\n          if (this.width !== undefined) {\n            assertGreaterThanZero(this, this.width, 'width');\n          }\n          ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer, this.destroyRef));\n        }\n        assertValidLoadingInput(this);\n        assertValidDecodingInput(this);\n        if (!this.ngSrcset) {\n          assertNoComplexSizes(this);\n        }\n        assertValidPlaceholder(this, this.imageLoader);\n        assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);\n        assertNoNgSrcsetWithoutLoader(this, this.imageLoader);\n        assertNoLoaderParamsWithoutLoader(this, this.imageLoader);\n        ngZone.runOutsideAngular(() => {\n          this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);\n        });\n        if (this.priority) {\n          const checker = this.injector.get(PreconnectLinkChecker);\n          checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);\n          if (typeof ngServerMode !== 'undefined' && !ngServerMode) {\n            const applicationRef = this.injector.get(ApplicationRef);\n            assetPriorityCountBelowThreshold(applicationRef);\n          }\n        }\n      }\n      if (this.placeholder) {\n        this.removePlaceholderOnLoad(this.imgElement);\n      }\n      this.setHostAttributes();\n    }\n    setHostAttributes() {\n      if (this.fill) {\n        this.sizes ||= '100vw';\n      } else {\n        this.setHostAttribute('width', this.width.toString());\n        this.setHostAttribute('height', this.height.toString());\n      }\n      this.setHostAttribute('loading', this.getLoadingBehavior());\n      this.setHostAttribute('fetchpriority', this.getFetchPriority());\n      this.setHostAttribute('decoding', this.getDecoding());\n      this.setHostAttribute('ng-img', 'true');\n      const rewrittenSrcset = this.updateSrcAndSrcset();\n      if (this.sizes) {\n        if (this.getLoadingBehavior() === 'lazy') {\n          this.setHostAttribute('sizes', 'auto, ' + this.sizes);\n        } else {\n          this.setHostAttribute('sizes', this.sizes);\n        }\n      } else {\n        if (this.ngSrcset && VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) && this.getLoadingBehavior() === 'lazy') {\n          this.setHostAttribute('sizes', 'auto, 100vw');\n        }\n      }\n      if (typeof ngServerMode !== 'undefined' && ngServerMode && this.priority) {\n        const preloadLinkCreator = this.injector.get(PreloadLinkCreator);\n        preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);\n      }\n    }\n    ngOnChanges(changes) {\n      if (ngDevMode) {\n        assertNoPostInitInputChange(this, changes, ['ngSrcset', 'width', 'height', 'priority', 'fill', 'loading', 'sizes', 'loaderParams', 'disableOptimizedSrcset']);\n      }\n      if (changes['ngSrc'] && !changes['ngSrc'].isFirstChange()) {\n        const oldSrc = this._renderedSrc;\n        this.updateSrcAndSrcset(true);\n        if (ngDevMode) {\n          const newSrc = this._renderedSrc;\n          if (oldSrc && newSrc && oldSrc !== newSrc) {\n            const ngZone = this.injector.get(NgZone);\n            ngZone.runOutsideAngular(() => {\n              this.lcpObserver.updateImage(oldSrc, newSrc);\n            });\n          }\n        }\n      }\n      if (ngDevMode && changes['placeholder']?.currentValue && typeof ngServerMode !== 'undefined' && !ngServerMode) {\n        assertPlaceholderDimensions(this, this.imgElement);\n      }\n    }\n    callImageLoader(configWithoutCustomParams) {\n      let augmentedConfig = configWithoutCustomParams;\n      if (this.loaderParams) {\n        augmentedConfig.loaderParams = this.loaderParams;\n      }\n      return this.imageLoader(augmentedConfig);\n    }\n    getLoadingBehavior() {\n      if (!this.priority && this.loading !== undefined) {\n        return this.loading;\n      }\n      return this.priority ? 'eager' : 'lazy';\n    }\n    getFetchPriority() {\n      return this.priority ? 'high' : 'auto';\n    }\n    getDecoding() {\n      if (this.priority) {\n        return 'sync';\n      }\n      return this.decoding ?? 'auto';\n    }\n    getRewrittenSrc() {\n      if (!this._renderedSrc) {\n        const imgConfig = {\n          src: this.ngSrc\n        };\n        this._renderedSrc = this.callImageLoader(imgConfig);\n      }\n      return this._renderedSrc;\n    }\n    getRewrittenSrcset() {\n      const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);\n      const finalSrcs = this.ngSrcset.split(',').filter(src => src !== '').map(srcStr => {\n        srcStr = srcStr.trim();\n        const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;\n        return `${this.callImageLoader({\n          src: this.ngSrc,\n          width\n        })} ${srcStr}`;\n      });\n      return finalSrcs.join(', ');\n    }\n    getAutomaticSrcset() {\n      if (this.sizes) {\n        return this.getResponsiveSrcset();\n      } else {\n        return this.getFixedSrcset();\n      }\n    }\n    getResponsiveSrcset() {\n      const {\n        breakpoints\n      } = this.config;\n      let filteredBreakpoints = breakpoints;\n      if (this.sizes?.trim() === '100vw') {\n        filteredBreakpoints = breakpoints.filter(bp => bp >= VIEWPORT_BREAKPOINT_CUTOFF);\n      }\n      const finalSrcs = filteredBreakpoints.map(bp => `${this.callImageLoader({\n        src: this.ngSrc,\n        width: bp\n      })} ${bp}w`);\n      return finalSrcs.join(', ');\n    }\n    updateSrcAndSrcset(forceSrcRecalc = false) {\n      if (forceSrcRecalc) {\n        this._renderedSrc = null;\n      }\n      const rewrittenSrc = this.getRewrittenSrc();\n      this.setHostAttribute('src', rewrittenSrc);\n      let rewrittenSrcset = undefined;\n      if (this.ngSrcset) {\n        rewrittenSrcset = this.getRewrittenSrcset();\n      } else if (this.shouldGenerateAutomaticSrcset()) {\n        rewrittenSrcset = this.getAutomaticSrcset();\n      }\n      if (rewrittenSrcset) {\n        this.setHostAttribute('srcset', rewrittenSrcset);\n      }\n      return rewrittenSrcset;\n    }\n    getFixedSrcset() {\n      const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map(multiplier => `${this.callImageLoader({\n        src: this.ngSrc,\n        width: this.width * multiplier\n      })} ${multiplier}x`);\n      return finalSrcs.join(', ');\n    }\n    shouldGenerateAutomaticSrcset() {\n      let oversizedImage = false;\n      if (!this.sizes) {\n        oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;\n      }\n      return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;\n    }\n    generatePlaceholder(placeholderInput) {\n      const {\n        placeholderResolution\n      } = this.config;\n      if (placeholderInput === true) {\n        return `url(${this.callImageLoader({\n          src: this.ngSrc,\n          width: placeholderResolution,\n          isPlaceholder: true\n        })})`;\n      } else if (typeof placeholderInput === 'string') {\n        return `url(${placeholderInput})`;\n      }\n      return null;\n    }\n    shouldBlurPlaceholder(placeholderConfig) {\n      if (!placeholderConfig || !placeholderConfig.hasOwnProperty('blur')) {\n        return true;\n      }\n      return Boolean(placeholderConfig.blur);\n    }\n    removePlaceholderOnLoad(img) {\n      const callback = () => {\n        const changeDetectorRef = this.injector.get(ChangeDetectorRef);\n        removeLoadListenerFn();\n        removeErrorListenerFn();\n        this.placeholder = false;\n        changeDetectorRef.markForCheck();\n      };\n      const removeLoadListenerFn = this.renderer.listen(img, 'load', callback);\n      const removeErrorListenerFn = this.renderer.listen(img, 'error', callback);\n      this.destroyRef.onDestroy(() => {\n        removeLoadListenerFn();\n        removeErrorListenerFn();\n      });\n      callOnLoadIfImageIsLoaded(img, callback);\n    }\n    setHostAttribute(name, value) {\n      this.renderer.setAttribute(this.imgElement, name, value);\n    }\n    static ɵfac = function NgOptimizedImage_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NgOptimizedImage)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgOptimizedImage,\n      selectors: [[\"img\", \"ngSrc\", \"\"]],\n      hostVars: 18,\n      hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"position\", ctx.fill ? \"absolute\" : null)(\"width\", ctx.fill ? \"100%\" : null)(\"height\", ctx.fill ? \"100%\" : null)(\"inset\", ctx.fill ? \"0\" : null)(\"background-size\", ctx.placeholder ? \"cover\" : null)(\"background-position\", ctx.placeholder ? \"50% 50%\" : null)(\"background-repeat\", ctx.placeholder ? \"no-repeat\" : null)(\"background-image\", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)(\"filter\", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? \"blur(15px)\" : null);\n        }\n      },\n      inputs: {\n        ngSrc: [2, \"ngSrc\", \"ngSrc\", unwrapSafeUrl],\n        ngSrcset: \"ngSrcset\",\n        sizes: \"sizes\",\n        width: [2, \"width\", \"width\", numberAttribute],\n        height: [2, \"height\", \"height\", numberAttribute],\n        decoding: \"decoding\",\n        loading: \"loading\",\n        priority: [2, \"priority\", \"priority\", booleanAttribute],\n        loaderParams: \"loaderParams\",\n        disableOptimizedSrcset: [2, \"disableOptimizedSrcset\", \"disableOptimizedSrcset\", booleanAttribute],\n        fill: [2, \"fill\", \"fill\", booleanAttribute],\n        placeholder: [2, \"placeholder\", \"placeholder\", booleanOrUrlAttribute],\n        placeholderConfig: \"placeholderConfig\",\n        src: \"src\",\n        srcset: \"srcset\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgOptimizedImage;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction processConfig(config) {\n  let sortedBreakpoints = {};\n  if (config.breakpoints) {\n    sortedBreakpoints.breakpoints = config.breakpoints.sort((a, b) => a - b);\n  }\n  return Object.assign({}, _IMAGE_CONFIG_DEFAULTS, config, sortedBreakpoints);\n}\nfunction assertNoConflictingSrc(dir) {\n  if (dir.src) {\n    throw new _RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \\`src\\` and \\`ngSrc\\` have been set. ` + `Supplying both of these attributes breaks lazy loading. ` + `The NgOptimizedImage directive sets \\`src\\` itself based on the value of \\`ngSrc\\`. ` + `To fix this, please remove the \\`src\\` attribute.`);\n  }\n}\nfunction assertNoConflictingSrcset(dir) {\n  if (dir.srcset) {\n    throw new _RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \\`srcset\\` and \\`ngSrcset\\` have been set. ` + `Supplying both of these attributes breaks lazy loading. ` + `The NgOptimizedImage directive sets \\`srcset\\` itself based on the value of ` + `\\`ngSrcset\\`. To fix this, please remove the \\`srcset\\` attribute.`);\n  }\n}\nfunction assertNotBase64Image(dir) {\n  let ngSrc = dir.ngSrc.trim();\n  if (ngSrc.startsWith('data:')) {\n    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {\n      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + '...';\n    }\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \\`ngSrc\\` is a Base64-encoded string ` + `(${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. ` + `To fix this, disable the NgOptimizedImage directive for this element ` + `by removing \\`ngSrc\\` and using a standard \\`src\\` attribute instead.`);\n  }\n}\nfunction assertNoComplexSizes(dir) {\n  let sizes = dir.sizes;\n  if (sizes?.match(/((\\)|,)\\s|^)\\d+px/)) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \\`sizes\\` was set to a string including ` + `pixel values. For automatic \\`srcset\\` generation, \\`sizes\\` must only include responsive ` + `values, such as \\`sizes=\"50vw\"\\` or \\`sizes=\"(min-width: 768px) 50vw, 100vw\"\\`. ` + `To fix this, modify the \\`sizes\\` attribute, or provide your own \\`ngSrcset\\` value directly.`);\n  }\n}\nfunction assertValidPlaceholder(dir, imageLoader) {\n  assertNoPlaceholderConfigWithoutPlaceholder(dir);\n  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);\n  assertNoOversizedDataUrl(dir);\n}\nfunction assertNoPlaceholderConfigWithoutPlaceholder(dir) {\n  if (dir.placeholderConfig && !dir.placeholder) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \\`placeholderConfig\\` options were provided for an ` + `image that does not use the \\`placeholder\\` attribute, and will have no effect.`);\n  }\n}\nfunction assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {\n  if (dir.placeholder === true && imageLoader === noopImageLoader) {\n    throw new _RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to true but ` + `no image loader is configured (i.e. the default one is being used), ` + `which would result in the same image being used for the primary image and its placeholder. ` + `To fix this, provide a loader or remove the \\`placeholder\\` attribute from the image.`);\n  }\n}\nfunction assertNoOversizedDataUrl(dir) {\n  if (dir.placeholder && typeof dir.placeholder === 'string' && dir.placeholder.startsWith('data:')) {\n    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {\n      throw new _RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to a data URL which is longer ` + `than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders ` + `directly increase the bundle size of Angular and hurt page load performance. To fix this, generate ` + `a smaller data URL placeholder.`);\n    }\n    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {\n      console.warn(_formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to a data URL which is longer ` + `than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders ` + `directly increase the bundle size of Angular and hurt page load performance. For better loading performance, ` + `generate a smaller data URL placeholder.`));\n    }\n  }\n}\nfunction assertNotBlobUrl(dir) {\n  const ngSrc = dir.ngSrc.trim();\n  if (ngSrc.startsWith('blob:')) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`ngSrc\\` was set to a blob URL (${ngSrc}). ` + `Blob URLs are not supported by the NgOptimizedImage directive. ` + `To fix this, disable the NgOptimizedImage directive for this element ` + `by removing \\`ngSrc\\` and using a regular \\`src\\` attribute instead.`);\n  }\n}\nfunction assertNonEmptyInput(dir, name, value) {\n  const isString = typeof value === 'string';\n  const isEmptyString = isString && value.trim() === '';\n  if (!isString || isEmptyString) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`${name}\\` has an invalid value ` + `(\\`${value}\\`). To fix this, change the value to a non-empty string.`);\n  }\n}\nfunction assertValidNgSrcset(dir, value) {\n  if (value == null) return;\n  assertNonEmptyInput(dir, 'ngSrcset', value);\n  const stringVal = value;\n  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);\n  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);\n  if (isValidDensityDescriptor) {\n    assertUnderDensityCap(dir, stringVal);\n  }\n  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;\n  if (!isValidSrcset) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`ngSrcset\\` has an invalid value (\\`${value}\\`). ` + `To fix this, supply \\`ngSrcset\\` using a comma-separated list of one or more width ` + `descriptors (e.g. \"100w, 200w\") or density descriptors (e.g. \"1x, 2x\").`);\n  }\n}\nfunction assertUnderDensityCap(dir, value) {\n  const underDensityCap = value.split(',').every(num => num === '' || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);\n  if (!underDensityCap) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`ngSrcset\\` contains an unsupported image density:` + `\\`${value}\\`. NgOptimizedImage generally recommends a max image density of ` + `${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ` + `${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities ` + `greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for ` + `most use cases. Images that will be pinch-zoomed are typically the primary use case for ` + `${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);\n  }\n}\nfunction postInitInputChangeError(dir, inputName) {\n  let reason;\n  if (inputName === 'width' || inputName === 'height') {\n    reason = `Changing \\`${inputName}\\` may result in different attribute value ` + `applied to the underlying image element and cause layout shifts on a page.`;\n  } else {\n    reason = `Changing the \\`${inputName}\\` would have no effect on the underlying ` + `image element, because the resource loading has already occurred.`;\n  }\n  return new _RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \\`${inputName}\\` was updated after initialization. ` + `The NgOptimizedImage directive will not react to this input change. ${reason} ` + `To fix this, either switch \\`${inputName}\\` to a static value ` + `or wrap the image element in an @if that is gated on the necessary value.`);\n}\nfunction assertNoPostInitInputChange(dir, changes, inputs) {\n  inputs.forEach(input => {\n    const isUpdated = changes.hasOwnProperty(input);\n    if (isUpdated && !changes[input].isFirstChange()) {\n      if (input === 'ngSrc') {\n        dir = {\n          ngSrc: changes[input].previousValue\n        };\n      }\n      throw postInitInputChangeError(dir, input);\n    }\n  });\n}\nfunction assertGreaterThanZero(dir, inputValue, inputName) {\n  const validNumber = typeof inputValue === 'number' && inputValue > 0;\n  const validString = typeof inputValue === 'string' && /^\\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;\n  if (!validNumber && !validString) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`${inputName}\\` has an invalid value. ` + `To fix this, provide \\`${inputName}\\` as a number greater than 0.`);\n  }\n}\nfunction assertNoImageDistortion(dir, img, renderer, destroyRef) {\n  const callback = () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n    const computedStyle = window.getComputedStyle(img);\n    let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n    let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n    const boxSizing = computedStyle.getPropertyValue('box-sizing');\n    if (boxSizing === 'border-box') {\n      const paddingTop = computedStyle.getPropertyValue('padding-top');\n      const paddingRight = computedStyle.getPropertyValue('padding-right');\n      const paddingBottom = computedStyle.getPropertyValue('padding-bottom');\n      const paddingLeft = computedStyle.getPropertyValue('padding-left');\n      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n    }\n    const renderedAspectRatio = renderedWidth / renderedHeight;\n    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;\n    const intrinsicWidth = img.naturalWidth;\n    const intrinsicHeight = img.naturalHeight;\n    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;\n    const suppliedWidth = dir.width;\n    const suppliedHeight = dir.height;\n    const suppliedAspectRatio = suppliedWidth / suppliedHeight;\n    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;\n    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;\n    if (inaccurateDimensions) {\n      console.warn(_formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match ` + `the aspect ratio indicated by the width and height attributes. ` + `\\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h ` + `(aspect-ratio: ${round(intrinsicAspectRatio)}). \\nSupplied width and height attributes: ` + `${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). ` + `\\nTo fix this, update the width and height attributes.`));\n    } else if (stylingDistortion) {\n      console.warn(_formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image ` + `does not match the image's intrinsic aspect ratio. ` + `\\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h ` + `(aspect-ratio: ${round(intrinsicAspectRatio)}). \\nRendered image size: ` + `${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ` + `${round(renderedAspectRatio)}). \\nThis issue can occur if \"width\" and \"height\" ` + `attributes are added to an image without updating the corresponding ` + `image styling. To fix this, adjust image styling. In most cases, ` + `adding \"height: auto\" or \"width: auto\" to the image styling will fix ` + `this issue.`));\n    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {\n      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;\n      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;\n      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;\n      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;\n      if (oversizedWidth || oversizedHeight) {\n        console.warn(_formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly ` + `larger than necessary. ` + `\\nRendered image size: ${renderedWidth}w x ${renderedHeight}h. ` + `\\nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. ` + `\\nRecommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. ` + `\\nNote: Recommended intrinsic image size is calculated assuming a maximum DPR of ` + `${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image ` + `or consider using the \"ngSrcset\" and \"sizes\" attributes.`));\n      }\n    }\n  };\n  const removeLoadListenerFn = renderer.listen(img, 'load', callback);\n  const removeErrorListenerFn = renderer.listen(img, 'error', () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n  destroyRef.onDestroy(() => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n  callOnLoadIfImageIsLoaded(img, callback);\n}\nfunction assertNonEmptyWidthAndHeight(dir) {\n  let missingAttributes = [];\n  if (dir.width === undefined) missingAttributes.push('width');\n  if (dir.height === undefined) missingAttributes.push('height');\n  if (missingAttributes.length > 0) {\n    throw new _RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes ` + `are missing: ${missingAttributes.map(attr => `\"${attr}\"`).join(', ')}. ` + `Including \"width\" and \"height\" attributes will prevent image-related layout shifts. ` + `To fix this, include \"width\" and \"height\" attributes on the image tag or turn on ` + `\"fill\" mode with the \\`fill\\` attribute.`);\n  }\n}\nfunction assertEmptyWidthAndHeight(dir) {\n  if (dir.width || dir.height) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \\`height\\` and/or \\`width\\` are present ` + `along with the \\`fill\\` attribute. Because \\`fill\\` mode causes an image to fill its containing ` + `element, the size attributes have no effect and should be removed.`);\n  }\n}\nfunction assertNonZeroRenderedHeight(dir, img, renderer, destroyRef) {\n  const callback = () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n    const renderedHeight = img.clientHeight;\n    if (dir.fill && renderedHeight === 0) {\n      console.warn(_formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. ` + `This is likely because the containing element does not have the CSS 'position' ` + `property set to one of the following: \"relative\", \"fixed\", or \"absolute\". ` + `To fix this problem, make sure the container element has the CSS 'position' ` + `property defined and the height of the element is not zero.`));\n    }\n  };\n  const removeLoadListenerFn = renderer.listen(img, 'load', callback);\n  const removeErrorListenerFn = renderer.listen(img, 'error', () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n  destroyRef.onDestroy(() => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n  callOnLoadIfImageIsLoaded(img, callback);\n}\nfunction assertValidLoadingInput(dir) {\n  if (dir.loading && dir.priority) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`loading\\` attribute ` + `was used on an image that was marked \"priority\". ` + `Setting \\`loading\\` on priority images is not allowed ` + `because these images will always be eagerly loaded. ` + `To fix this, remove the “loading” attribute from the priority image.`);\n  }\n  const validInputs = ['auto', 'eager', 'lazy'];\n  if (typeof dir.loading === 'string' && !validInputs.includes(dir.loading)) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`loading\\` attribute ` + `has an invalid value (\\`${dir.loading}\\`). ` + `To fix this, provide a valid value (\"lazy\", \"eager\", or \"auto\").`);\n  }\n}\nfunction assertValidDecodingInput(dir) {\n  const validInputs = ['sync', 'async', 'auto'];\n  if (typeof dir.decoding === 'string' && !validInputs.includes(dir.decoding)) {\n    throw new _RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`decoding\\` attribute ` + `has an invalid value (\\`${dir.decoding}\\`). ` + `To fix this, provide a valid value (\"sync\", \"async\", or \"auto\").`);\n  }\n}\nfunction assertNotMissingBuiltInLoader(ngSrc, imageLoader) {\n  if (imageLoader === noopImageLoader) {\n    let builtInLoaderName = '';\n    for (const loader of BUILT_IN_LOADERS) {\n      if (loader.testUrl(ngSrc)) {\n        builtInLoaderName = loader.name;\n        break;\n      }\n    }\n    if (builtInLoaderName) {\n      console.warn(_formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ` + `${builtInLoaderName} CDN, but your app is not using Angular's ` + `built-in loader for that CDN. We recommend switching to use ` + `the built-in by calling \\`provide${builtInLoaderName}Loader()\\` ` + `in your \\`providers\\` and passing it your instance's base URL. ` + `If you don't want to use the built-in loader, define a custom ` + `loader function using IMAGE_LOADER to silence this warning.`));\n    }\n  }\n}\nfunction assertNoNgSrcsetWithoutLoader(dir, imageLoader) {\n  if (dir.ngSrcset && imageLoader === noopImageLoader) {\n    console.warn(_formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \\`ngSrcset\\` attribute is present but ` + `no image loader is configured (i.e. the default one is being used), ` + `which would result in the same image being used for all configured sizes. ` + `To fix this, provide a loader or remove the \\`ngSrcset\\` attribute from the image.`));\n  }\n}\nfunction assertNoLoaderParamsWithoutLoader(dir, imageLoader) {\n  if (dir.loaderParams && imageLoader === noopImageLoader) {\n    console.warn(_formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \\`loaderParams\\` attribute is present but ` + `no image loader is configured (i.e. the default one is being used), ` + `which means that the loaderParams data will not be consumed and will not affect the URL. ` + `To fix this, provide a custom loader or remove the \\`loaderParams\\` attribute from the image.`));\n  }\n}\nfunction assetPriorityCountBelowThreshold(_x) {\n  return _assetPriorityCountBelowThreshold.apply(this, arguments);\n}\nfunction _assetPriorityCountBelowThreshold() {\n  _assetPriorityCountBelowThreshold = _asyncToGenerator(function* (appRef) {\n    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {\n      IMGS_WITH_PRIORITY_ATTR_COUNT++;\n      yield appRef.whenStable();\n      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {\n        console.warn(_formatRuntimeError(2966, `NgOptimizedImage: The \"priority\" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). ` + `Marking too many images as \"high\" priority can hurt your application's LCP (https://web.dev/lcp). ` + `\"Priority\" should only be set on the image expected to be the page's LCP element.`));\n      }\n    } else {\n      IMGS_WITH_PRIORITY_ATTR_COUNT++;\n    }\n  });\n  return _assetPriorityCountBelowThreshold.apply(this, arguments);\n}\nfunction assertPlaceholderDimensions(dir, imgElement) {\n  const computedStyle = window.getComputedStyle(imgElement);\n  let renderedWidth = parseFloat(computedStyle.getPropertyValue('width'));\n  let renderedHeight = parseFloat(computedStyle.getPropertyValue('height'));\n  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {\n    console.warn(_formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one ` + `of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. ` + `To fix this, use a smaller image as a placeholder.`));\n  }\n}\nfunction callOnLoadIfImageIsLoaded(img, callback) {\n  if (img.complete && img.naturalWidth) {\n    callback();\n  }\n}\nfunction round(input) {\n  return Number.isInteger(input) ? input : input.toFixed(2);\n}\nfunction unwrapSafeUrl(value) {\n  if (typeof value === 'string') {\n    return value;\n  }\n  return _unwrapSafeValue(value);\n}\nfunction booleanOrUrlAttribute(value) {\n  if (typeof value === 'string' && value !== 'true' && value !== 'false' && value !== '') {\n    return value;\n  }\n  return booleanAttribute(value);\n}\nexport { IMAGE_LOADER, Location, LocationStrategy, NgOptimizedImage, PRECONNECT_CHECK_BLOCKLIST, PlatformNavigation, VERSION, ViewportScroller, isPlatformBrowser, isPlatformServer, provideCloudflareLoader, provideCloudinaryLoader, provideImageKitLoader, provideImgixLoader, provideNetlifyLoader, registerLocaleData, NavigationAdapterForLocation as ɵNavigationAdapterForLocation, NullViewportScroller as ɵNullViewportScroller, PLATFORM_BROWSER_ID as ɵPLATFORM_BROWSER_ID, PLATFORM_SERVER_ID as ɵPLATFORM_SERVER_ID, normalizeQueryParams as ɵnormalizeQueryParams };\n//# sourceMappingURL=common.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}