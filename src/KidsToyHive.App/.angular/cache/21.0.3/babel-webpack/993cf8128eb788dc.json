{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { inject, ElementRef, NgZone, Renderer2, ChangeDetectorRef, Injector, DOCUMENT, afterNextRender, Component, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, InjectionToken, TemplateRef, Injectable, signal, EventEmitter, NgModule } from '@angular/core';\nimport { Subject, defer } from 'rxjs';\nimport { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, TemplatePortal, PortalModule } from './portal.mjs';\nfunction CdkDialogContainer_ng_template_0_Template(rf, ctx) {}\nexport { CdkPortal as ɵɵCdkPortal } from './portal.mjs';\nimport { FocusTrapFactory, InteractivityChecker, A11yModule } from './_a11y-module-chunk.mjs';\nimport { FocusMonitor } from './_focus-monitor-chunk.mjs';\nimport { Platform } from './_platform-chunk.mjs';\nimport { _getFocusedElementPierceShadowDom } from './_shadow-dom-chunk.mjs';\nimport { ESCAPE } from './_keycodes-chunk.mjs';\nimport { hasModifierKey } from './keycodes.mjs';\nimport { startWith, take } from 'rxjs/operators';\nimport { createBlockScrollStrategy, OverlayContainer, createOverlayRef, OverlayConfig, createGlobalPositionStrategy, OverlayRef, OverlayModule } from './_overlay-module-chunk.mjs';\nimport { _IdGenerator } from './_id-generator-chunk.mjs';\nimport { Directionality } from './_directionality-chunk.mjs';\nimport './_style-loader-chunk.mjs';\nimport './_visually-hidden-chunk.mjs';\nimport './_breakpoints-observer-chunk.mjs';\nimport './_array-chunk.mjs';\nimport './observers.mjs';\nimport './_element-chunk.mjs';\nimport './_fake-event-detection-chunk.mjs';\nimport './_passive-listeners-chunk.mjs';\nimport '@angular/common';\nimport './_test-environment-chunk.mjs';\nimport './_css-pixel-value-chunk.mjs';\nimport './scrolling.mjs';\nimport './_scrolling-chunk.mjs';\nimport './bidi.mjs';\nimport './_recycle-view-repeater-strategy-chunk.mjs';\nimport './_data-source-chunk.mjs';\nclass DialogConfig {\n  viewContainerRef;\n  injector;\n  id;\n  role = 'dialog';\n  panelClass = '';\n  hasBackdrop = true;\n  backdropClass = '';\n  disableClose = false;\n  closePredicate;\n  width = '';\n  height = '';\n  minWidth;\n  minHeight;\n  maxWidth;\n  maxHeight;\n  positionStrategy;\n  data = null;\n  direction;\n  ariaDescribedBy = null;\n  ariaLabelledBy = null;\n  ariaLabel = null;\n  ariaModal = false;\n  autoFocus = 'first-tabbable';\n  restoreFocus = true;\n  scrollStrategy;\n  closeOnNavigation = true;\n  closeOnDestroy = true;\n  closeOnOverlayDetachments = true;\n  disableAnimations = false;\n  providers;\n  container;\n  templateContext;\n}\nfunction throwDialogContentAlreadyAttachedError() {\n  throw Error('Attempting to attach dialog content after content is already attached');\n}\nlet CdkDialogContainer = /*#__PURE__*/(() => {\n  class CdkDialogContainer extends BasePortalOutlet {\n    _elementRef = inject(ElementRef);\n    _focusTrapFactory = inject(FocusTrapFactory);\n    _config;\n    _interactivityChecker = inject(InteractivityChecker);\n    _ngZone = inject(NgZone);\n    _focusMonitor = inject(FocusMonitor);\n    _renderer = inject(Renderer2);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _injector = inject(Injector);\n    _platform = inject(Platform);\n    _document = inject(DOCUMENT);\n    _portalOutlet;\n    _focusTrapped = new Subject();\n    _focusTrap = null;\n    _elementFocusedBeforeDialogWasOpened = null;\n    _closeInteractionType = null;\n    _ariaLabelledByQueue = [];\n    _isDestroyed = false;\n    constructor() {\n      super();\n      this._config = inject(DialogConfig, {\n        optional: true\n      }) || new DialogConfig();\n      if (this._config.ariaLabelledBy) {\n        this._ariaLabelledByQueue.push(this._config.ariaLabelledBy);\n      }\n    }\n    _addAriaLabelledBy(id) {\n      this._ariaLabelledByQueue.push(id);\n      this._changeDetectorRef.markForCheck();\n    }\n    _removeAriaLabelledBy(id) {\n      const index = this._ariaLabelledByQueue.indexOf(id);\n      if (index > -1) {\n        this._ariaLabelledByQueue.splice(index, 1);\n        this._changeDetectorRef.markForCheck();\n      }\n    }\n    _contentAttached() {\n      this._initializeFocusTrap();\n      this._captureInitialFocus();\n    }\n    _captureInitialFocus() {\n      this._trapFocus();\n    }\n    ngOnDestroy() {\n      this._focusTrapped.complete();\n      this._isDestroyed = true;\n      this._restoreFocus();\n    }\n    attachComponentPortal(portal) {\n      if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwDialogContentAlreadyAttachedError();\n      }\n      const result = this._portalOutlet.attachComponentPortal(portal);\n      this._contentAttached();\n      return result;\n    }\n    attachTemplatePortal(portal) {\n      if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwDialogContentAlreadyAttachedError();\n      }\n      const result = this._portalOutlet.attachTemplatePortal(portal);\n      this._contentAttached();\n      return result;\n    }\n    attachDomPortal = portal => {\n      if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throwDialogContentAlreadyAttachedError();\n      }\n      const result = this._portalOutlet.attachDomPortal(portal);\n      this._contentAttached();\n      return result;\n    };\n    _recaptureFocus() {\n      if (!this._containsFocus()) {\n        this._trapFocus();\n      }\n    }\n    _forceFocus(element, options) {\n      if (!this._interactivityChecker.isFocusable(element)) {\n        element.tabIndex = -1;\n        this._ngZone.runOutsideAngular(() => {\n          const callback = () => {\n            deregisterBlur();\n            deregisterMousedown();\n            element.removeAttribute('tabindex');\n          };\n          const deregisterBlur = this._renderer.listen(element, 'blur', callback);\n          const deregisterMousedown = this._renderer.listen(element, 'mousedown', callback);\n        });\n      }\n      element.focus(options);\n    }\n    _focusByCssSelector(selector, options) {\n      let elementToFocus = this._elementRef.nativeElement.querySelector(selector);\n      if (elementToFocus) {\n        this._forceFocus(elementToFocus, options);\n      }\n    }\n    _trapFocus(options) {\n      if (this._isDestroyed) {\n        return;\n      }\n      afterNextRender(() => {\n        const element = this._elementRef.nativeElement;\n        switch (this._config.autoFocus) {\n          case false:\n          case 'dialog':\n            if (!this._containsFocus()) {\n              element.focus(options);\n            }\n            break;\n          case true:\n          case 'first-tabbable':\n            const focusedSuccessfully = this._focusTrap?.focusInitialElement(options);\n            if (!focusedSuccessfully) {\n              this._focusDialogContainer(options);\n            }\n            break;\n          case 'first-heading':\n            this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role=\"heading\"]', options);\n            break;\n          default:\n            this._focusByCssSelector(this._config.autoFocus, options);\n            break;\n        }\n        this._focusTrapped.next();\n      }, {\n        injector: this._injector\n      });\n    }\n    _restoreFocus() {\n      const focusConfig = this._config.restoreFocus;\n      let focusTargetElement = null;\n      if (typeof focusConfig === 'string') {\n        focusTargetElement = this._document.querySelector(focusConfig);\n      } else if (typeof focusConfig === 'boolean') {\n        focusTargetElement = focusConfig ? this._elementFocusedBeforeDialogWasOpened : null;\n      } else if (focusConfig) {\n        focusTargetElement = focusConfig;\n      }\n      if (this._config.restoreFocus && focusTargetElement && typeof focusTargetElement.focus === 'function') {\n        const activeElement = _getFocusedElementPierceShadowDom();\n        const element = this._elementRef.nativeElement;\n        if (!activeElement || activeElement === this._document.body || activeElement === element || element.contains(activeElement)) {\n          if (this._focusMonitor) {\n            this._focusMonitor.focusVia(focusTargetElement, this._closeInteractionType);\n            this._closeInteractionType = null;\n          } else {\n            focusTargetElement.focus();\n          }\n        }\n      }\n      if (this._focusTrap) {\n        this._focusTrap.destroy();\n      }\n    }\n    _focusDialogContainer(options) {\n      this._elementRef.nativeElement.focus?.(options);\n    }\n    _containsFocus() {\n      const element = this._elementRef.nativeElement;\n      const activeElement = _getFocusedElementPierceShadowDom();\n      return element === activeElement || element.contains(activeElement);\n    }\n    _initializeFocusTrap() {\n      if (this._platform.isBrowser) {\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n        if (this._document) {\n          this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();\n        }\n      }\n    }\n    static ɵfac = function CdkDialogContainer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || CdkDialogContainer)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: CdkDialogContainer,\n      selectors: [[\"cdk-dialog-container\"]],\n      viewQuery: function CdkDialogContainer_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(CdkPortalOutlet, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);\n        }\n      },\n      hostAttrs: [\"tabindex\", \"-1\", 1, \"cdk-dialog-container\"],\n      hostVars: 6,\n      hostBindings: function CdkDialogContainer_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"id\", ctx._config.id || null)(\"role\", ctx._config.role)(\"aria-modal\", ctx._config.ariaModal)(\"aria-labelledby\", ctx._config.ariaLabel ? null : ctx._ariaLabelledByQueue[0])(\"aria-label\", ctx._config.ariaLabel)(\"aria-describedby\", ctx._config.ariaDescribedBy || null);\n        }\n      },\n      features: [i0.ɵɵInheritDefinitionFeature],\n      decls: 1,\n      vars: 0,\n      consts: [[\"cdkPortalOutlet\", \"\"]],\n      template: function CdkDialogContainer_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, CdkDialogContainer_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n        }\n      },\n      dependencies: [CdkPortalOutlet],\n      styles: [\".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return CdkDialogContainer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DialogRef {\n  overlayRef;\n  config;\n  componentInstance;\n  componentRef;\n  containerInstance;\n  disableClose;\n  closed = /*#__PURE__*/new Subject();\n  backdropClick;\n  keydownEvents;\n  outsidePointerEvents;\n  id;\n  _detachSubscription;\n  constructor(overlayRef, config) {\n    this.overlayRef = overlayRef;\n    this.config = config;\n    this.disableClose = config.disableClose;\n    this.backdropClick = overlayRef.backdropClick();\n    this.keydownEvents = overlayRef.keydownEvents();\n    this.outsidePointerEvents = overlayRef.outsidePointerEvents();\n    this.id = config.id;\n    this.keydownEvents.subscribe(event => {\n      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n        event.preventDefault();\n        this.close(undefined, {\n          focusOrigin: 'keyboard'\n        });\n      }\n    });\n    this.backdropClick.subscribe(() => {\n      if (!this.disableClose && this._canClose()) {\n        this.close(undefined, {\n          focusOrigin: 'mouse'\n        });\n      } else {\n        this.containerInstance._recaptureFocus?.();\n      }\n    });\n    this._detachSubscription = overlayRef.detachments().subscribe(() => {\n      if (config.closeOnOverlayDetachments !== false) {\n        this.close();\n      }\n    });\n  }\n  close(result, options) {\n    if (this._canClose(result)) {\n      const closedSubject = this.closed;\n      this.containerInstance._closeInteractionType = options?.focusOrigin || 'program';\n      this._detachSubscription.unsubscribe();\n      this.overlayRef.dispose();\n      closedSubject.next(result);\n      closedSubject.complete();\n      this.componentInstance = this.containerInstance = null;\n    }\n  }\n  updatePosition() {\n    this.overlayRef.updatePosition();\n    return this;\n  }\n  updateSize(width = '', height = '') {\n    this.overlayRef.updateSize({\n      width,\n      height\n    });\n    return this;\n  }\n  addPanelClass(classes) {\n    this.overlayRef.addPanelClass(classes);\n    return this;\n  }\n  removePanelClass(classes) {\n    this.overlayRef.removePanelClass(classes);\n    return this;\n  }\n  _canClose(result) {\n    const config = this.config;\n    return !!this.containerInstance && (!config.closePredicate || config.closePredicate(result, config, this.componentInstance));\n  }\n}\nconst DIALOG_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('DialogScrollStrategy', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(Injector);\n    return () => createBlockScrollStrategy(injector);\n  }\n});\nconst DIALOG_DATA = /*#__PURE__*/new InjectionToken('DialogData');\nconst DEFAULT_DIALOG_CONFIG = /*#__PURE__*/new InjectionToken('DefaultDialogConfig');\nfunction getDirectionality(value) {\n  const valueSignal = signal(value, ...(ngDevMode ? [{\n    debugName: \"valueSignal\"\n  }] : []));\n  const change = new EventEmitter();\n  return {\n    valueSignal,\n    get value() {\n      return valueSignal();\n    },\n    change,\n    ngOnDestroy() {\n      change.complete();\n    }\n  };\n}\nlet Dialog = /*#__PURE__*/(() => {\n  class Dialog {\n    _injector = inject(Injector);\n    _defaultOptions = inject(DEFAULT_DIALOG_CONFIG, {\n      optional: true\n    });\n    _parentDialog = inject(Dialog, {\n      optional: true,\n      skipSelf: true\n    });\n    _overlayContainer = inject(OverlayContainer);\n    _idGenerator = inject(_IdGenerator);\n    _openDialogsAtThisLevel = [];\n    _afterAllClosedAtThisLevel = new Subject();\n    _afterOpenedAtThisLevel = new Subject();\n    _ariaHiddenElements = new Map();\n    _scrollStrategy = inject(DIALOG_SCROLL_STRATEGY);\n    get openDialogs() {\n      return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\n    }\n    get afterOpened() {\n      return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\n    }\n    afterAllClosed = defer(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(startWith(undefined)));\n    constructor() {}\n    open(componentOrTemplateRef, config) {\n      const defaults = this._defaultOptions || new DialogConfig();\n      config = {\n        ...defaults,\n        ...config\n      };\n      config.id = config.id || this._idGenerator.getId('cdk-dialog-');\n      if (config.id && this.getDialogById(config.id) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\n      }\n      const overlayConfig = this._getOverlayConfig(config);\n      const overlayRef = createOverlayRef(this._injector, overlayConfig);\n      const dialogRef = new DialogRef(overlayRef, config);\n      const dialogContainer = this._attachContainer(overlayRef, dialogRef, config);\n      dialogRef.containerInstance = dialogContainer;\n      if (!this.openDialogs.length) {\n        const overlayContainer = this._overlayContainer.getContainerElement();\n        if (dialogContainer._focusTrapped) {\n          dialogContainer._focusTrapped.pipe(take(1)).subscribe(() => {\n            this._hideNonDialogContentFromAssistiveTechnology(overlayContainer);\n          });\n        } else {\n          this._hideNonDialogContentFromAssistiveTechnology(overlayContainer);\n        }\n      }\n      this._attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config);\n      this.openDialogs.push(dialogRef);\n      dialogRef.closed.subscribe(() => this._removeOpenDialog(dialogRef, true));\n      this.afterOpened.next(dialogRef);\n      return dialogRef;\n    }\n    closeAll() {\n      reverseForEach(this.openDialogs, dialog => dialog.close());\n    }\n    getDialogById(id) {\n      return this.openDialogs.find(dialog => dialog.id === id);\n    }\n    ngOnDestroy() {\n      reverseForEach(this._openDialogsAtThisLevel, dialog => {\n        if (dialog.config.closeOnDestroy === false) {\n          this._removeOpenDialog(dialog, false);\n        }\n      });\n      reverseForEach(this._openDialogsAtThisLevel, dialog => dialog.close());\n      this._afterAllClosedAtThisLevel.complete();\n      this._afterOpenedAtThisLevel.complete();\n      this._openDialogsAtThisLevel = [];\n    }\n    _getOverlayConfig(config) {\n      const state = new OverlayConfig({\n        positionStrategy: config.positionStrategy || createGlobalPositionStrategy().centerHorizontally().centerVertically(),\n        scrollStrategy: config.scrollStrategy || this._scrollStrategy(),\n        panelClass: config.panelClass,\n        hasBackdrop: config.hasBackdrop,\n        direction: config.direction,\n        minWidth: config.minWidth,\n        minHeight: config.minHeight,\n        maxWidth: config.maxWidth,\n        maxHeight: config.maxHeight,\n        width: config.width,\n        height: config.height,\n        disposeOnNavigation: config.closeOnNavigation,\n        disableAnimations: config.disableAnimations\n      });\n      if (config.backdropClass) {\n        state.backdropClass = config.backdropClass;\n      }\n      return state;\n    }\n    _attachContainer(overlay, dialogRef, config) {\n      const userInjector = config.injector || config.viewContainerRef?.injector;\n      const providers = [{\n        provide: DialogConfig,\n        useValue: config\n      }, {\n        provide: DialogRef,\n        useValue: dialogRef\n      }, {\n        provide: OverlayRef,\n        useValue: overlay\n      }];\n      let containerType;\n      if (config.container) {\n        if (typeof config.container === 'function') {\n          containerType = config.container;\n        } else {\n          containerType = config.container.type;\n          providers.push(...config.container.providers(config));\n        }\n      } else {\n        containerType = CdkDialogContainer;\n      }\n      const containerPortal = new ComponentPortal(containerType, config.viewContainerRef, Injector.create({\n        parent: userInjector || this._injector,\n        providers\n      }));\n      const containerRef = overlay.attach(containerPortal);\n      return containerRef.instance;\n    }\n    _attachDialogContent(componentOrTemplateRef, dialogRef, dialogContainer, config) {\n      if (componentOrTemplateRef instanceof TemplateRef) {\n        const injector = this._createInjector(config, dialogRef, dialogContainer, undefined);\n        let context = {\n          $implicit: config.data,\n          dialogRef\n        };\n        if (config.templateContext) {\n          context = {\n            ...context,\n            ...(typeof config.templateContext === 'function' ? config.templateContext() : config.templateContext)\n          };\n        }\n        dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, context, injector));\n      } else {\n        const injector = this._createInjector(config, dialogRef, dialogContainer, this._injector);\n        const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));\n        dialogRef.componentRef = contentRef;\n        dialogRef.componentInstance = contentRef.instance;\n      }\n    }\n    _createInjector(config, dialogRef, dialogContainer, fallbackInjector) {\n      const userInjector = config.injector || config.viewContainerRef?.injector;\n      const providers = [{\n        provide: DIALOG_DATA,\n        useValue: config.data\n      }, {\n        provide: DialogRef,\n        useValue: dialogRef\n      }];\n      if (config.providers) {\n        if (typeof config.providers === 'function') {\n          providers.push(...config.providers(dialogRef, config, dialogContainer));\n        } else {\n          providers.push(...config.providers);\n        }\n      }\n      if (config.direction && (!userInjector || !userInjector.get(Directionality, null, {\n        optional: true\n      }))) {\n        providers.push({\n          provide: Directionality,\n          useValue: getDirectionality(config.direction)\n        });\n      }\n      return Injector.create({\n        parent: userInjector || fallbackInjector,\n        providers\n      });\n    }\n    _removeOpenDialog(dialogRef, emitEvent) {\n      const index = this.openDialogs.indexOf(dialogRef);\n      if (index > -1) {\n        this.openDialogs.splice(index, 1);\n        if (!this.openDialogs.length) {\n          this._ariaHiddenElements.forEach((previousValue, element) => {\n            if (previousValue) {\n              element.setAttribute('aria-hidden', previousValue);\n            } else {\n              element.removeAttribute('aria-hidden');\n            }\n          });\n          this._ariaHiddenElements.clear();\n          if (emitEvent) {\n            this._getAfterAllClosed().next();\n          }\n        }\n      }\n    }\n    _hideNonDialogContentFromAssistiveTechnology(overlayContainer) {\n      if (overlayContainer.parentElement) {\n        const siblings = overlayContainer.parentElement.children;\n        for (let i = siblings.length - 1; i > -1; i--) {\n          const sibling = siblings[i];\n          if (sibling !== overlayContainer && sibling.nodeName !== 'SCRIPT' && sibling.nodeName !== 'STYLE' && !sibling.hasAttribute('aria-live') && !sibling.hasAttribute('popover')) {\n            this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\n            sibling.setAttribute('aria-hidden', 'true');\n          }\n        }\n      }\n    }\n    _getAfterAllClosed() {\n      const parent = this._parentDialog;\n      return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\n    }\n    static ɵfac = function Dialog_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Dialog)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Dialog,\n      factory: Dialog.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Dialog;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction reverseForEach(items, callback) {\n  let i = items.length;\n  while (i--) {\n    callback(items[i]);\n  }\n}\nlet DialogModule = /*#__PURE__*/(() => {\n  class DialogModule {\n    static ɵfac = function DialogModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DialogModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: DialogModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [Dialog],\n      imports: [OverlayModule, PortalModule, A11yModule, PortalModule]\n    });\n  }\n  return DialogModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { CdkDialogContainer, DEFAULT_DIALOG_CONFIG, DIALOG_DATA, DIALOG_SCROLL_STRATEGY, Dialog, DialogConfig, DialogModule, DialogRef, throwDialogContentAlreadyAttachedError, CdkPortalOutlet as ɵɵCdkPortalOutlet };\n//# sourceMappingURL=dialog.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}