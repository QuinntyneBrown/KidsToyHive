{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, inject, ElementRef, NgZone, EventEmitter, Injector, Renderer2, afterNextRender, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, InjectionToken, ChangeDetectorRef, signal, ViewChild, ViewContainerRef, DOCUMENT, booleanAttribute, Directive, forwardRef, HostAttributeToken, ContentChild, TemplateRef, NgModule } from '@angular/core';\nimport { Subject, Subscription, merge, of } from 'rxjs';\nimport { DateAdapter, MAT_DATE_FORMATS } from './_date-formats-chunk.mjs';\nimport { _IdGenerator, CdkMonitorFocus, CdkTrapFocus, A11yModule } from '@angular/cdk/a11y';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { coerceStringArray } from '@angular/cdk/coercion';\nimport { ESCAPE, hasModifierKey, SPACE, ENTER, PAGE_DOWN, PAGE_UP, END, HOME, DOWN_ARROW, UP_ARROW, RIGHT_ARROW, LEFT_ARROW, BACKSPACE } from '@angular/cdk/keycodes';\nimport { createRepositionScrollStrategy, FlexibleConnectedPositionStrategy, createOverlayRef, OverlayConfig, createBlockScrollStrategy, createGlobalPositionStrategy, createFlexibleConnectedPositionStrategy, OverlayModule } from '@angular/cdk/overlay';\nimport { Platform, _getFocusedElementPierceShadowDom } from '@angular/cdk/platform';\nimport { ComponentPortal, CdkPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { startWith, take, filter } from 'rxjs/operators';\nimport { NgClass } from '@angular/common';\nimport { _CdkPrivateStyleLoader, _VisuallyHiddenLoader } from '@angular/cdk/private';\nimport { _StructuralStylesLoader } from './_structural-styles-chunk.mjs';\nimport { MatButton, MatButtonModule } from './button.mjs';\nimport { MatIconButton } from './_icon-button-chunk.mjs';\nimport { MatTooltip } from './_tooltip-chunk.mjs';\nimport { _animationsDisabled } from './_animation-chunk.mjs';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS, Validators, ControlContainer, NgForm, FormGroupDirective, NgControl } from '@angular/forms';\nimport { MAT_INPUT_VALUE_ACCESSOR } from './_input-value-accessor-chunk.mjs';\nimport { MAT_FORM_FIELD, MatFormFieldControl } from './_form-field-chunk.mjs';\nimport { ErrorStateMatcher } from './_error-options-chunk.mjs';\nimport { _ErrorStateTracker } from './_error-state-chunk.mjs';\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\nimport './_ripple-module-chunk.mjs';\nimport './_ripple-chunk.mjs';\nimport './_ripple-loader-chunk.mjs';\nimport '@angular/cdk/layout';\nimport '@angular/cdk/observers/private';\nconst _c0 = [\"mat-calendar-body\", \"\"];\nfunction _forTrack0($index, $item) {\n  return this._trackRow($item);\n}\nconst _forTrack1 = ($index, $item) => $item.id;\nfunction MatCalendarBody_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 0)(1, \"td\", 3);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵstyleProp(\"padding-top\", ctx_r0._cellPadding)(\"padding-bottom\", ctx_r0._cellPadding);\n    i0.ɵɵattribute(\"colspan\", ctx_r0.numCols);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0.label, \" \");\n  }\n}\nfunction MatCalendarBody_For_2_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"td\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext(2);\n    i0.ɵɵstyleProp(\"padding-top\", ctx_r0._cellPadding)(\"padding-bottom\", ctx_r0._cellPadding);\n    i0.ɵɵattribute(\"colspan\", ctx_r0._firstRowOffset);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r0._firstRowOffset >= ctx_r0.labelMinRequiredCells ? ctx_r0.label : \"\", \" \");\n  }\n}\nfunction MatCalendarBody_For_2_For_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"td\", 6)(1, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function MatCalendarBody_For_2_For_3_Template_button_click_1_listener($event) {\n      const item_r3 = i0.ɵɵrestoreView(_r2).$implicit;\n      const ctx_r0 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r0._cellClicked(item_r3, $event));\n    })(\"focus\", function MatCalendarBody_For_2_For_3_Template_button_focus_1_listener($event) {\n      const item_r3 = i0.ɵɵrestoreView(_r2).$implicit;\n      const ctx_r0 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r0._emitActiveDateChange(item_r3, $event));\n    });\n    i0.ɵɵelementStart(2, \"span\", 8);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelement(4, \"span\", 9);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const item_r3 = ctx.$implicit;\n    const ɵ$index_14_r4 = ctx.$index;\n    const ɵ$index_7_r5 = i0.ɵɵnextContext().$index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", ctx_r0._cellWidth)(\"padding-top\", ctx_r0._cellPadding)(\"padding-bottom\", ctx_r0._cellPadding);\n    i0.ɵɵattribute(\"data-mat-row\", ɵ$index_7_r5)(\"data-mat-col\", ɵ$index_14_r4);\n    i0.ɵɵadvance();\n    i0.ɵɵclassProp(\"mat-calendar-body-disabled\", !item_r3.enabled)(\"mat-calendar-body-active\", ctx_r0._isActiveCell(ɵ$index_7_r5, ɵ$index_14_r4))(\"mat-calendar-body-range-start\", ctx_r0._isRangeStart(item_r3.compareValue))(\"mat-calendar-body-range-end\", ctx_r0._isRangeEnd(item_r3.compareValue))(\"mat-calendar-body-in-range\", ctx_r0._isInRange(item_r3.compareValue))(\"mat-calendar-body-comparison-bridge-start\", ctx_r0._isComparisonBridgeStart(item_r3.compareValue, ɵ$index_7_r5, ɵ$index_14_r4))(\"mat-calendar-body-comparison-bridge-end\", ctx_r0._isComparisonBridgeEnd(item_r3.compareValue, ɵ$index_7_r5, ɵ$index_14_r4))(\"mat-calendar-body-comparison-start\", ctx_r0._isComparisonStart(item_r3.compareValue))(\"mat-calendar-body-comparison-end\", ctx_r0._isComparisonEnd(item_r3.compareValue))(\"mat-calendar-body-in-comparison-range\", ctx_r0._isInComparisonRange(item_r3.compareValue))(\"mat-calendar-body-preview-start\", ctx_r0._isPreviewStart(item_r3.compareValue))(\"mat-calendar-body-preview-end\", ctx_r0._isPreviewEnd(item_r3.compareValue))(\"mat-calendar-body-in-preview\", ctx_r0._isInPreview(item_r3.compareValue));\n    i0.ɵɵproperty(\"ngClass\", item_r3.cssClasses)(\"tabindex\", ctx_r0._isActiveCell(ɵ$index_7_r5, ɵ$index_14_r4) ? 0 : -1);\n    i0.ɵɵattribute(\"aria-label\", item_r3.ariaLabel)(\"aria-disabled\", !item_r3.enabled || null)(\"aria-pressed\", ctx_r0._isSelected(item_r3.compareValue))(\"aria-current\", ctx_r0.todayValue === item_r3.compareValue ? \"date\" : null)(\"aria-describedby\", ctx_r0._getDescribedby(item_r3.compareValue));\n    i0.ɵɵadvance();\n    i0.ɵɵclassProp(\"mat-calendar-body-selected\", ctx_r0._isSelected(item_r3.compareValue))(\"mat-calendar-body-comparison-identical\", ctx_r0._isComparisonIdentical(item_r3.compareValue))(\"mat-calendar-body-today\", ctx_r0.todayValue === item_r3.compareValue);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", item_r3.displayValue, \" \");\n  }\n}\nfunction MatCalendarBody_For_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"tr\", 1);\n    i0.ɵɵconditionalCreate(1, MatCalendarBody_For_2_Conditional_1_Template, 2, 6, \"td\", 4);\n    i0.ɵɵrepeaterCreate(2, MatCalendarBody_For_2_For_3_Template, 5, 48, \"td\", 5, _forTrack1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const row_r6 = ctx.$implicit;\n    const ɵ$index_7_r5 = ctx.$index;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(ɵ$index_7_r5 === 0 && ctx_r0._firstRowOffset ? 1 : -1);\n    i0.ɵɵadvance();\n    i0.ɵɵrepeater(row_r6);\n  }\n}\nfunction MatMonthView_For_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"th\", 2)(1, \"span\", 6);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"span\", 3);\n    i0.ɵɵtext(4);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const day_r1 = ctx.$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(day_r1.long);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(day_r1.narrow);\n  }\n}\nconst _c1 = [\"*\"];\nfunction MatCalendar_ng_template_0_Template(rf, ctx) {}\nfunction MatCalendar_Case_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"mat-month-view\", 4);\n    i0.ɵɵtwoWayListener(\"activeDateChange\", function MatCalendar_Case_2_Template_mat_month_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      i0.ɵɵtwoWayBindingSet(ctx_r1.activeDate, $event) || (ctx_r1.activeDate = $event);\n      return i0.ɵɵresetView($event);\n    });\n    i0.ɵɵlistener(\"_userSelection\", function MatCalendar_Case_2_Template_mat_month_view__userSelection_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._dateSelected($event));\n    })(\"dragStarted\", function MatCalendar_Case_2_Template_mat_month_view_dragStarted_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._dragStarted($event));\n    })(\"dragEnded\", function MatCalendar_Case_2_Template_mat_month_view_dragEnded_0_listener($event) {\n      i0.ɵɵrestoreView(_r1);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._dragEnded($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵtwoWayProperty(\"activeDate\", ctx_r1.activeDate);\n    i0.ɵɵproperty(\"selected\", ctx_r1.selected)(\"dateFilter\", ctx_r1.dateFilter)(\"maxDate\", ctx_r1.maxDate)(\"minDate\", ctx_r1.minDate)(\"dateClass\", ctx_r1.dateClass)(\"comparisonStart\", ctx_r1.comparisonStart)(\"comparisonEnd\", ctx_r1.comparisonEnd)(\"startDateAccessibleName\", ctx_r1.startDateAccessibleName)(\"endDateAccessibleName\", ctx_r1.endDateAccessibleName)(\"activeDrag\", ctx_r1._activeDrag);\n  }\n}\nfunction MatCalendar_Case_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"mat-year-view\", 5);\n    i0.ɵɵtwoWayListener(\"activeDateChange\", function MatCalendar_Case_3_Template_mat_year_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      i0.ɵɵtwoWayBindingSet(ctx_r1.activeDate, $event) || (ctx_r1.activeDate = $event);\n      return i0.ɵɵresetView($event);\n    });\n    i0.ɵɵlistener(\"monthSelected\", function MatCalendar_Case_3_Template_mat_year_view_monthSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._monthSelectedInYearView($event));\n    })(\"selectedChange\", function MatCalendar_Case_3_Template_mat_year_view_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._goToDateInView($event, \"month\"));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵtwoWayProperty(\"activeDate\", ctx_r1.activeDate);\n    i0.ɵɵproperty(\"selected\", ctx_r1.selected)(\"dateFilter\", ctx_r1.dateFilter)(\"maxDate\", ctx_r1.maxDate)(\"minDate\", ctx_r1.minDate)(\"dateClass\", ctx_r1.dateClass);\n  }\n}\nfunction MatCalendar_Case_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r4 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"mat-multi-year-view\", 6);\n    i0.ɵɵtwoWayListener(\"activeDateChange\", function MatCalendar_Case_4_Template_mat_multi_year_view_activeDateChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      i0.ɵɵtwoWayBindingSet(ctx_r1.activeDate, $event) || (ctx_r1.activeDate = $event);\n      return i0.ɵɵresetView($event);\n    });\n    i0.ɵɵlistener(\"yearSelected\", function MatCalendar_Case_4_Template_mat_multi_year_view_yearSelected_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._yearSelectedInMultiYearView($event));\n    })(\"selectedChange\", function MatCalendar_Case_4_Template_mat_multi_year_view_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r4);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1._goToDateInView($event, \"year\"));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵtwoWayProperty(\"activeDate\", ctx_r1.activeDate);\n    i0.ɵɵproperty(\"selected\", ctx_r1.selected)(\"dateFilter\", ctx_r1.dateFilter)(\"maxDate\", ctx_r1.maxDate)(\"minDate\", ctx_r1.minDate)(\"dateClass\", ctx_r1.dateClass);\n  }\n}\nfunction MatDatepickerContent_ng_template_2_Template(rf, ctx) {}\nconst _c2 = [\"button\"];\nconst _c3 = [[[\"\", \"matDatepickerToggleIcon\", \"\"]]];\nconst _c4 = [\"[matDatepickerToggleIcon]\"];\nfunction MatDatepickerToggle_Conditional_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(0, \"svg\", 2);\n    i0.ɵɵelement(1, \"path\", 3);\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c5 = [[[\"input\", \"matStartDate\", \"\"]], [[\"input\", \"matEndDate\", \"\"]]];\nconst _c6 = [\"input[matStartDate]\", \"input[matEndDate]\"];\nfunction MatDatepickerActions_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵdomElementStart(0, \"div\", 0);\n    i0.ɵɵprojection(1);\n    i0.ɵɵdomElementEnd();\n  }\n}\nfunction createMissingDateImplError(provider) {\n  return Error(`MatDatepicker: No provider found for ${provider}. You must add one of the following ` + `to your app config: provideNativeDateAdapter, provideDateFnsAdapter, ` + `provideLuxonDateAdapter, provideMomentDateAdapter, or provide a custom implementation.`);\n}\nlet MatDatepickerIntl = /*#__PURE__*/(() => {\n  class MatDatepickerIntl {\n    changes = new Subject();\n    calendarLabel = 'Calendar';\n    openCalendarLabel = 'Open calendar';\n    closeCalendarLabel = 'Close calendar';\n    prevMonthLabel = 'Previous month';\n    nextMonthLabel = 'Next month';\n    prevYearLabel = 'Previous year';\n    nextYearLabel = 'Next year';\n    prevMultiYearLabel = 'Previous 24 years';\n    nextMultiYearLabel = 'Next 24 years';\n    switchToMonthViewLabel = 'Choose date';\n    switchToMultiYearViewLabel = 'Choose month and year';\n    startDateLabel = 'Start date';\n    endDateLabel = 'End date';\n    comparisonDateLabel = 'Comparison range';\n    formatYearRange(start, end) {\n      return `${start} \\u2013 ${end}`;\n    }\n    formatYearRangeLabel(start, end) {\n      return `${start} to ${end}`;\n    }\n    static ɵfac = function MatDatepickerIntl_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerIntl)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MatDatepickerIntl,\n      factory: MatDatepickerIntl.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return MatDatepickerIntl;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet uniqueIdCounter$1 = 0;\nclass MatCalendarCell {\n  value;\n  displayValue;\n  ariaLabel;\n  enabled;\n  cssClasses;\n  compareValue;\n  rawValue;\n  id = uniqueIdCounter$1++;\n  constructor(value, displayValue, ariaLabel, enabled, cssClasses = {}, compareValue = value, rawValue) {\n    this.value = value;\n    this.displayValue = displayValue;\n    this.ariaLabel = ariaLabel;\n    this.enabled = enabled;\n    this.cssClasses = cssClasses;\n    this.compareValue = compareValue;\n    this.rawValue = rawValue;\n  }\n}\nconst activeCapturingEventOptions = {\n  passive: false,\n  capture: true\n};\nconst passiveCapturingEventOptions = {\n  passive: true,\n  capture: true\n};\nconst passiveEventOptions = {\n  passive: true\n};\nlet MatCalendarBody = /*#__PURE__*/(() => {\n  class MatCalendarBody {\n    _elementRef = inject(ElementRef);\n    _ngZone = inject(NgZone);\n    _platform = inject(Platform);\n    _intl = inject(MatDatepickerIntl);\n    _eventCleanups;\n    _skipNextFocus;\n    _focusActiveCellAfterViewChecked = false;\n    label;\n    rows;\n    todayValue;\n    startValue;\n    endValue;\n    labelMinRequiredCells;\n    numCols = 7;\n    activeCell = 0;\n    ngAfterViewChecked() {\n      if (this._focusActiveCellAfterViewChecked) {\n        this._focusActiveCell();\n        this._focusActiveCellAfterViewChecked = false;\n      }\n    }\n    isRange = false;\n    cellAspectRatio = 1;\n    comparisonStart;\n    comparisonEnd;\n    previewStart = null;\n    previewEnd = null;\n    startDateAccessibleName;\n    endDateAccessibleName;\n    selectedValueChange = new EventEmitter();\n    previewChange = new EventEmitter();\n    activeDateChange = new EventEmitter();\n    dragStarted = new EventEmitter();\n    dragEnded = new EventEmitter();\n    _firstRowOffset;\n    _cellPadding;\n    _cellWidth;\n    _startDateLabelId;\n    _endDateLabelId;\n    _comparisonStartDateLabelId;\n    _comparisonEndDateLabelId;\n    _didDragSinceMouseDown = false;\n    _injector = inject(Injector);\n    comparisonDateAccessibleName = this._intl.comparisonDateLabel;\n    _trackRow = row => row;\n    constructor() {\n      const renderer = inject(Renderer2);\n      const idGenerator = inject(_IdGenerator);\n      this._startDateLabelId = idGenerator.getId('mat-calendar-body-start-');\n      this._endDateLabelId = idGenerator.getId('mat-calendar-body-end-');\n      this._comparisonStartDateLabelId = idGenerator.getId('mat-calendar-body-comparison-start-');\n      this._comparisonEndDateLabelId = idGenerator.getId('mat-calendar-body-comparison-end-');\n      inject(_CdkPrivateStyleLoader).load(_StructuralStylesLoader);\n      this._ngZone.runOutsideAngular(() => {\n        const element = this._elementRef.nativeElement;\n        const cleanups = [renderer.listen(element, 'touchmove', this._touchmoveHandler, activeCapturingEventOptions), renderer.listen(element, 'mouseenter', this._enterHandler, passiveCapturingEventOptions), renderer.listen(element, 'focus', this._enterHandler, passiveCapturingEventOptions), renderer.listen(element, 'mouseleave', this._leaveHandler, passiveCapturingEventOptions), renderer.listen(element, 'blur', this._leaveHandler, passiveCapturingEventOptions), renderer.listen(element, 'mousedown', this._mousedownHandler, passiveEventOptions), renderer.listen(element, 'touchstart', this._mousedownHandler, passiveEventOptions)];\n        if (this._platform.isBrowser) {\n          cleanups.push(renderer.listen('window', 'mouseup', this._mouseupHandler), renderer.listen('window', 'touchend', this._touchendHandler));\n        }\n        this._eventCleanups = cleanups;\n      });\n    }\n    _cellClicked(cell, event) {\n      if (this._didDragSinceMouseDown) {\n        return;\n      }\n      if (cell.enabled) {\n        this.selectedValueChange.emit({\n          value: cell.value,\n          event\n        });\n      }\n    }\n    _emitActiveDateChange(cell, event) {\n      if (cell.enabled) {\n        this.activeDateChange.emit({\n          value: cell.value,\n          event\n        });\n      }\n    }\n    _isSelected(value) {\n      return this.startValue === value || this.endValue === value;\n    }\n    ngOnChanges(changes) {\n      const columnChanges = changes['numCols'];\n      const {\n        rows,\n        numCols\n      } = this;\n      if (changes['rows'] || columnChanges) {\n        this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;\n      }\n      if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {\n        this._cellPadding = `${50 * this.cellAspectRatio / numCols}%`;\n      }\n      if (columnChanges || !this._cellWidth) {\n        this._cellWidth = `${100 / numCols}%`;\n      }\n    }\n    ngOnDestroy() {\n      this._eventCleanups.forEach(cleanup => cleanup());\n    }\n    _isActiveCell(rowIndex, colIndex) {\n      let cellNumber = rowIndex * this.numCols + colIndex;\n      if (rowIndex) {\n        cellNumber -= this._firstRowOffset;\n      }\n      return cellNumber == this.activeCell;\n    }\n    _focusActiveCell(movePreview = true) {\n      afterNextRender(() => {\n        setTimeout(() => {\n          const activeCell = this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');\n          if (activeCell) {\n            if (!movePreview) {\n              this._skipNextFocus = true;\n            }\n            activeCell.focus();\n          }\n        });\n      }, {\n        injector: this._injector\n      });\n    }\n    _scheduleFocusActiveCellAfterViewChecked() {\n      this._focusActiveCellAfterViewChecked = true;\n    }\n    _isRangeStart(value) {\n      return isStart(value, this.startValue, this.endValue);\n    }\n    _isRangeEnd(value) {\n      return isEnd(value, this.startValue, this.endValue);\n    }\n    _isInRange(value) {\n      return isInRange(value, this.startValue, this.endValue, this.isRange);\n    }\n    _isComparisonStart(value) {\n      return isStart(value, this.comparisonStart, this.comparisonEnd);\n    }\n    _isComparisonBridgeStart(value, rowIndex, colIndex) {\n      if (!this._isComparisonStart(value) || this._isRangeStart(value) || !this._isInRange(value)) {\n        return false;\n      }\n      let previousCell = this.rows[rowIndex][colIndex - 1];\n      if (!previousCell) {\n        const previousRow = this.rows[rowIndex - 1];\n        previousCell = previousRow && previousRow[previousRow.length - 1];\n      }\n      return previousCell && !this._isRangeEnd(previousCell.compareValue);\n    }\n    _isComparisonBridgeEnd(value, rowIndex, colIndex) {\n      if (!this._isComparisonEnd(value) || this._isRangeEnd(value) || !this._isInRange(value)) {\n        return false;\n      }\n      let nextCell = this.rows[rowIndex][colIndex + 1];\n      if (!nextCell) {\n        const nextRow = this.rows[rowIndex + 1];\n        nextCell = nextRow && nextRow[0];\n      }\n      return nextCell && !this._isRangeStart(nextCell.compareValue);\n    }\n    _isComparisonEnd(value) {\n      return isEnd(value, this.comparisonStart, this.comparisonEnd);\n    }\n    _isInComparisonRange(value) {\n      return isInRange(value, this.comparisonStart, this.comparisonEnd, this.isRange);\n    }\n    _isComparisonIdentical(value) {\n      return this.comparisonStart === this.comparisonEnd && value === this.comparisonStart;\n    }\n    _isPreviewStart(value) {\n      return isStart(value, this.previewStart, this.previewEnd);\n    }\n    _isPreviewEnd(value) {\n      return isEnd(value, this.previewStart, this.previewEnd);\n    }\n    _isInPreview(value) {\n      return isInRange(value, this.previewStart, this.previewEnd, this.isRange);\n    }\n    _getDescribedby(value) {\n      if (!this.isRange) {\n        return null;\n      }\n      if (this.startValue === value && this.endValue === value) {\n        return `${this._startDateLabelId} ${this._endDateLabelId}`;\n      } else if (this.startValue === value) {\n        return this._startDateLabelId;\n      } else if (this.endValue === value) {\n        return this._endDateLabelId;\n      }\n      if (this.comparisonStart !== null && this.comparisonEnd !== null) {\n        if (value === this.comparisonStart && value === this.comparisonEnd) {\n          return `${this._comparisonStartDateLabelId} ${this._comparisonEndDateLabelId}`;\n        } else if (value === this.comparisonStart) {\n          return this._comparisonStartDateLabelId;\n        } else if (value === this.comparisonEnd) {\n          return this._comparisonEndDateLabelId;\n        }\n      }\n      return null;\n    }\n    _enterHandler = event => {\n      if (this._skipNextFocus && event.type === 'focus') {\n        this._skipNextFocus = false;\n        return;\n      }\n      if (event.target && this.isRange) {\n        const cell = this._getCellFromElement(event.target);\n        if (cell) {\n          this._ngZone.run(() => this.previewChange.emit({\n            value: cell.enabled ? cell : null,\n            event\n          }));\n        }\n      }\n    };\n    _touchmoveHandler = event => {\n      if (!this.isRange) return;\n      const target = getActualTouchTarget(event);\n      const cell = target ? this._getCellFromElement(target) : null;\n      if (target !== event.target) {\n        this._didDragSinceMouseDown = true;\n      }\n      if (getCellElement(event.target)) {\n        event.preventDefault();\n      }\n      this._ngZone.run(() => this.previewChange.emit({\n        value: cell?.enabled ? cell : null,\n        event\n      }));\n    };\n    _leaveHandler = event => {\n      if (this.previewEnd !== null && this.isRange) {\n        if (event.type !== 'blur') {\n          this._didDragSinceMouseDown = true;\n        }\n        if (event.target && this._getCellFromElement(event.target) && !(event.relatedTarget && this._getCellFromElement(event.relatedTarget))) {\n          this._ngZone.run(() => this.previewChange.emit({\n            value: null,\n            event\n          }));\n        }\n      }\n    };\n    _mousedownHandler = event => {\n      if (!this.isRange) return;\n      this._didDragSinceMouseDown = false;\n      const cell = event.target && this._getCellFromElement(event.target);\n      if (!cell || !this._isInRange(cell.compareValue)) {\n        return;\n      }\n      this._ngZone.run(() => {\n        this.dragStarted.emit({\n          value: cell.rawValue,\n          event\n        });\n      });\n    };\n    _mouseupHandler = event => {\n      if (!this.isRange) return;\n      const cellElement = getCellElement(event.target);\n      if (!cellElement) {\n        this._ngZone.run(() => {\n          this.dragEnded.emit({\n            value: null,\n            event\n          });\n        });\n        return;\n      }\n      if (cellElement.closest('.mat-calendar-body') !== this._elementRef.nativeElement) {\n        return;\n      }\n      this._ngZone.run(() => {\n        const cell = this._getCellFromElement(cellElement);\n        this.dragEnded.emit({\n          value: cell?.rawValue ?? null,\n          event\n        });\n      });\n    };\n    _touchendHandler = event => {\n      const target = getActualTouchTarget(event);\n      if (target) {\n        this._mouseupHandler({\n          target\n        });\n      }\n    };\n    _getCellFromElement(element) {\n      const cell = getCellElement(element);\n      if (cell) {\n        const row = cell.getAttribute('data-mat-row');\n        const col = cell.getAttribute('data-mat-col');\n        if (row && col) {\n          return this.rows[parseInt(row)]?.[parseInt(col)] || null;\n        }\n      }\n      return null;\n    }\n    static ɵfac = function MatCalendarBody_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatCalendarBody)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatCalendarBody,\n      selectors: [[\"\", \"mat-calendar-body\", \"\"]],\n      hostAttrs: [1, \"mat-calendar-body\"],\n      inputs: {\n        label: \"label\",\n        rows: \"rows\",\n        todayValue: \"todayValue\",\n        startValue: \"startValue\",\n        endValue: \"endValue\",\n        labelMinRequiredCells: \"labelMinRequiredCells\",\n        numCols: \"numCols\",\n        activeCell: \"activeCell\",\n        isRange: \"isRange\",\n        cellAspectRatio: \"cellAspectRatio\",\n        comparisonStart: \"comparisonStart\",\n        comparisonEnd: \"comparisonEnd\",\n        previewStart: \"previewStart\",\n        previewEnd: \"previewEnd\",\n        startDateAccessibleName: \"startDateAccessibleName\",\n        endDateAccessibleName: \"endDateAccessibleName\"\n      },\n      outputs: {\n        selectedValueChange: \"selectedValueChange\",\n        previewChange: \"previewChange\",\n        activeDateChange: \"activeDateChange\",\n        dragStarted: \"dragStarted\",\n        dragEnded: \"dragEnded\"\n      },\n      exportAs: [\"matCalendarBody\"],\n      features: [i0.ɵɵNgOnChangesFeature],\n      attrs: _c0,\n      decls: 11,\n      vars: 11,\n      consts: [[\"aria-hidden\", \"true\"], [\"role\", \"row\"], [1, \"mat-calendar-body-hidden-label\", 3, \"id\"], [1, \"mat-calendar-body-label\"], [1, \"mat-calendar-body-label\", 3, \"paddingTop\", \"paddingBottom\"], [\"role\", \"gridcell\", 1, \"mat-calendar-body-cell-container\", 3, \"width\", \"paddingTop\", \"paddingBottom\"], [\"role\", \"gridcell\", 1, \"mat-calendar-body-cell-container\"], [\"type\", \"button\", 1, \"mat-calendar-body-cell\", 3, \"click\", \"focus\", \"ngClass\", \"tabindex\"], [1, \"mat-calendar-body-cell-content\", \"mat-focus-indicator\"], [\"aria-hidden\", \"true\", 1, \"mat-calendar-body-cell-preview\"]],\n      template: function MatCalendarBody_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵconditionalCreate(0, MatCalendarBody_Conditional_0_Template, 3, 6, \"tr\", 0);\n          i0.ɵɵrepeaterCreate(1, MatCalendarBody_For_2_Template, 4, 1, \"tr\", 1, _forTrack0, true);\n          i0.ɵɵelementStart(3, \"span\", 2);\n          i0.ɵɵtext(4);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(5, \"span\", 2);\n          i0.ɵɵtext(6);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(7, \"span\", 2);\n          i0.ɵɵtext(8);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(9, \"span\", 2);\n          i0.ɵɵtext(10);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵconditional(ctx._firstRowOffset < ctx.labelMinRequiredCells ? 0 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵrepeater(ctx.rows);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"id\", ctx._startDateLabelId);\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate1(\" \", ctx.startDateAccessibleName, \"\\n\");\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"id\", ctx._endDateLabelId);\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate1(\" \", ctx.endDateAccessibleName, \"\\n\");\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"id\", ctx._comparisonStartDateLabelId);\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate2(\" \", ctx.comparisonDateAccessibleName, \" \", ctx.startDateAccessibleName, \"\\n\");\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"id\", ctx._comparisonEndDateLabelId);\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate2(\" \", ctx.comparisonDateAccessibleName, \" \", ctx.endDateAccessibleName, \"\\n\");\n        }\n      },\n      dependencies: [NgClass],\n      styles: [\".mat-calendar-body{min-width:224px}.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:var(--mat-datepicker-calendar-date-today-outline-color, var(--mat-sys-primary))}.mat-calendar-body-label{height:0;line-height:0;text-align:start;padding-left:4.7142857143%;padding-right:4.7142857143%;font-size:var(--mat-datepicker-calendar-body-label-text-size, var(--mat-sys-title-small-size));font-weight:var(--mat-datepicker-calendar-body-label-text-weight, var(--mat-sys-title-small-weight));color:var(--mat-datepicker-calendar-body-label-text-color, var(--mat-sys-on-surface))}.mat-calendar-body-hidden-label{display:none}.mat-calendar-body-cell-container{position:relative;height:0;line-height:0}.mat-calendar-body-cell{position:absolute;top:0;left:0;width:100%;height:100%;background:none;text-align:center;outline:none;margin:0;font-family:var(--mat-datepicker-calendar-text-font, var(--mat-sys-body-medium-font));font-size:var(--mat-datepicker-calendar-text-size, var(--mat-sys-body-medium-size));-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-calendar-body-cell::-moz-focus-inner{border:0}.mat-calendar-body-cell::before,.mat-calendar-body-cell::after,.mat-calendar-body-cell-preview{content:\\\"\\\";position:absolute;top:5%;left:0;z-index:0;box-sizing:border-box;display:block;height:90%;width:100%}.mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range)::before,.mat-calendar-body-range-start::after,.mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start)::before,.mat-calendar-body-comparison-start::after,.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{left:5%;width:95%;border-top-left-radius:999px;border-bottom-left-radius:999px}[dir=rtl] .mat-calendar-body-range-start:not(.mat-calendar-body-in-comparison-range)::before,[dir=rtl] .mat-calendar-body-range-start::after,[dir=rtl] .mat-calendar-body-comparison-start:not(.mat-calendar-body-comparison-bridge-start)::before,[dir=rtl] .mat-calendar-body-comparison-start::after,[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{left:0;border-radius:0;border-top-right-radius:999px;border-bottom-right-radius:999px}.mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range)::before,.mat-calendar-body-range-end::after,.mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end)::before,.mat-calendar-body-comparison-end::after,.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{width:95%;border-top-right-radius:999px;border-bottom-right-radius:999px}[dir=rtl] .mat-calendar-body-range-end:not(.mat-calendar-body-in-comparison-range)::before,[dir=rtl] .mat-calendar-body-range-end::after,[dir=rtl] .mat-calendar-body-comparison-end:not(.mat-calendar-body-comparison-bridge-end)::before,[dir=rtl] .mat-calendar-body-comparison-end::after,[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{left:5%;border-radius:0;border-top-left-radius:999px;border-bottom-left-radius:999px}[dir=rtl] .mat-calendar-body-comparison-bridge-start.mat-calendar-body-range-end::after,[dir=rtl] .mat-calendar-body-comparison-bridge-end.mat-calendar-body-range-start::after{width:95%;border-top-right-radius:999px;border-bottom-right-radius:999px}.mat-calendar-body-comparison-start.mat-calendar-body-range-end::after,[dir=rtl] .mat-calendar-body-comparison-start.mat-calendar-body-range-end::after,.mat-calendar-body-comparison-end.mat-calendar-body-range-start::after,[dir=rtl] .mat-calendar-body-comparison-end.mat-calendar-body-range-start::after{width:90%}.mat-calendar-body-in-preview{color:var(--mat-datepicker-calendar-date-preview-state-outline-color, var(--mat-sys-primary))}.mat-calendar-body-in-preview .mat-calendar-body-cell-preview{border-top:dashed 1px;border-bottom:dashed 1px}.mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:dashed 1px}[dir=rtl] .mat-calendar-body-preview-start .mat-calendar-body-cell-preview{border-left:0;border-right:dashed 1px}.mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:dashed 1px}[dir=rtl] .mat-calendar-body-preview-end .mat-calendar-body-cell-preview{border-right:0;border-left:dashed 1px}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-disabled>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){color:var(--mat-datepicker-calendar-date-disabled-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-calendar-body-disabled>.mat-calendar-body-today:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){border-color:var(--mat-datepicker-calendar-date-today-disabled-state-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}@media(forced-colors: active){.mat-calendar-body-disabled{opacity:.5}}.mat-calendar-body-cell-content{top:5%;left:5%;z-index:1;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px;color:var(--mat-datepicker-calendar-date-text-color, var(--mat-sys-on-surface));border-color:var(--mat-datepicker-calendar-date-outline-color, transparent)}.mat-calendar-body-cell-content.mat-focus-indicator{position:absolute}@media(forced-colors: active){.mat-calendar-body-cell-content{border:none}}.cdk-keyboard-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical),.cdk-program-focused .mat-calendar-body-active>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:var(--mat-datepicker-calendar-date-focus-state-background-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(hover: hover){.mat-calendar-body-cell:not(.mat-calendar-body-disabled):hover>.mat-calendar-body-cell-content:not(.mat-calendar-body-selected):not(.mat-calendar-body-comparison-identical){background-color:var(--mat-datepicker-calendar-date-hover-state-background-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}}.mat-calendar-body-selected{background-color:var(--mat-datepicker-calendar-date-selected-state-background-color, var(--mat-sys-primary));color:var(--mat-datepicker-calendar-date-selected-state-text-color, var(--mat-sys-on-primary))}.mat-calendar-body-disabled>.mat-calendar-body-selected{background-color:var(--mat-datepicker-calendar-date-selected-disabled-state-background-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-calendar-body-selected.mat-calendar-body-today{box-shadow:inset 0 0 0 1px var(--mat-datepicker-calendar-date-today-selected-state-outline-color, var(--mat-sys-primary))}.mat-calendar-body-in-range::before{background:var(--mat-datepicker-calendar-date-in-range-state-background-color, var(--mat-sys-primary-container))}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range::before{background:var(--mat-datepicker-calendar-date-in-comparison-range-state-background-color, var(--mat-sys-tertiary-container))}.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range::before{background:var(--mat-datepicker-calendar-date-in-comparison-range-state-background-color, var(--mat-sys-tertiary-container))}.mat-calendar-body-comparison-bridge-start::before,[dir=rtl] .mat-calendar-body-comparison-bridge-end::before{background:linear-gradient(to right, var(--mat-datepicker-calendar-date-in-range-state-background-color, var(--mat-sys-primary-container)) 50%, var(--mat-datepicker-calendar-date-in-comparison-range-state-background-color, var(--mat-sys-tertiary-container)) 50%)}.mat-calendar-body-comparison-bridge-end::before,[dir=rtl] .mat-calendar-body-comparison-bridge-start::before{background:linear-gradient(to left, var(--mat-datepicker-calendar-date-in-range-state-background-color, var(--mat-sys-primary-container)) 50%, var(--mat-datepicker-calendar-date-in-comparison-range-state-background-color, var(--mat-sys-tertiary-container)) 50%)}.mat-calendar-body-in-range>.mat-calendar-body-comparison-identical,.mat-calendar-body-in-comparison-range.mat-calendar-body-in-range::after{background:var(--mat-datepicker-calendar-date-in-overlap-range-state-background-color, var(--mat-sys-secondary-container))}.mat-calendar-body-comparison-identical.mat-calendar-body-selected,.mat-calendar-body-in-comparison-range>.mat-calendar-body-selected{background:var(--mat-datepicker-calendar-date-in-overlap-range-selected-state-background-color, var(--mat-sys-secondary))}@media(forced-colors: active){.mat-datepicker-popup:not(:empty),.mat-calendar-body-cell:not(.mat-calendar-body-in-range) .mat-calendar-body-selected{outline:solid 1px}.mat-calendar-body-today{outline:dotted 1px}.mat-calendar-body-cell::before,.mat-calendar-body-cell::after,.mat-calendar-body-selected{background:none}.mat-calendar-body-in-range::before,.mat-calendar-body-comparison-bridge-start::before,.mat-calendar-body-comparison-bridge-end::before{border-top:solid 1px;border-bottom:solid 1px}.mat-calendar-body-range-start::before{border-left:solid 1px}[dir=rtl] .mat-calendar-body-range-start::before{border-left:0;border-right:solid 1px}.mat-calendar-body-range-end::before{border-right:solid 1px}[dir=rtl] .mat-calendar-body-range-end::before{border-right:0;border-left:solid 1px}.mat-calendar-body-in-comparison-range::before{border-top:dashed 1px;border-bottom:dashed 1px}.mat-calendar-body-comparison-start::before{border-left:dashed 1px}[dir=rtl] .mat-calendar-body-comparison-start::before{border-left:0;border-right:dashed 1px}.mat-calendar-body-comparison-end::before{border-right:dashed 1px}[dir=rtl] .mat-calendar-body-comparison-end::before{border-right:0;border-left:dashed 1px}}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatCalendarBody;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isTableCell(node) {\n  return node?.nodeName === 'TD';\n}\nfunction getCellElement(element) {\n  let cell;\n  if (isTableCell(element)) {\n    cell = element;\n  } else if (isTableCell(element.parentNode)) {\n    cell = element.parentNode;\n  } else if (isTableCell(element.parentNode?.parentNode)) {\n    cell = element.parentNode.parentNode;\n  }\n  return cell?.getAttribute('data-mat-row') != null ? cell : null;\n}\nfunction isStart(value, start, end) {\n  return end !== null && start !== end && value < end && value === start;\n}\nfunction isEnd(value, start, end) {\n  return start !== null && start !== end && value >= start && value === end;\n}\nfunction isInRange(value, start, end, rangeEnabled) {\n  return rangeEnabled && start !== null && end !== null && start !== end && value >= start && value <= end;\n}\nfunction getActualTouchTarget(event) {\n  const touchLocation = event.changedTouches[0];\n  return document.elementFromPoint(touchLocation.clientX, touchLocation.clientY);\n}\nclass DateRange {\n  start;\n  end;\n  _disableStructuralEquivalency;\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n}\nlet MatDateSelectionModel = /*#__PURE__*/(() => {\n  class MatDateSelectionModel {\n    selection;\n    _adapter;\n    _selectionChanged = new Subject();\n    selectionChanged = this._selectionChanged;\n    constructor(selection, _adapter) {\n      this.selection = selection;\n      this._adapter = _adapter;\n      this.selection = selection;\n    }\n    updateSelection(value, source) {\n      const oldValue = this.selection;\n      this.selection = value;\n      this._selectionChanged.next({\n        selection: value,\n        source,\n        oldValue\n      });\n    }\n    ngOnDestroy() {\n      this._selectionChanged.complete();\n    }\n    _isValidDateInstance(date) {\n      return this._adapter.isDateInstance(date) && this._adapter.isValid(date);\n    }\n    static ɵfac = function MatDateSelectionModel_Factory(__ngFactoryType__) {\n      i0.ɵɵinvalidFactory();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MatDateSelectionModel,\n      factory: MatDateSelectionModel.ɵfac\n    });\n  }\n  return MatDateSelectionModel;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatSingleDateSelectionModel = /*#__PURE__*/(() => {\n  class MatSingleDateSelectionModel extends MatDateSelectionModel {\n    constructor(adapter) {\n      super(null, adapter);\n    }\n    add(date) {\n      super.updateSelection(date, this);\n    }\n    isValid() {\n      return this.selection != null && this._isValidDateInstance(this.selection);\n    }\n    isComplete() {\n      return this.selection != null;\n    }\n    clone() {\n      const clone = new MatSingleDateSelectionModel(this._adapter);\n      clone.updateSelection(this.selection, this);\n      return clone;\n    }\n    static ɵfac = function MatSingleDateSelectionModel_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatSingleDateSelectionModel)(i0.ɵɵinject(DateAdapter));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MatSingleDateSelectionModel,\n      factory: MatSingleDateSelectionModel.ɵfac\n    });\n  }\n  return MatSingleDateSelectionModel;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatRangeDateSelectionModel = /*#__PURE__*/(() => {\n  class MatRangeDateSelectionModel extends MatDateSelectionModel {\n    constructor(adapter) {\n      super(new DateRange(null, null), adapter);\n    }\n    add(date) {\n      let {\n        start,\n        end\n      } = this.selection;\n      if (start == null) {\n        start = date;\n      } else if (end == null) {\n        end = date;\n      } else {\n        start = date;\n        end = null;\n      }\n      super.updateSelection(new DateRange(start, end), this);\n    }\n    isValid() {\n      const {\n        start,\n        end\n      } = this.selection;\n      if (start == null && end == null) {\n        return true;\n      }\n      if (start != null && end != null) {\n        return this._isValidDateInstance(start) && this._isValidDateInstance(end) && this._adapter.compareDate(start, end) <= 0;\n      }\n      return (start == null || this._isValidDateInstance(start)) && (end == null || this._isValidDateInstance(end));\n    }\n    isComplete() {\n      return this.selection.start != null && this.selection.end != null;\n    }\n    clone() {\n      const clone = new MatRangeDateSelectionModel(this._adapter);\n      clone.updateSelection(this.selection, this);\n      return clone;\n    }\n    static ɵfac = function MatRangeDateSelectionModel_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatRangeDateSelectionModel)(i0.ɵɵinject(DateAdapter));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: MatRangeDateSelectionModel,\n      factory: MatRangeDateSelectionModel.ɵfac\n    });\n  }\n  return MatRangeDateSelectionModel;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER = {\n  provide: MatDateSelectionModel,\n  useFactory: () => {\n    const parent = inject(MatDateSelectionModel, {\n      optional: true,\n      skipSelf: true\n    });\n    return parent || new MatSingleDateSelectionModel(inject(DateAdapter));\n  }\n};\nconst MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER = {\n  provide: MatDateSelectionModel,\n  useFactory: () => {\n    const parent = inject(MatDateSelectionModel, {\n      optional: true,\n      skipSelf: true\n    });\n    return parent || new MatRangeDateSelectionModel(inject(DateAdapter));\n  }\n};\nconst MAT_DATE_RANGE_SELECTION_STRATEGY = /*#__PURE__*/new InjectionToken('MAT_DATE_RANGE_SELECTION_STRATEGY');\nlet DefaultMatCalendarRangeStrategy = /*#__PURE__*/(() => {\n  class DefaultMatCalendarRangeStrategy {\n    _dateAdapter;\n    constructor(_dateAdapter) {\n      this._dateAdapter = _dateAdapter;\n    }\n    selectionFinished(date, currentRange) {\n      let {\n        start,\n        end\n      } = currentRange;\n      if (start == null) {\n        start = date;\n      } else if (end == null && date && this._dateAdapter.compareDate(date, start) >= 0) {\n        end = date;\n      } else {\n        start = date;\n        end = null;\n      }\n      return new DateRange(start, end);\n    }\n    createPreview(activeDate, currentRange) {\n      let start = null;\n      let end = null;\n      if (currentRange.start && !currentRange.end && activeDate) {\n        start = currentRange.start;\n        end = activeDate;\n      }\n      return new DateRange(start, end);\n    }\n    createDrag(dragOrigin, originalRange, newDate) {\n      let start = originalRange.start;\n      let end = originalRange.end;\n      if (!start || !end) {\n        return null;\n      }\n      const adapter = this._dateAdapter;\n      const isRange = adapter.compareDate(start, end) !== 0;\n      const diffYears = adapter.getYear(newDate) - adapter.getYear(dragOrigin);\n      const diffMonths = adapter.getMonth(newDate) - adapter.getMonth(dragOrigin);\n      const diffDays = adapter.getDate(newDate) - adapter.getDate(dragOrigin);\n      if (isRange && adapter.sameDate(dragOrigin, originalRange.start)) {\n        start = newDate;\n        if (adapter.compareDate(newDate, end) > 0) {\n          end = adapter.addCalendarYears(end, diffYears);\n          end = adapter.addCalendarMonths(end, diffMonths);\n          end = adapter.addCalendarDays(end, diffDays);\n        }\n      } else if (isRange && adapter.sameDate(dragOrigin, originalRange.end)) {\n        end = newDate;\n        if (adapter.compareDate(newDate, start) < 0) {\n          start = adapter.addCalendarYears(start, diffYears);\n          start = adapter.addCalendarMonths(start, diffMonths);\n          start = adapter.addCalendarDays(start, diffDays);\n        }\n      } else {\n        start = adapter.addCalendarYears(start, diffYears);\n        start = adapter.addCalendarMonths(start, diffMonths);\n        start = adapter.addCalendarDays(start, diffDays);\n        end = adapter.addCalendarYears(end, diffYears);\n        end = adapter.addCalendarMonths(end, diffMonths);\n        end = adapter.addCalendarDays(end, diffDays);\n      }\n      return new DateRange(start, end);\n    }\n    static ɵfac = function DefaultMatCalendarRangeStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultMatCalendarRangeStrategy)(i0.ɵɵinject(DateAdapter));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultMatCalendarRangeStrategy,\n      factory: DefaultMatCalendarRangeStrategy.ɵfac\n    });\n  }\n  return DefaultMatCalendarRangeStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DAYS_PER_WEEK = 7;\nlet uniqueIdCounter = 0;\nlet MatMonthView = /*#__PURE__*/(() => {\n  class MatMonthView {\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _dateFormats = inject(MAT_DATE_FORMATS, {\n      optional: true\n    });\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _rangeStrategy = inject(MAT_DATE_RANGE_SELECTION_STRATEGY, {\n      optional: true\n    });\n    _rerenderSubscription = Subscription.EMPTY;\n    _selectionKeyPressed;\n    get activeDate() {\n      return this._activeDate;\n    }\n    set activeDate(value) {\n      const oldActiveDate = this._activeDate;\n      const validDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n      if (!this._hasSameMonthAndYear(oldActiveDate, this._activeDate)) {\n        this._init();\n      }\n    }\n    _activeDate;\n    get selected() {\n      return this._selected;\n    }\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      this._setRanges(this._selected);\n    }\n    _selected;\n    get minDate() {\n      return this._minDate;\n    }\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _minDate;\n    get maxDate() {\n      return this._maxDate;\n    }\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _maxDate;\n    dateFilter;\n    dateClass;\n    comparisonStart;\n    comparisonEnd;\n    startDateAccessibleName;\n    endDateAccessibleName;\n    activeDrag = null;\n    selectedChange = new EventEmitter();\n    _userSelection = new EventEmitter();\n    dragStarted = new EventEmitter();\n    dragEnded = new EventEmitter();\n    activeDateChange = new EventEmitter();\n    _matCalendarBody;\n    _monthLabel = signal('', ...(ngDevMode ? [{\n      debugName: \"_monthLabel\"\n    }] : []));\n    _weeks = signal([], ...(ngDevMode ? [{\n      debugName: \"_weeks\"\n    }] : []));\n    _firstWeekOffset = signal(0, ...(ngDevMode ? [{\n      debugName: \"_firstWeekOffset\"\n    }] : []));\n    _rangeStart = signal(null, ...(ngDevMode ? [{\n      debugName: \"_rangeStart\"\n    }] : []));\n    _rangeEnd = signal(null, ...(ngDevMode ? [{\n      debugName: \"_rangeEnd\"\n    }] : []));\n    _comparisonRangeStart = signal(null, ...(ngDevMode ? [{\n      debugName: \"_comparisonRangeStart\"\n    }] : []));\n    _comparisonRangeEnd = signal(null, ...(ngDevMode ? [{\n      debugName: \"_comparisonRangeEnd\"\n    }] : []));\n    _previewStart = signal(null, ...(ngDevMode ? [{\n      debugName: \"_previewStart\"\n    }] : []));\n    _previewEnd = signal(null, ...(ngDevMode ? [{\n      debugName: \"_previewEnd\"\n    }] : []));\n    _isRange = signal(false, ...(ngDevMode ? [{\n      debugName: \"_isRange\"\n    }] : []));\n    _todayDate = signal(null, ...(ngDevMode ? [{\n      debugName: \"_todayDate\"\n    }] : []));\n    _weekdays = signal([], ...(ngDevMode ? [{\n      debugName: \"_weekdays\"\n    }] : []));\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n      this._activeDate = this._dateAdapter.today();\n    }\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(() => this._init());\n    }\n    ngOnChanges(changes) {\n      const comparisonChange = changes['comparisonStart'] || changes['comparisonEnd'];\n      if (comparisonChange && !comparisonChange.firstChange) {\n        this._setRanges(this.selected);\n      }\n      if (changes['activeDrag'] && !this.activeDrag) {\n        this._clearPreview();\n      }\n    }\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    _dateSelected(event) {\n      const date = event.value;\n      const selectedDate = this._getDateFromDayOfMonth(date);\n      let rangeStartDate;\n      let rangeEndDate;\n      if (this._selected instanceof DateRange) {\n        rangeStartDate = this._getDateInCurrentMonth(this._selected.start);\n        rangeEndDate = this._getDateInCurrentMonth(this._selected.end);\n      } else {\n        rangeStartDate = rangeEndDate = this._getDateInCurrentMonth(this._selected);\n      }\n      if (rangeStartDate !== date || rangeEndDate !== date) {\n        this.selectedChange.emit(selectedDate);\n      }\n      this._userSelection.emit({\n        value: selectedDate,\n        event: event.event\n      });\n      this._clearPreview();\n      this._changeDetectorRef.markForCheck();\n    }\n    _updateActiveDate(event) {\n      const month = event.value;\n      const oldActiveDate = this._activeDate;\n      this.activeDate = this._getDateFromDayOfMonth(month);\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this._activeDate);\n      }\n    }\n    _handleCalendarBodyKeydown(event) {\n      const oldActiveDate = this._activeDate;\n      const isRtl = this._isRtl();\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? 1 : -1);\n          break;\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, isRtl ? -1 : 1);\n          break;\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, -7);\n          break;\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 7);\n          break;\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, 1 - this._dateAdapter.getDate(this._activeDate));\n          break;\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarDays(this._activeDate, this._dateAdapter.getNumDaysInMonth(this._activeDate) - this._dateAdapter.getDate(this._activeDate));\n          break;\n        case PAGE_UP:\n          this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, -1) : this._dateAdapter.addCalendarMonths(this._activeDate, -1);\n          break;\n        case PAGE_DOWN:\n          this.activeDate = event.altKey ? this._dateAdapter.addCalendarYears(this._activeDate, 1) : this._dateAdapter.addCalendarMonths(this._activeDate, 1);\n          break;\n        case ENTER:\n        case SPACE:\n          this._selectionKeyPressed = true;\n          if (this._canSelect(this._activeDate)) {\n            event.preventDefault();\n          }\n          return;\n        case ESCAPE:\n          if (this._previewEnd() != null && !hasModifierKey(event)) {\n            this._clearPreview();\n            if (this.activeDrag) {\n              this.dragEnded.emit({\n                value: null,\n                event\n              });\n            } else {\n              this.selectedChange.emit(null);\n              this._userSelection.emit({\n                value: null,\n                event\n              });\n            }\n            event.preventDefault();\n            event.stopPropagation();\n          }\n          return;\n        default:\n          return;\n      }\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n        this._focusActiveCellAfterViewChecked();\n      }\n      event.preventDefault();\n    }\n    _handleCalendarBodyKeyup(event) {\n      if (event.keyCode === SPACE || event.keyCode === ENTER) {\n        if (this._selectionKeyPressed && this._canSelect(this._activeDate)) {\n          this._dateSelected({\n            value: this._dateAdapter.getDate(this._activeDate),\n            event\n          });\n        }\n        this._selectionKeyPressed = false;\n      }\n    }\n    _init() {\n      this._setRanges(this.selected);\n      this._todayDate.set(this._getCellCompareValue(this._dateAdapter.today()));\n      this._monthLabel.set(this._dateFormats.display.monthLabel ? this._dateAdapter.format(this.activeDate, this._dateFormats.display.monthLabel) : this._dateAdapter.getMonthNames('short')[this._dateAdapter.getMonth(this.activeDate)].toLocaleUpperCase());\n      let firstOfMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), 1);\n      this._firstWeekOffset.set((DAYS_PER_WEEK + this._dateAdapter.getDayOfWeek(firstOfMonth) - this._dateAdapter.getFirstDayOfWeek()) % DAYS_PER_WEEK);\n      this._initWeekdays();\n      this._createWeekCells();\n      this._changeDetectorRef.markForCheck();\n    }\n    _focusActiveCell(movePreview) {\n      this._matCalendarBody._focusActiveCell(movePreview);\n    }\n    _focusActiveCellAfterViewChecked() {\n      this._matCalendarBody._scheduleFocusActiveCellAfterViewChecked();\n    }\n    _previewChanged({\n      event,\n      value: cell\n    }) {\n      if (this._rangeStrategy) {\n        const value = cell ? cell.rawValue : null;\n        const previewRange = this._rangeStrategy.createPreview(value, this.selected, event);\n        this._previewStart.set(this._getCellCompareValue(previewRange.start));\n        this._previewEnd.set(this._getCellCompareValue(previewRange.end));\n        if (this.activeDrag && value) {\n          const dragRange = this._rangeStrategy.createDrag?.(this.activeDrag.value, this.selected, value, event);\n          if (dragRange) {\n            this._previewStart.set(this._getCellCompareValue(dragRange.start));\n            this._previewEnd.set(this._getCellCompareValue(dragRange.end));\n          }\n        }\n      }\n    }\n    _dragEnded(event) {\n      if (!this.activeDrag) return;\n      if (event.value) {\n        const dragDropResult = this._rangeStrategy?.createDrag?.(this.activeDrag.value, this.selected, event.value, event.event);\n        this.dragEnded.emit({\n          value: dragDropResult ?? null,\n          event: event.event\n        });\n      } else {\n        this.dragEnded.emit({\n          value: null,\n          event: event.event\n        });\n      }\n    }\n    _getDateFromDayOfMonth(dayOfMonth) {\n      return this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), dayOfMonth);\n    }\n    _initWeekdays() {\n      const firstDayOfWeek = this._dateAdapter.getFirstDayOfWeek();\n      const narrowWeekdays = this._dateAdapter.getDayOfWeekNames('narrow');\n      const longWeekdays = this._dateAdapter.getDayOfWeekNames('long');\n      const weekdays = longWeekdays.map((long, i) => {\n        return {\n          long,\n          narrow: narrowWeekdays[i],\n          id: uniqueIdCounter++\n        };\n      });\n      this._weekdays.set(weekdays.slice(firstDayOfWeek).concat(weekdays.slice(0, firstDayOfWeek)));\n    }\n    _createWeekCells() {\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(this.activeDate);\n      const dateNames = this._dateAdapter.getDateNames();\n      const weeks = [[]];\n      for (let i = 0, cell = this._firstWeekOffset(); i < daysInMonth; i++, cell++) {\n        if (cell == DAYS_PER_WEEK) {\n          weeks.push([]);\n          cell = 0;\n        }\n        const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), this._dateAdapter.getMonth(this.activeDate), i + 1);\n        const enabled = this._shouldEnableDate(date);\n        const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.dateA11yLabel);\n        const cellClasses = this.dateClass ? this.dateClass(date, 'month') : undefined;\n        weeks[weeks.length - 1].push(new MatCalendarCell(i + 1, dateNames[i], ariaLabel, enabled, cellClasses, this._getCellCompareValue(date), date));\n      }\n      this._weeks.set(weeks);\n    }\n    _shouldEnableDate(date) {\n      return !!date && (!this.minDate || this._dateAdapter.compareDate(date, this.minDate) >= 0) && (!this.maxDate || this._dateAdapter.compareDate(date, this.maxDate) <= 0) && (!this.dateFilter || this.dateFilter(date));\n    }\n    _getDateInCurrentMonth(date) {\n      return date && this._hasSameMonthAndYear(date, this.activeDate) ? this._dateAdapter.getDate(date) : null;\n    }\n    _hasSameMonthAndYear(d1, d2) {\n      return !!(d1 && d2 && this._dateAdapter.getMonth(d1) == this._dateAdapter.getMonth(d2) && this._dateAdapter.getYear(d1) == this._dateAdapter.getYear(d2));\n    }\n    _getCellCompareValue(date) {\n      if (date) {\n        const year = this._dateAdapter.getYear(date);\n        const month = this._dateAdapter.getMonth(date);\n        const day = this._dateAdapter.getDate(date);\n        return new Date(year, month, day).getTime();\n      }\n      return null;\n    }\n    _isRtl() {\n      return this._dir && this._dir.value === 'rtl';\n    }\n    _setRanges(selectedValue) {\n      if (selectedValue instanceof DateRange) {\n        this._rangeStart.set(this._getCellCompareValue(selectedValue.start));\n        this._rangeEnd.set(this._getCellCompareValue(selectedValue.end));\n        this._isRange.set(true);\n      } else {\n        this._rangeStart.set(this._getCellCompareValue(selectedValue));\n        this._rangeEnd.set(this._rangeStart());\n        this._isRange.set(false);\n      }\n      this._comparisonRangeStart.set(this._getCellCompareValue(this.comparisonStart));\n      this._comparisonRangeEnd.set(this._getCellCompareValue(this.comparisonEnd));\n    }\n    _canSelect(date) {\n      return !this.dateFilter || this.dateFilter(date);\n    }\n    _clearPreview() {\n      this._previewStart.set(null);\n      this._previewEnd.set(null);\n    }\n    static ɵfac = function MatMonthView_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMonthView)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatMonthView,\n      selectors: [[\"mat-month-view\"]],\n      viewQuery: function MatMonthView_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatCalendarBody, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n        }\n      },\n      inputs: {\n        activeDate: \"activeDate\",\n        selected: \"selected\",\n        minDate: \"minDate\",\n        maxDate: \"maxDate\",\n        dateFilter: \"dateFilter\",\n        dateClass: \"dateClass\",\n        comparisonStart: \"comparisonStart\",\n        comparisonEnd: \"comparisonEnd\",\n        startDateAccessibleName: \"startDateAccessibleName\",\n        endDateAccessibleName: \"endDateAccessibleName\",\n        activeDrag: \"activeDrag\"\n      },\n      outputs: {\n        selectedChange: \"selectedChange\",\n        _userSelection: \"_userSelection\",\n        dragStarted: \"dragStarted\",\n        dragEnded: \"dragEnded\",\n        activeDateChange: \"activeDateChange\"\n      },\n      exportAs: [\"matMonthView\"],\n      features: [i0.ɵɵNgOnChangesFeature],\n      decls: 8,\n      vars: 14,\n      consts: [[\"role\", \"grid\", 1, \"mat-calendar-table\"], [1, \"mat-calendar-table-header\"], [\"scope\", \"col\"], [\"aria-hidden\", \"true\"], [\"colspan\", \"7\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"selectedValueChange\", \"activeDateChange\", \"previewChange\", \"dragStarted\", \"dragEnded\", \"keyup\", \"keydown\", \"label\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"comparisonStart\", \"comparisonEnd\", \"previewStart\", \"previewEnd\", \"isRange\", \"labelMinRequiredCells\", \"activeCell\", \"startDateAccessibleName\", \"endDateAccessibleName\"], [1, \"cdk-visually-hidden\"]],\n      template: function MatMonthView_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"table\", 0)(1, \"thead\", 1)(2, \"tr\");\n          i0.ɵɵrepeaterCreate(3, MatMonthView_For_4_Template, 5, 2, \"th\", 2, _forTrack1);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(5, \"tr\", 3);\n          i0.ɵɵelement(6, \"th\", 4);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(7, \"tbody\", 5);\n          i0.ɵɵlistener(\"selectedValueChange\", function MatMonthView_Template_tbody_selectedValueChange_7_listener($event) {\n            return ctx._dateSelected($event);\n          })(\"activeDateChange\", function MatMonthView_Template_tbody_activeDateChange_7_listener($event) {\n            return ctx._updateActiveDate($event);\n          })(\"previewChange\", function MatMonthView_Template_tbody_previewChange_7_listener($event) {\n            return ctx._previewChanged($event);\n          })(\"dragStarted\", function MatMonthView_Template_tbody_dragStarted_7_listener($event) {\n            return ctx.dragStarted.emit($event);\n          })(\"dragEnded\", function MatMonthView_Template_tbody_dragEnded_7_listener($event) {\n            return ctx._dragEnded($event);\n          })(\"keyup\", function MatMonthView_Template_tbody_keyup_7_listener($event) {\n            return ctx._handleCalendarBodyKeyup($event);\n          })(\"keydown\", function MatMonthView_Template_tbody_keydown_7_listener($event) {\n            return ctx._handleCalendarBodyKeydown($event);\n          });\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(3);\n          i0.ɵɵrepeater(ctx._weekdays());\n          i0.ɵɵadvance(4);\n          i0.ɵɵproperty(\"label\", ctx._monthLabel())(\"rows\", ctx._weeks())(\"todayValue\", ctx._todayDate())(\"startValue\", ctx._rangeStart())(\"endValue\", ctx._rangeEnd())(\"comparisonStart\", ctx._comparisonRangeStart())(\"comparisonEnd\", ctx._comparisonRangeEnd())(\"previewStart\", ctx._previewStart())(\"previewEnd\", ctx._previewEnd())(\"isRange\", ctx._isRange())(\"labelMinRequiredCells\", 3)(\"activeCell\", ctx._dateAdapter.getDate(ctx.activeDate) - 1)(\"startDateAccessibleName\", ctx.startDateAccessibleName)(\"endDateAccessibleName\", ctx.endDateAccessibleName);\n        }\n      },\n      dependencies: [MatCalendarBody],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatMonthView;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst yearsPerPage = 24;\nconst yearsPerRow = 4;\nlet MatMultiYearView = /*#__PURE__*/(() => {\n  class MatMultiYearView {\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _rerenderSubscription = Subscription.EMPTY;\n    _selectionKeyPressed;\n    get activeDate() {\n      return this._activeDate;\n    }\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n      const validDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n      if (!isSameMultiYearView(this._dateAdapter, oldActiveDate, this._activeDate, this.minDate, this.maxDate)) {\n        this._init();\n      }\n    }\n    _activeDate;\n    get selected() {\n      return this._selected;\n    }\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      this._setSelectedYear(value);\n    }\n    _selected;\n    get minDate() {\n      return this._minDate;\n    }\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _minDate;\n    get maxDate() {\n      return this._maxDate;\n    }\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _maxDate;\n    dateFilter;\n    dateClass;\n    selectedChange = new EventEmitter();\n    yearSelected = new EventEmitter();\n    activeDateChange = new EventEmitter();\n    _matCalendarBody;\n    _years = signal([], ...(ngDevMode ? [{\n      debugName: \"_years\"\n    }] : []));\n    _todayYear = signal(0, ...(ngDevMode ? [{\n      debugName: \"_todayYear\"\n    }] : []));\n    _selectedYear = signal(null, ...(ngDevMode ? [{\n      debugName: \"_selectedYear\"\n    }] : []));\n    constructor() {\n      if (!this._dateAdapter && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n      this._activeDate = this._dateAdapter.today();\n    }\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(() => this._init());\n    }\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    _init() {\n      this._todayYear.set(this._dateAdapter.getYear(this._dateAdapter.today()));\n      const activeYear = this._dateAdapter.getYear(this._activeDate);\n      const minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\n      const years = [];\n      for (let i = 0, row = []; i < yearsPerPage; i++) {\n        row.push(minYearOfPage + i);\n        if (row.length == yearsPerRow) {\n          years.push(row.map(year => this._createCellForYear(year)));\n          row = [];\n        }\n      }\n      this._years.set(years);\n      this._changeDetectorRef.markForCheck();\n    }\n    _yearSelected(event) {\n      const year = event.value;\n      const selectedYear = this._dateAdapter.createDate(year, 0, 1);\n      const selectedDate = this._getDateFromYear(year);\n      this.yearSelected.emit(selectedYear);\n      this.selectedChange.emit(selectedDate);\n    }\n    _updateActiveDate(event) {\n      const year = event.value;\n      const oldActiveDate = this._activeDate;\n      this.activeDate = this._getDateFromYear(year);\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n    }\n    _handleCalendarBodyKeydown(event) {\n      const oldActiveDate = this._activeDate;\n      const isRtl = this._isRtl();\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? 1 : -1);\n          break;\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, isRtl ? -1 : 1);\n          break;\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -yearsPerRow);\n          break;\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerRow);\n          break;\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, -getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate));\n          break;\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, yearsPerPage - getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate) - 1);\n          break;\n        case PAGE_UP:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -yearsPerPage * 10 : -yearsPerPage);\n          break;\n        case PAGE_DOWN:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? yearsPerPage * 10 : yearsPerPage);\n          break;\n        case ENTER:\n        case SPACE:\n          this._selectionKeyPressed = true;\n          break;\n        default:\n          return;\n      }\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n      this._focusActiveCellAfterViewChecked();\n      event.preventDefault();\n    }\n    _handleCalendarBodyKeyup(event) {\n      if (event.keyCode === SPACE || event.keyCode === ENTER) {\n        if (this._selectionKeyPressed) {\n          this._yearSelected({\n            value: this._dateAdapter.getYear(this._activeDate),\n            event\n          });\n        }\n        this._selectionKeyPressed = false;\n      }\n    }\n    _getActiveCell() {\n      return getActiveOffset(this._dateAdapter, this.activeDate, this.minDate, this.maxDate);\n    }\n    _focusActiveCell() {\n      this._matCalendarBody._focusActiveCell();\n    }\n    _focusActiveCellAfterViewChecked() {\n      this._matCalendarBody._scheduleFocusActiveCellAfterViewChecked();\n    }\n    _getDateFromYear(year) {\n      const activeMonth = this._dateAdapter.getMonth(this.activeDate);\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(this._dateAdapter.createDate(year, activeMonth, 1));\n      const normalizedDate = this._dateAdapter.createDate(year, activeMonth, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth));\n      return normalizedDate;\n    }\n    _createCellForYear(year) {\n      const date = this._dateAdapter.createDate(year, 0, 1);\n      const yearName = this._dateAdapter.getYearName(date);\n      const cellClasses = this.dateClass ? this.dateClass(date, 'multi-year') : undefined;\n      return new MatCalendarCell(year, yearName, yearName, this._shouldEnableYear(year), cellClasses);\n    }\n    _shouldEnableYear(year) {\n      if (year === undefined || year === null || this.maxDate && year > this._dateAdapter.getYear(this.maxDate) || this.minDate && year < this._dateAdapter.getYear(this.minDate)) {\n        return false;\n      }\n      if (!this.dateFilter) {\n        return true;\n      }\n      const firstOfYear = this._dateAdapter.createDate(year, 0, 1);\n      for (let date = firstOfYear; this._dateAdapter.getYear(date) == year; date = this._dateAdapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    _isRtl() {\n      return this._dir && this._dir.value === 'rtl';\n    }\n    _setSelectedYear(value) {\n      this._selectedYear.set(null);\n      if (value instanceof DateRange) {\n        const displayValue = value.start || value.end;\n        if (displayValue) {\n          this._selectedYear.set(this._dateAdapter.getYear(displayValue));\n        }\n      } else if (value) {\n        this._selectedYear.set(this._dateAdapter.getYear(value));\n      }\n    }\n    static ɵfac = function MatMultiYearView_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatMultiYearView)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatMultiYearView,\n      selectors: [[\"mat-multi-year-view\"]],\n      viewQuery: function MatMultiYearView_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatCalendarBody, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n        }\n      },\n      inputs: {\n        activeDate: \"activeDate\",\n        selected: \"selected\",\n        minDate: \"minDate\",\n        maxDate: \"maxDate\",\n        dateFilter: \"dateFilter\",\n        dateClass: \"dateClass\"\n      },\n      outputs: {\n        selectedChange: \"selectedChange\",\n        yearSelected: \"yearSelected\",\n        activeDateChange: \"activeDateChange\"\n      },\n      exportAs: [\"matMultiYearView\"],\n      decls: 5,\n      vars: 7,\n      consts: [[\"role\", \"grid\", 1, \"mat-calendar-table\"], [\"aria-hidden\", \"true\", 1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"selectedValueChange\", \"activeDateChange\", \"keyup\", \"keydown\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"numCols\", \"cellAspectRatio\", \"activeCell\"]],\n      template: function MatMultiYearView_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"table\", 0)(1, \"thead\", 1)(2, \"tr\");\n          i0.ɵɵelement(3, \"th\", 2);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(4, \"tbody\", 3);\n          i0.ɵɵlistener(\"selectedValueChange\", function MatMultiYearView_Template_tbody_selectedValueChange_4_listener($event) {\n            return ctx._yearSelected($event);\n          })(\"activeDateChange\", function MatMultiYearView_Template_tbody_activeDateChange_4_listener($event) {\n            return ctx._updateActiveDate($event);\n          })(\"keyup\", function MatMultiYearView_Template_tbody_keyup_4_listener($event) {\n            return ctx._handleCalendarBodyKeyup($event);\n          })(\"keydown\", function MatMultiYearView_Template_tbody_keydown_4_listener($event) {\n            return ctx._handleCalendarBodyKeydown($event);\n          });\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(4);\n          i0.ɵɵproperty(\"rows\", ctx._years())(\"todayValue\", ctx._todayYear())(\"startValue\", ctx._selectedYear())(\"endValue\", ctx._selectedYear())(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._getActiveCell());\n        }\n      },\n      dependencies: [MatCalendarBody],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatMultiYearView;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isSameMultiYearView(dateAdapter, date1, date2, minDate, maxDate) {\n  const year1 = dateAdapter.getYear(date1);\n  const year2 = dateAdapter.getYear(date2);\n  const startingYear = getStartingYear(dateAdapter, minDate, maxDate);\n  return Math.floor((year1 - startingYear) / yearsPerPage) === Math.floor((year2 - startingYear) / yearsPerPage);\n}\nfunction getActiveOffset(dateAdapter, activeDate, minDate, maxDate) {\n  const activeYear = dateAdapter.getYear(activeDate);\n  return euclideanModulo(activeYear - getStartingYear(dateAdapter, minDate, maxDate), yearsPerPage);\n}\nfunction getStartingYear(dateAdapter, minDate, maxDate) {\n  let startingYear = 0;\n  if (maxDate) {\n    const maxYear = dateAdapter.getYear(maxDate);\n    startingYear = maxYear - yearsPerPage + 1;\n  } else if (minDate) {\n    startingYear = dateAdapter.getYear(minDate);\n  }\n  return startingYear;\n}\nfunction euclideanModulo(a, b) {\n  return (a % b + b) % b;\n}\nlet MatYearView = /*#__PURE__*/(() => {\n  class MatYearView {\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _dateFormats = inject(MAT_DATE_FORMATS, {\n      optional: true\n    });\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _rerenderSubscription = Subscription.EMPTY;\n    _selectionKeyPressed;\n    get activeDate() {\n      return this._activeDate;\n    }\n    set activeDate(value) {\n      let oldActiveDate = this._activeDate;\n      const validDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value)) || this._dateAdapter.today();\n      this._activeDate = this._dateAdapter.clampDate(validDate, this.minDate, this.maxDate);\n      if (this._dateAdapter.getYear(oldActiveDate) !== this._dateAdapter.getYear(this._activeDate)) {\n        this._init();\n      }\n    }\n    _activeDate;\n    get selected() {\n      return this._selected;\n    }\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n      this._setSelectedMonth(value);\n    }\n    _selected;\n    get minDate() {\n      return this._minDate;\n    }\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _minDate;\n    get maxDate() {\n      return this._maxDate;\n    }\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _maxDate;\n    dateFilter;\n    dateClass;\n    selectedChange = new EventEmitter();\n    monthSelected = new EventEmitter();\n    activeDateChange = new EventEmitter();\n    _matCalendarBody;\n    _months = signal([], ...(ngDevMode ? [{\n      debugName: \"_months\"\n    }] : []));\n    _yearLabel = signal('', ...(ngDevMode ? [{\n      debugName: \"_yearLabel\"\n    }] : []));\n    _todayMonth = signal(null, ...(ngDevMode ? [{\n      debugName: \"_todayMonth\"\n    }] : []));\n    _selectedMonth = signal(null, ...(ngDevMode ? [{\n      debugName: \"_selectedMonth\"\n    }] : []));\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n      this._activeDate = this._dateAdapter.today();\n    }\n    ngAfterContentInit() {\n      this._rerenderSubscription = this._dateAdapter.localeChanges.pipe(startWith(null)).subscribe(() => this._init());\n    }\n    ngOnDestroy() {\n      this._rerenderSubscription.unsubscribe();\n    }\n    _monthSelected(event) {\n      const month = event.value;\n      const selectedMonth = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n      this.monthSelected.emit(selectedMonth);\n      const selectedDate = this._getDateFromMonth(month);\n      this.selectedChange.emit(selectedDate);\n    }\n    _updateActiveDate(event) {\n      const month = event.value;\n      const oldActiveDate = this._activeDate;\n      this.activeDate = this._getDateFromMonth(month);\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n      }\n    }\n    _handleCalendarBodyKeydown(event) {\n      const oldActiveDate = this._activeDate;\n      const isRtl = this._isRtl();\n      switch (event.keyCode) {\n        case LEFT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? 1 : -1);\n          break;\n        case RIGHT_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, isRtl ? -1 : 1);\n          break;\n        case UP_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -4);\n          break;\n        case DOWN_ARROW:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 4);\n          break;\n        case HOME:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, -this._dateAdapter.getMonth(this._activeDate));\n          break;\n        case END:\n          this.activeDate = this._dateAdapter.addCalendarMonths(this._activeDate, 11 - this._dateAdapter.getMonth(this._activeDate));\n          break;\n        case PAGE_UP:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? -10 : -1);\n          break;\n        case PAGE_DOWN:\n          this.activeDate = this._dateAdapter.addCalendarYears(this._activeDate, event.altKey ? 10 : 1);\n          break;\n        case ENTER:\n        case SPACE:\n          this._selectionKeyPressed = true;\n          break;\n        default:\n          return;\n      }\n      if (this._dateAdapter.compareDate(oldActiveDate, this.activeDate)) {\n        this.activeDateChange.emit(this.activeDate);\n        this._focusActiveCellAfterViewChecked();\n      }\n      event.preventDefault();\n    }\n    _handleCalendarBodyKeyup(event) {\n      if (event.keyCode === SPACE || event.keyCode === ENTER) {\n        if (this._selectionKeyPressed) {\n          this._monthSelected({\n            value: this._dateAdapter.getMonth(this._activeDate),\n            event\n          });\n        }\n        this._selectionKeyPressed = false;\n      }\n    }\n    _init() {\n      this._setSelectedMonth(this.selected);\n      this._todayMonth.set(this._getMonthInCurrentYear(this._dateAdapter.today()));\n      this._yearLabel.set(this._dateAdapter.getYearName(this.activeDate));\n      let monthNames = this._dateAdapter.getMonthNames('short');\n      this._months.set([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]].map(row => row.map(month => this._createCellForMonth(month, monthNames[month]))));\n      this._changeDetectorRef.markForCheck();\n    }\n    _focusActiveCell() {\n      this._matCalendarBody._focusActiveCell();\n    }\n    _focusActiveCellAfterViewChecked() {\n      this._matCalendarBody._scheduleFocusActiveCellAfterViewChecked();\n    }\n    _getMonthInCurrentYear(date) {\n      return date && this._dateAdapter.getYear(date) == this._dateAdapter.getYear(this.activeDate) ? this._dateAdapter.getMonth(date) : null;\n    }\n    _getDateFromMonth(month) {\n      const normalizedDate = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n      const daysInMonth = this._dateAdapter.getNumDaysInMonth(normalizedDate);\n      return this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, Math.min(this._dateAdapter.getDate(this.activeDate), daysInMonth));\n    }\n    _createCellForMonth(month, monthName) {\n      const date = this._dateAdapter.createDate(this._dateAdapter.getYear(this.activeDate), month, 1);\n      const ariaLabel = this._dateAdapter.format(date, this._dateFormats.display.monthYearA11yLabel);\n      const cellClasses = this.dateClass ? this.dateClass(date, 'year') : undefined;\n      return new MatCalendarCell(month, monthName.toLocaleUpperCase(), ariaLabel, this._shouldEnableMonth(month), cellClasses);\n    }\n    _shouldEnableMonth(month) {\n      const activeYear = this._dateAdapter.getYear(this.activeDate);\n      if (month === undefined || month === null || this._isYearAndMonthAfterMaxDate(activeYear, month) || this._isYearAndMonthBeforeMinDate(activeYear, month)) {\n        return false;\n      }\n      if (!this.dateFilter) {\n        return true;\n      }\n      const firstOfMonth = this._dateAdapter.createDate(activeYear, month, 1);\n      for (let date = firstOfMonth; this._dateAdapter.getMonth(date) == month; date = this._dateAdapter.addCalendarDays(date, 1)) {\n        if (this.dateFilter(date)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    _isYearAndMonthAfterMaxDate(year, month) {\n      if (this.maxDate) {\n        const maxYear = this._dateAdapter.getYear(this.maxDate);\n        const maxMonth = this._dateAdapter.getMonth(this.maxDate);\n        return year > maxYear || year === maxYear && month > maxMonth;\n      }\n      return false;\n    }\n    _isYearAndMonthBeforeMinDate(year, month) {\n      if (this.minDate) {\n        const minYear = this._dateAdapter.getYear(this.minDate);\n        const minMonth = this._dateAdapter.getMonth(this.minDate);\n        return year < minYear || year === minYear && month < minMonth;\n      }\n      return false;\n    }\n    _isRtl() {\n      return this._dir && this._dir.value === 'rtl';\n    }\n    _setSelectedMonth(value) {\n      if (value instanceof DateRange) {\n        this._selectedMonth.set(this._getMonthInCurrentYear(value.start) || this._getMonthInCurrentYear(value.end));\n      } else {\n        this._selectedMonth.set(this._getMonthInCurrentYear(value));\n      }\n    }\n    static ɵfac = function MatYearView_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatYearView)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatYearView,\n      selectors: [[\"mat-year-view\"]],\n      viewQuery: function MatYearView_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatCalendarBody, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._matCalendarBody = _t.first);\n        }\n      },\n      inputs: {\n        activeDate: \"activeDate\",\n        selected: \"selected\",\n        minDate: \"minDate\",\n        maxDate: \"maxDate\",\n        dateFilter: \"dateFilter\",\n        dateClass: \"dateClass\"\n      },\n      outputs: {\n        selectedChange: \"selectedChange\",\n        monthSelected: \"monthSelected\",\n        activeDateChange: \"activeDateChange\"\n      },\n      exportAs: [\"matYearView\"],\n      decls: 5,\n      vars: 9,\n      consts: [[\"role\", \"grid\", 1, \"mat-calendar-table\"], [\"aria-hidden\", \"true\", 1, \"mat-calendar-table-header\"], [\"colspan\", \"4\", 1, \"mat-calendar-table-header-divider\"], [\"mat-calendar-body\", \"\", 3, \"selectedValueChange\", \"activeDateChange\", \"keyup\", \"keydown\", \"label\", \"rows\", \"todayValue\", \"startValue\", \"endValue\", \"labelMinRequiredCells\", \"numCols\", \"cellAspectRatio\", \"activeCell\"]],\n      template: function MatYearView_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"table\", 0)(1, \"thead\", 1)(2, \"tr\");\n          i0.ɵɵelement(3, \"th\", 2);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(4, \"tbody\", 3);\n          i0.ɵɵlistener(\"selectedValueChange\", function MatYearView_Template_tbody_selectedValueChange_4_listener($event) {\n            return ctx._monthSelected($event);\n          })(\"activeDateChange\", function MatYearView_Template_tbody_activeDateChange_4_listener($event) {\n            return ctx._updateActiveDate($event);\n          })(\"keyup\", function MatYearView_Template_tbody_keyup_4_listener($event) {\n            return ctx._handleCalendarBodyKeyup($event);\n          })(\"keydown\", function MatYearView_Template_tbody_keydown_4_listener($event) {\n            return ctx._handleCalendarBodyKeydown($event);\n          });\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(4);\n          i0.ɵɵproperty(\"label\", ctx._yearLabel())(\"rows\", ctx._months())(\"todayValue\", ctx._todayMonth())(\"startValue\", ctx._selectedMonth())(\"endValue\", ctx._selectedMonth())(\"labelMinRequiredCells\", 2)(\"numCols\", 4)(\"cellAspectRatio\", 4 / 7)(\"activeCell\", ctx._dateAdapter.getMonth(ctx.activeDate));\n        }\n      },\n      dependencies: [MatCalendarBody],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatYearView;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatCalendarHeader = /*#__PURE__*/(() => {\n  class MatCalendarHeader {\n    _intl = inject(MatDatepickerIntl);\n    calendar = inject(MatCalendar);\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dateFormats = inject(MAT_DATE_FORMATS, {\n      optional: true\n    });\n    _periodButtonText;\n    _periodButtonDescription;\n    _periodButtonLabel;\n    _prevButtonLabel;\n    _nextButtonLabel;\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n      const changeDetectorRef = inject(ChangeDetectorRef);\n      this._updateLabels();\n      this.calendar.stateChanges.subscribe(() => {\n        this._updateLabels();\n        changeDetectorRef.markForCheck();\n      });\n    }\n    get periodButtonText() {\n      return this._periodButtonText;\n    }\n    get periodButtonDescription() {\n      return this._periodButtonDescription;\n    }\n    get periodButtonLabel() {\n      return this._periodButtonLabel;\n    }\n    get prevButtonLabel() {\n      return this._prevButtonLabel;\n    }\n    get nextButtonLabel() {\n      return this._nextButtonLabel;\n    }\n    currentPeriodClicked() {\n      this.calendar.currentView = this.calendar.currentView == 'month' ? 'multi-year' : 'month';\n    }\n    previousClicked() {\n      if (this.previousEnabled()) {\n        this.calendar.activeDate = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, -1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? -1 : -yearsPerPage);\n      }\n    }\n    nextClicked() {\n      if (this.nextEnabled()) {\n        this.calendar.activeDate = this.calendar.currentView == 'month' ? this._dateAdapter.addCalendarMonths(this.calendar.activeDate, 1) : this._dateAdapter.addCalendarYears(this.calendar.activeDate, this.calendar.currentView == 'year' ? 1 : yearsPerPage);\n      }\n    }\n    previousEnabled() {\n      if (!this.calendar.minDate) {\n        return true;\n      }\n      return !this.calendar.minDate || !this._isSameView(this.calendar.activeDate, this.calendar.minDate);\n    }\n    nextEnabled() {\n      return !this.calendar.maxDate || !this._isSameView(this.calendar.activeDate, this.calendar.maxDate);\n    }\n    _updateLabels() {\n      const calendar = this.calendar;\n      const intl = this._intl;\n      const adapter = this._dateAdapter;\n      if (calendar.currentView === 'month') {\n        this._periodButtonText = adapter.format(calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase();\n        this._periodButtonDescription = adapter.format(calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase();\n        this._periodButtonLabel = intl.switchToMultiYearViewLabel;\n        this._prevButtonLabel = intl.prevMonthLabel;\n        this._nextButtonLabel = intl.nextMonthLabel;\n      } else if (calendar.currentView === 'year') {\n        this._periodButtonText = adapter.getYearName(calendar.activeDate);\n        this._periodButtonDescription = adapter.getYearName(calendar.activeDate);\n        this._periodButtonLabel = intl.switchToMonthViewLabel;\n        this._prevButtonLabel = intl.prevYearLabel;\n        this._nextButtonLabel = intl.nextYearLabel;\n      } else {\n        this._periodButtonText = intl.formatYearRange(...this._formatMinAndMaxYearLabels());\n        this._periodButtonDescription = intl.formatYearRangeLabel(...this._formatMinAndMaxYearLabels());\n        this._periodButtonLabel = intl.switchToMonthViewLabel;\n        this._prevButtonLabel = intl.prevMultiYearLabel;\n        this._nextButtonLabel = intl.nextMultiYearLabel;\n      }\n    }\n    _isSameView(date1, date2) {\n      if (this.calendar.currentView == 'month') {\n        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2) && this._dateAdapter.getMonth(date1) == this._dateAdapter.getMonth(date2);\n      }\n      if (this.calendar.currentView == 'year') {\n        return this._dateAdapter.getYear(date1) == this._dateAdapter.getYear(date2);\n      }\n      return isSameMultiYearView(this._dateAdapter, date1, date2, this.calendar.minDate, this.calendar.maxDate);\n    }\n    _formatMinAndMaxYearLabels() {\n      const activeYear = this._dateAdapter.getYear(this.calendar.activeDate);\n      const minYearOfPage = activeYear - getActiveOffset(this._dateAdapter, this.calendar.activeDate, this.calendar.minDate, this.calendar.maxDate);\n      const maxYearOfPage = minYearOfPage + yearsPerPage - 1;\n      const minYearLabel = this._dateAdapter.getYearName(this._dateAdapter.createDate(minYearOfPage, 0, 1));\n      const maxYearLabel = this._dateAdapter.getYearName(this._dateAdapter.createDate(maxYearOfPage, 0, 1));\n      return [minYearLabel, maxYearLabel];\n    }\n    _periodButtonLabelId = inject(_IdGenerator).getId('mat-calendar-period-label-');\n    static ɵfac = function MatCalendarHeader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatCalendarHeader)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatCalendarHeader,\n      selectors: [[\"mat-calendar-header\"]],\n      exportAs: [\"matCalendarHeader\"],\n      ngContentSelectors: _c1,\n      decls: 17,\n      vars: 13,\n      consts: [[1, \"mat-calendar-header\"], [1, \"mat-calendar-controls\"], [\"aria-live\", \"polite\", 1, \"cdk-visually-hidden\", 3, \"id\"], [\"matButton\", \"\", \"type\", \"button\", 1, \"mat-calendar-period-button\", 3, \"click\"], [\"aria-hidden\", \"true\"], [\"viewBox\", \"0 0 10 5\", \"focusable\", \"false\", \"aria-hidden\", \"true\", 1, \"mat-calendar-arrow\"], [\"points\", \"0,0 5,5 10,0\"], [1, \"mat-calendar-spacer\"], [\"matIconButton\", \"\", \"type\", \"button\", \"disabledInteractive\", \"\", 1, \"mat-calendar-previous-button\", 3, \"click\", \"disabled\", \"matTooltip\"], [\"viewBox\", \"0 0 24 24\", \"focusable\", \"false\", \"aria-hidden\", \"true\"], [\"d\", \"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\"], [\"matIconButton\", \"\", \"type\", \"button\", \"disabledInteractive\", \"\", 1, \"mat-calendar-next-button\", 3, \"click\", \"disabled\", \"matTooltip\"], [\"d\", \"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\"]],\n      template: function MatCalendarHeader_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1)(2, \"span\", 2);\n          i0.ɵɵtext(3);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(4, \"button\", 3);\n          i0.ɵɵlistener(\"click\", function MatCalendarHeader_Template_button_click_4_listener() {\n            return ctx.currentPeriodClicked();\n          });\n          i0.ɵɵelementStart(5, \"span\", 4);\n          i0.ɵɵtext(6);\n          i0.ɵɵelementEnd();\n          i0.ɵɵnamespaceSVG();\n          i0.ɵɵelementStart(7, \"svg\", 5);\n          i0.ɵɵelement(8, \"polygon\", 6);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵnamespaceHTML();\n          i0.ɵɵelement(9, \"div\", 7);\n          i0.ɵɵprojection(10);\n          i0.ɵɵelementStart(11, \"button\", 8);\n          i0.ɵɵlistener(\"click\", function MatCalendarHeader_Template_button_click_11_listener() {\n            return ctx.previousClicked();\n          });\n          i0.ɵɵnamespaceSVG();\n          i0.ɵɵelementStart(12, \"svg\", 9);\n          i0.ɵɵelement(13, \"path\", 10);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵnamespaceHTML();\n          i0.ɵɵelementStart(14, \"button\", 11);\n          i0.ɵɵlistener(\"click\", function MatCalendarHeader_Template_button_click_14_listener() {\n            return ctx.nextClicked();\n          });\n          i0.ɵɵnamespaceSVG();\n          i0.ɵɵelementStart(15, \"svg\", 9);\n          i0.ɵɵelement(16, \"path\", 12);\n          i0.ɵɵelementEnd()()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"id\", ctx._periodButtonLabelId);\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate(ctx.periodButtonDescription);\n          i0.ɵɵadvance();\n          i0.ɵɵattribute(\"aria-label\", ctx.periodButtonLabel)(\"aria-describedby\", ctx._periodButtonLabelId);\n          i0.ɵɵadvance(2);\n          i0.ɵɵtextInterpolate(ctx.periodButtonText);\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"mat-calendar-invert\", ctx.calendar.currentView !== \"month\");\n          i0.ɵɵadvance(4);\n          i0.ɵɵproperty(\"disabled\", !ctx.previousEnabled())(\"matTooltip\", ctx.prevButtonLabel);\n          i0.ɵɵattribute(\"aria-label\", ctx.prevButtonLabel);\n          i0.ɵɵadvance(3);\n          i0.ɵɵproperty(\"disabled\", !ctx.nextEnabled())(\"matTooltip\", ctx.nextButtonLabel);\n          i0.ɵɵattribute(\"aria-label\", ctx.nextButtonLabel);\n        }\n      },\n      dependencies: [MatButton, MatIconButton, MatTooltip],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatCalendarHeader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatCalendar = /*#__PURE__*/(() => {\n  class MatCalendar {\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dateFormats = inject(MAT_DATE_FORMATS, {\n      optional: true\n    });\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    headerComponent;\n    _calendarHeaderPortal;\n    _intlChanges;\n    _moveFocusOnNextTick = false;\n    get startAt() {\n      return this._startAt;\n    }\n    set startAt(value) {\n      this._startAt = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _startAt;\n    startView = 'month';\n    get selected() {\n      return this._selected;\n    }\n    set selected(value) {\n      if (value instanceof DateRange) {\n        this._selected = value;\n      } else {\n        this._selected = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      }\n    }\n    _selected;\n    get minDate() {\n      return this._minDate;\n    }\n    set minDate(value) {\n      this._minDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _minDate;\n    get maxDate() {\n      return this._maxDate;\n    }\n    set maxDate(value) {\n      this._maxDate = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _maxDate;\n    dateFilter;\n    dateClass;\n    comparisonStart;\n    comparisonEnd;\n    startDateAccessibleName;\n    endDateAccessibleName;\n    selectedChange = new EventEmitter();\n    yearSelected = new EventEmitter();\n    monthSelected = new EventEmitter();\n    viewChanged = new EventEmitter(true);\n    _userSelection = new EventEmitter();\n    _userDragDrop = new EventEmitter();\n    monthView;\n    yearView;\n    multiYearView;\n    get activeDate() {\n      return this._clampedActiveDate;\n    }\n    set activeDate(value) {\n      this._clampedActiveDate = this._dateAdapter.clampDate(value, this.minDate, this.maxDate);\n      this.stateChanges.next();\n      this._changeDetectorRef.markForCheck();\n    }\n    _clampedActiveDate;\n    get currentView() {\n      return this._currentView;\n    }\n    set currentView(value) {\n      const viewChangedResult = this._currentView !== value ? value : null;\n      this._currentView = value;\n      this._moveFocusOnNextTick = true;\n      this._changeDetectorRef.markForCheck();\n      if (viewChangedResult) {\n        this.stateChanges.next();\n        this.viewChanged.emit(viewChangedResult);\n      }\n    }\n    _currentView;\n    _activeDrag = null;\n    stateChanges = new Subject();\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n      this._intlChanges = inject(MatDatepickerIntl).changes.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n      });\n    }\n    ngAfterContentInit() {\n      this._calendarHeaderPortal = new ComponentPortal(this.headerComponent || MatCalendarHeader);\n      this.activeDate = this.startAt || this._dateAdapter.today();\n      this._currentView = this.startView;\n    }\n    ngAfterViewChecked() {\n      if (this._moveFocusOnNextTick) {\n        this._moveFocusOnNextTick = false;\n        this.focusActiveCell();\n      }\n    }\n    ngOnDestroy() {\n      this._intlChanges.unsubscribe();\n      this.stateChanges.complete();\n    }\n    ngOnChanges(changes) {\n      const minDateChange = changes['minDate'] && !this._dateAdapter.sameDate(changes['minDate'].previousValue, changes['minDate'].currentValue) ? changes['minDate'] : undefined;\n      const maxDateChange = changes['maxDate'] && !this._dateAdapter.sameDate(changes['maxDate'].previousValue, changes['maxDate'].currentValue) ? changes['maxDate'] : undefined;\n      const changeRequiringRerender = minDateChange || maxDateChange || changes['dateFilter'];\n      if (changeRequiringRerender && !changeRequiringRerender.firstChange) {\n        const view = this._getCurrentViewComponent();\n        if (view) {\n          if (this._elementRef.nativeElement.contains(_getFocusedElementPierceShadowDom())) {\n            this._moveFocusOnNextTick = true;\n          }\n          this._changeDetectorRef.detectChanges();\n          view._init();\n        }\n      }\n      this.stateChanges.next();\n    }\n    focusActiveCell() {\n      this._getCurrentViewComponent()._focusActiveCell(false);\n    }\n    updateTodaysDate() {\n      this._getCurrentViewComponent()._init();\n    }\n    _dateSelected(event) {\n      const date = event.value;\n      if (this.selected instanceof DateRange || date && !this._dateAdapter.sameDate(date, this.selected)) {\n        this.selectedChange.emit(date);\n      }\n      this._userSelection.emit(event);\n    }\n    _yearSelectedInMultiYearView(normalizedYear) {\n      this.yearSelected.emit(normalizedYear);\n    }\n    _monthSelectedInYearView(normalizedMonth) {\n      this.monthSelected.emit(normalizedMonth);\n    }\n    _goToDateInView(date, view) {\n      this.activeDate = date;\n      this.currentView = view;\n    }\n    _dragStarted(event) {\n      this._activeDrag = event;\n    }\n    _dragEnded(event) {\n      if (!this._activeDrag) return;\n      if (event.value) {\n        this._userDragDrop.emit(event);\n      }\n      this._activeDrag = null;\n    }\n    _getCurrentViewComponent() {\n      return this.monthView || this.yearView || this.multiYearView;\n    }\n    static ɵfac = function MatCalendar_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatCalendar)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatCalendar,\n      selectors: [[\"mat-calendar\"]],\n      viewQuery: function MatCalendar_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatMonthView, 5)(MatYearView, 5)(MatMultiYearView, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthView = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearView = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.multiYearView = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-calendar\"],\n      inputs: {\n        headerComponent: \"headerComponent\",\n        startAt: \"startAt\",\n        startView: \"startView\",\n        selected: \"selected\",\n        minDate: \"minDate\",\n        maxDate: \"maxDate\",\n        dateFilter: \"dateFilter\",\n        dateClass: \"dateClass\",\n        comparisonStart: \"comparisonStart\",\n        comparisonEnd: \"comparisonEnd\",\n        startDateAccessibleName: \"startDateAccessibleName\",\n        endDateAccessibleName: \"endDateAccessibleName\"\n      },\n      outputs: {\n        selectedChange: \"selectedChange\",\n        yearSelected: \"yearSelected\",\n        monthSelected: \"monthSelected\",\n        viewChanged: \"viewChanged\",\n        _userSelection: \"_userSelection\",\n        _userDragDrop: \"_userDragDrop\"\n      },\n      exportAs: [\"matCalendar\"],\n      features: [i0.ɵɵProvidersFeature([MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER]), i0.ɵɵNgOnChangesFeature],\n      decls: 5,\n      vars: 2,\n      consts: [[3, \"cdkPortalOutlet\"], [\"cdkMonitorSubtreeFocus\", \"\", \"tabindex\", \"-1\", 1, \"mat-calendar-content\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"comparisonStart\", \"comparisonEnd\", \"startDateAccessibleName\", \"endDateAccessibleName\", \"activeDrag\"], [3, \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\"], [3, \"activeDateChange\", \"_userSelection\", \"dragStarted\", \"dragEnded\", \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\", \"comparisonStart\", \"comparisonEnd\", \"startDateAccessibleName\", \"endDateAccessibleName\", \"activeDrag\"], [3, \"activeDateChange\", \"monthSelected\", \"selectedChange\", \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\"], [3, \"activeDateChange\", \"yearSelected\", \"selectedChange\", \"activeDate\", \"selected\", \"dateFilter\", \"maxDate\", \"minDate\", \"dateClass\"]],\n      template: function MatCalendar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, MatCalendar_ng_template_0_Template, 0, 0, \"ng-template\", 0);\n          i0.ɵɵelementStart(1, \"div\", 1);\n          i0.ɵɵconditionalCreate(2, MatCalendar_Case_2_Template, 1, 11, \"mat-month-view\", 2)(3, MatCalendar_Case_3_Template, 1, 6, \"mat-year-view\", 3)(4, MatCalendar_Case_4_Template, 1, 6, \"mat-multi-year-view\", 3);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          let tmp_1_0;\n          i0.ɵɵproperty(\"cdkPortalOutlet\", ctx._calendarHeaderPortal);\n          i0.ɵɵadvance(2);\n          i0.ɵɵconditional((tmp_1_0 = ctx.currentView) === \"month\" ? 2 : tmp_1_0 === \"year\" ? 3 : tmp_1_0 === \"multi-year\" ? 4 : -1);\n        }\n      },\n      dependencies: [CdkPortalOutlet, CdkMonitorFocus, MatMonthView, MatYearView, MatMultiYearView],\n      styles: [\".mat-calendar{display:block;line-height:normal;font-family:var(--mat-datepicker-calendar-text-font, var(--mat-sys-body-medium-font));font-size:var(--mat-datepicker-calendar-text-size, var(--mat-sys-body-medium-size))}.mat-calendar-header{padding:8px 8px 0 8px}.mat-calendar-content{padding:0 8px 8px 8px;outline:none}.mat-calendar-controls{display:flex;align-items:center;margin:5% calc(4.7142857143% - 16px)}.mat-calendar-spacer{flex:1 1 auto}.mat-calendar-period-button{min-width:0;margin:0 8px;font-size:var(--mat-datepicker-calendar-period-button-text-size, var(--mat-sys-title-small-size));font-weight:var(--mat-datepicker-calendar-period-button-text-weight, var(--mat-sys-title-small-weight));--mat-button-text-label-text-color: var(--mat-datepicker-calendar-period-button-text-color, var(--mat-sys-on-surface-variant))}.mat-calendar-arrow{display:inline-block;width:10px;height:5px;margin:0 0 0 5px;vertical-align:middle;fill:var(--mat-datepicker-calendar-period-button-icon-color, var(--mat-sys-on-surface-variant))}.mat-calendar-arrow.mat-calendar-invert{transform:rotate(180deg)}[dir=rtl] .mat-calendar-arrow{margin:0 5px 0 0}@media(forced-colors: active){.mat-calendar-arrow{fill:CanvasText}}.mat-datepicker-content .mat-calendar-previous-button:not(.mat-mdc-button-disabled),.mat-datepicker-content .mat-calendar-next-button:not(.mat-mdc-button-disabled){color:var(--mat-datepicker-calendar-navigation-button-icon-color, var(--mat-sys-on-surface-variant))}[dir=rtl] .mat-calendar-previous-button,[dir=rtl] .mat-calendar-next-button{transform:rotate(180deg)}.mat-calendar-table{border-spacing:0;border-collapse:collapse;width:100%}.mat-calendar-table-header th{text-align:center;padding:0 0 8px 0;color:var(--mat-datepicker-calendar-header-text-color, var(--mat-sys-on-surface-variant));font-size:var(--mat-datepicker-calendar-header-text-size, var(--mat-sys-title-small-size));font-weight:var(--mat-datepicker-calendar-header-text-weight, var(--mat-sys-title-small-weight))}.mat-calendar-table-header-divider{position:relative;height:1px}.mat-calendar-table-header-divider::after{content:\\\"\\\";position:absolute;top:0;left:-8px;right:-8px;height:1px;background:var(--mat-datepicker-calendar-header-divider-color, transparent)}.mat-calendar-body-cell-content::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 3px)*-1)}.mat-calendar-body-cell:focus .mat-focus-indicator::before{content:\\\"\\\"}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatCalendar;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MAT_DATEPICKER_SCROLL_STRATEGY = /*#__PURE__*/new InjectionToken('mat-datepicker-scroll-strategy', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(Injector);\n    return () => createRepositionScrollStrategy(injector);\n  }\n});\nlet MatDatepickerContent = /*#__PURE__*/(() => {\n  class MatDatepickerContent {\n    _elementRef = inject(ElementRef);\n    _animationsDisabled = _animationsDisabled();\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _globalModel = inject(MatDateSelectionModel);\n    _dateAdapter = inject(DateAdapter);\n    _ngZone = inject(NgZone);\n    _rangeSelectionStrategy = inject(MAT_DATE_RANGE_SELECTION_STRATEGY, {\n      optional: true\n    });\n    _stateChanges;\n    _model;\n    _eventCleanups;\n    _animationFallback;\n    _calendar;\n    color;\n    datepicker;\n    comparisonStart;\n    comparisonEnd;\n    startDateAccessibleName;\n    endDateAccessibleName;\n    _isAbove;\n    _animationDone = new Subject();\n    _isAnimating = false;\n    _closeButtonText;\n    _closeButtonFocused;\n    _actionsPortal = null;\n    _dialogLabelId;\n    constructor() {\n      inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);\n      this._closeButtonText = inject(MatDatepickerIntl).closeCalendarLabel;\n      if (!this._animationsDisabled) {\n        const element = this._elementRef.nativeElement;\n        const renderer = inject(Renderer2);\n        this._eventCleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(element, 'animationstart', this._handleAnimationEvent), renderer.listen(element, 'animationend', this._handleAnimationEvent), renderer.listen(element, 'animationcancel', this._handleAnimationEvent)]);\n      }\n    }\n    ngAfterViewInit() {\n      this._stateChanges = this.datepicker.stateChanges.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n      });\n      this._calendar.focusActiveCell();\n    }\n    ngOnDestroy() {\n      clearTimeout(this._animationFallback);\n      this._eventCleanups?.forEach(cleanup => cleanup());\n      this._stateChanges?.unsubscribe();\n      this._animationDone.complete();\n    }\n    _handleUserSelection(event) {\n      const selection = this._model.selection;\n      const value = event.value;\n      const isRange = selection instanceof DateRange;\n      if (isRange && this._rangeSelectionStrategy) {\n        const newSelection = this._rangeSelectionStrategy.selectionFinished(value, selection, event.event);\n        this._model.updateSelection(newSelection, this);\n      } else if (value && (isRange || !this._dateAdapter.sameDate(value, selection))) {\n        this._model.add(value);\n      }\n      if ((!this._model || this._model.isComplete()) && !this._actionsPortal) {\n        this.datepicker.close();\n      }\n    }\n    _handleUserDragDrop(event) {\n      this._model.updateSelection(event.value, this);\n    }\n    _startExitAnimation() {\n      this._elementRef.nativeElement.classList.add('mat-datepicker-content-exit');\n      if (this._animationsDisabled) {\n        this._animationDone.next();\n      } else {\n        clearTimeout(this._animationFallback);\n        this._animationFallback = setTimeout(() => {\n          if (!this._isAnimating) {\n            this._animationDone.next();\n          }\n        }, 200);\n      }\n    }\n    _handleAnimationEvent = event => {\n      const element = this._elementRef.nativeElement;\n      if (event.target !== element || !event.animationName.startsWith('_mat-datepicker-content')) {\n        return;\n      }\n      clearTimeout(this._animationFallback);\n      this._isAnimating = event.type === 'animationstart';\n      element.classList.toggle('mat-datepicker-content-animating', this._isAnimating);\n      if (!this._isAnimating) {\n        this._animationDone.next();\n      }\n    };\n    _getSelected() {\n      return this._model.selection;\n    }\n    _applyPendingSelection() {\n      if (this._model !== this._globalModel) {\n        this._globalModel.updateSelection(this._model.selection, this);\n      }\n    }\n    _assignActions(portal, forceRerender) {\n      this._model = portal ? this._globalModel.clone() : this._globalModel;\n      this._actionsPortal = portal;\n      if (forceRerender) {\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    static ɵfac = function MatDatepickerContent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerContent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDatepickerContent,\n      selectors: [[\"mat-datepicker-content\"]],\n      viewQuery: function MatDatepickerContent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(MatCalendar, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._calendar = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-datepicker-content\"],\n      hostVars: 6,\n      hostBindings: function MatDatepickerContent_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassMap(ctx.color ? \"mat-\" + ctx.color : \"\");\n          i0.ɵɵclassProp(\"mat-datepicker-content-touch\", ctx.datepicker.touchUi)(\"mat-datepicker-content-animations-enabled\", !ctx._animationsDisabled);\n        }\n      },\n      inputs: {\n        color: \"color\"\n      },\n      exportAs: [\"matDatepickerContent\"],\n      decls: 5,\n      vars: 26,\n      consts: [[\"cdkTrapFocus\", \"\", \"role\", \"dialog\", 1, \"mat-datepicker-content-container\"], [3, \"yearSelected\", \"monthSelected\", \"viewChanged\", \"_userSelection\", \"_userDragDrop\", \"id\", \"startAt\", \"startView\", \"minDate\", \"maxDate\", \"dateFilter\", \"headerComponent\", \"selected\", \"dateClass\", \"comparisonStart\", \"comparisonEnd\", \"startDateAccessibleName\", \"endDateAccessibleName\"], [3, \"cdkPortalOutlet\"], [\"type\", \"button\", \"matButton\", \"elevated\", 1, \"mat-datepicker-close-button\", 3, \"focus\", \"blur\", \"click\", \"color\"]],\n      template: function MatDatepickerContent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"mat-calendar\", 1);\n          i0.ɵɵlistener(\"yearSelected\", function MatDatepickerContent_Template_mat_calendar_yearSelected_1_listener($event) {\n            return ctx.datepicker._selectYear($event);\n          })(\"monthSelected\", function MatDatepickerContent_Template_mat_calendar_monthSelected_1_listener($event) {\n            return ctx.datepicker._selectMonth($event);\n          })(\"viewChanged\", function MatDatepickerContent_Template_mat_calendar_viewChanged_1_listener($event) {\n            return ctx.datepicker._viewChanged($event);\n          })(\"_userSelection\", function MatDatepickerContent_Template_mat_calendar__userSelection_1_listener($event) {\n            return ctx._handleUserSelection($event);\n          })(\"_userDragDrop\", function MatDatepickerContent_Template_mat_calendar__userDragDrop_1_listener($event) {\n            return ctx._handleUserDragDrop($event);\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(2, MatDatepickerContent_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n          i0.ɵɵelementStart(3, \"button\", 3);\n          i0.ɵɵlistener(\"focus\", function MatDatepickerContent_Template_button_focus_3_listener() {\n            return ctx._closeButtonFocused = true;\n          })(\"blur\", function MatDatepickerContent_Template_button_blur_3_listener() {\n            return ctx._closeButtonFocused = false;\n          })(\"click\", function MatDatepickerContent_Template_button_click_3_listener() {\n            return ctx.datepicker.close();\n          });\n          i0.ɵɵtext(4);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"mat-datepicker-content-container-with-custom-header\", ctx.datepicker.calendarHeaderComponent)(\"mat-datepicker-content-container-with-actions\", ctx._actionsPortal);\n          i0.ɵɵattribute(\"aria-modal\", true)(\"aria-labelledby\", ctx._dialogLabelId ?? undefined);\n          i0.ɵɵadvance();\n          i0.ɵɵclassMap(ctx.datepicker.panelClass);\n          i0.ɵɵproperty(\"id\", ctx.datepicker.id)(\"startAt\", ctx.datepicker.startAt)(\"startView\", ctx.datepicker.startView)(\"minDate\", ctx.datepicker._getMinDate())(\"maxDate\", ctx.datepicker._getMaxDate())(\"dateFilter\", ctx.datepicker._getDateFilter())(\"headerComponent\", ctx.datepicker.calendarHeaderComponent)(\"selected\", ctx._getSelected())(\"dateClass\", ctx.datepicker.dateClass)(\"comparisonStart\", ctx.comparisonStart)(\"comparisonEnd\", ctx.comparisonEnd)(\"startDateAccessibleName\", ctx.startDateAccessibleName)(\"endDateAccessibleName\", ctx.endDateAccessibleName);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"cdkPortalOutlet\", ctx._actionsPortal);\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"cdk-visually-hidden\", !ctx._closeButtonFocused);\n          i0.ɵɵproperty(\"color\", ctx.color || \"primary\");\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate(ctx._closeButtonText);\n        }\n      },\n      dependencies: [CdkTrapFocus, MatCalendar, CdkPortalOutlet, MatButton],\n      styles: [\"@keyframes _mat-datepicker-content-dropdown-enter{from{opacity:0;transform:scaleY(0.8)}to{opacity:1;transform:none}}@keyframes _mat-datepicker-content-dialog-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-datepicker-content-exit{from{opacity:1}to{opacity:0}}.mat-datepicker-content{display:block;background-color:var(--mat-datepicker-calendar-container-background-color, var(--mat-sys-surface-container-high));color:var(--mat-datepicker-calendar-container-text-color, var(--mat-sys-on-surface));box-shadow:var(--mat-datepicker-calendar-container-elevation-shadow, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12));border-radius:var(--mat-datepicker-calendar-container-shape, var(--mat-sys-corner-large))}.mat-datepicker-content.mat-datepicker-content-animations-enabled{animation:_mat-datepicker-content-dropdown-enter 120ms cubic-bezier(0, 0, 0.2, 1)}.mat-datepicker-content .mat-calendar{width:296px;height:354px}.mat-datepicker-content .mat-datepicker-content-container-with-custom-header .mat-calendar{height:auto}.mat-datepicker-content .mat-datepicker-close-button{position:absolute;top:100%;left:0;margin-top:8px}.mat-datepicker-content-animating .mat-datepicker-content .mat-datepicker-close-button{display:none}.mat-datepicker-content-container{display:flex;flex-direction:column;justify-content:space-between}.mat-datepicker-content-touch{display:block;max-height:80vh;box-shadow:var(--mat-datepicker-calendar-container-touch-elevation-shadow, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12));border-radius:var(--mat-datepicker-calendar-container-touch-shape, var(--mat-sys-corner-extra-large));position:relative;overflow:visible}.mat-datepicker-content-touch.mat-datepicker-content-animations-enabled{animation:_mat-datepicker-content-dialog-enter 150ms cubic-bezier(0, 0, 0.2, 1)}.mat-datepicker-content-touch .mat-datepicker-content-container{min-height:312px;max-height:788px;min-width:250px;max-width:750px}.mat-datepicker-content-touch .mat-calendar{width:100%;height:auto}.mat-datepicker-content-exit.mat-datepicker-content-animations-enabled{animation:_mat-datepicker-content-exit 100ms linear}@media all and (orientation: landscape){.mat-datepicker-content-touch .mat-datepicker-content-container{width:64vh;height:80vh}}@media all and (orientation: portrait){.mat-datepicker-content-touch .mat-datepicker-content-container{width:80vw;height:100vw}.mat-datepicker-content-touch .mat-datepicker-content-container-with-actions{height:115vw}}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDatepickerContent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerBase = /*#__PURE__*/(() => {\n  class MatDatepickerBase {\n    _injector = inject(Injector);\n    _viewContainerRef = inject(ViewContainerRef);\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _model = inject(MatDateSelectionModel);\n    _animationsDisabled = _animationsDisabled();\n    _scrollStrategy = inject(MAT_DATEPICKER_SCROLL_STRATEGY);\n    _inputStateChanges = Subscription.EMPTY;\n    _document = inject(DOCUMENT);\n    calendarHeaderComponent;\n    get startAt() {\n      return this._startAt || (this.datepickerInput ? this.datepickerInput.getStartValue() : null);\n    }\n    set startAt(value) {\n      this._startAt = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n    }\n    _startAt;\n    startView = 'month';\n    get color() {\n      return this._color || (this.datepickerInput ? this.datepickerInput.getThemePalette() : undefined);\n    }\n    set color(value) {\n      this._color = value;\n    }\n    _color;\n    touchUi = false;\n    get disabled() {\n      return this._disabled === undefined && this.datepickerInput ? this.datepickerInput.disabled : !!this._disabled;\n    }\n    set disabled(value) {\n      if (value !== this._disabled) {\n        this._disabled = value;\n        this.stateChanges.next(undefined);\n      }\n    }\n    _disabled;\n    xPosition = 'start';\n    yPosition = 'below';\n    restoreFocus = true;\n    yearSelected = new EventEmitter();\n    monthSelected = new EventEmitter();\n    viewChanged = new EventEmitter(true);\n    dateClass;\n    openedStream = new EventEmitter();\n    closedStream = new EventEmitter();\n    get panelClass() {\n      return this._panelClass;\n    }\n    set panelClass(value) {\n      this._panelClass = coerceStringArray(value);\n    }\n    _panelClass;\n    get opened() {\n      return this._opened;\n    }\n    set opened(value) {\n      if (value) {\n        this.open();\n      } else {\n        this.close();\n      }\n    }\n    _opened = false;\n    id = inject(_IdGenerator).getId('mat-datepicker-');\n    _getMinDate() {\n      return this.datepickerInput && this.datepickerInput.min;\n    }\n    _getMaxDate() {\n      return this.datepickerInput && this.datepickerInput.max;\n    }\n    _getDateFilter() {\n      return this.datepickerInput && this.datepickerInput.dateFilter;\n    }\n    _overlayRef;\n    _componentRef;\n    _focusedElementBeforeOpen = null;\n    _backdropHarnessClass = `${this.id}-backdrop`;\n    _actionsPortal;\n    datepickerInput;\n    stateChanges = new Subject();\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    constructor() {\n      if (!this._dateAdapter && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n      this._model.selectionChanged.subscribe(() => {\n        this._changeDetectorRef.markForCheck();\n      });\n    }\n    ngOnChanges(changes) {\n      const positionChange = changes['xPosition'] || changes['yPosition'];\n      if (positionChange && !positionChange.firstChange && this._overlayRef) {\n        const positionStrategy = this._overlayRef.getConfig().positionStrategy;\n        if (positionStrategy instanceof FlexibleConnectedPositionStrategy) {\n          this._setConnectedPositions(positionStrategy);\n          if (this.opened) {\n            this._overlayRef.updatePosition();\n          }\n        }\n      }\n      this.stateChanges.next(undefined);\n    }\n    ngOnDestroy() {\n      this._destroyOverlay();\n      this.close();\n      this._inputStateChanges.unsubscribe();\n      this.stateChanges.complete();\n    }\n    select(date) {\n      this._model.add(date);\n    }\n    _selectYear(normalizedYear) {\n      this.yearSelected.emit(normalizedYear);\n    }\n    _selectMonth(normalizedMonth) {\n      this.monthSelected.emit(normalizedMonth);\n    }\n    _viewChanged(view) {\n      this.viewChanged.emit(view);\n    }\n    registerInput(input) {\n      if (this.datepickerInput && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('A MatDatepicker can only be associated with a single input.');\n      }\n      this._inputStateChanges.unsubscribe();\n      this.datepickerInput = input;\n      this._inputStateChanges = input.stateChanges.subscribe(() => this.stateChanges.next(undefined));\n      return this._model;\n    }\n    registerActions(portal) {\n      if (this._actionsPortal && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('A MatDatepicker can only be associated with a single actions row.');\n      }\n      this._actionsPortal = portal;\n      this._componentRef?.instance._assignActions(portal, true);\n    }\n    removeActions(portal) {\n      if (portal === this._actionsPortal) {\n        this._actionsPortal = null;\n        this._componentRef?.instance._assignActions(null, true);\n      }\n    }\n    open() {\n      if (this._opened || this.disabled || this._componentRef?.instance._isAnimating) {\n        return;\n      }\n      if (!this.datepickerInput && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw Error('Attempted to open an MatDatepicker with no associated input.');\n      }\n      this._focusedElementBeforeOpen = _getFocusedElementPierceShadowDom();\n      this._openOverlay();\n      this._opened = true;\n      this.openedStream.emit();\n    }\n    close() {\n      if (!this._opened || this._componentRef?.instance._isAnimating) {\n        return;\n      }\n      const canRestoreFocus = this.restoreFocus && this._focusedElementBeforeOpen && typeof this._focusedElementBeforeOpen.focus === 'function';\n      const completeClose = () => {\n        if (this._opened) {\n          this._opened = false;\n          this.closedStream.emit();\n        }\n      };\n      if (this._componentRef) {\n        const {\n          instance,\n          location\n        } = this._componentRef;\n        instance._animationDone.pipe(take(1)).subscribe(() => {\n          const activeElement = this._document.activeElement;\n          if (canRestoreFocus && (!activeElement || activeElement === this._document.activeElement || location.nativeElement.contains(activeElement))) {\n            this._focusedElementBeforeOpen.focus();\n          }\n          this._focusedElementBeforeOpen = null;\n          this._destroyOverlay();\n        });\n        instance._startExitAnimation();\n      }\n      if (canRestoreFocus) {\n        setTimeout(completeClose);\n      } else {\n        completeClose();\n      }\n    }\n    _applyPendingSelection() {\n      this._componentRef?.instance?._applyPendingSelection();\n    }\n    _forwardContentValues(instance) {\n      instance.datepicker = this;\n      instance.color = this.color;\n      instance._dialogLabelId = this.datepickerInput.getOverlayLabelId();\n      instance._assignActions(this._actionsPortal, false);\n    }\n    _openOverlay() {\n      this._destroyOverlay();\n      const isDialog = this.touchUi;\n      const portal = new ComponentPortal(MatDatepickerContent, this._viewContainerRef);\n      const overlayRef = this._overlayRef = createOverlayRef(this._injector, new OverlayConfig({\n        positionStrategy: isDialog ? this._getDialogStrategy() : this._getDropdownStrategy(),\n        hasBackdrop: true,\n        backdropClass: [isDialog ? 'cdk-overlay-dark-backdrop' : 'mat-overlay-transparent-backdrop', this._backdropHarnessClass],\n        direction: this._dir || 'ltr',\n        scrollStrategy: isDialog ? createBlockScrollStrategy(this._injector) : this._scrollStrategy(),\n        panelClass: `mat-datepicker-${isDialog ? 'dialog' : 'popup'}`,\n        disableAnimations: this._animationsDisabled\n      }));\n      this._getCloseStream(overlayRef).subscribe(event => {\n        if (event) {\n          event.preventDefault();\n        }\n        this.close();\n      });\n      overlayRef.keydownEvents().subscribe(event => {\n        const keyCode = event.keyCode;\n        if (keyCode === UP_ARROW || keyCode === DOWN_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW || keyCode === PAGE_UP || keyCode === PAGE_DOWN) {\n          event.preventDefault();\n        }\n      });\n      this._componentRef = overlayRef.attach(portal);\n      this._forwardContentValues(this._componentRef.instance);\n      if (!isDialog) {\n        afterNextRender(() => {\n          overlayRef.updatePosition();\n        }, {\n          injector: this._injector\n        });\n      }\n    }\n    _destroyOverlay() {\n      if (this._overlayRef) {\n        this._overlayRef.dispose();\n        this._overlayRef = this._componentRef = null;\n      }\n    }\n    _getDialogStrategy() {\n      return createGlobalPositionStrategy(this._injector).centerHorizontally().centerVertically();\n    }\n    _getDropdownStrategy() {\n      const strategy = createFlexibleConnectedPositionStrategy(this._injector, this.datepickerInput.getConnectedOverlayOrigin()).withTransformOriginOn('.mat-datepicker-content').withFlexibleDimensions(false).withViewportMargin(8).withLockedPosition();\n      return this._setConnectedPositions(strategy);\n    }\n    _setConnectedPositions(strategy) {\n      const primaryX = this.xPosition === 'end' ? 'end' : 'start';\n      const secondaryX = primaryX === 'start' ? 'end' : 'start';\n      const primaryY = this.yPosition === 'above' ? 'bottom' : 'top';\n      const secondaryY = primaryY === 'top' ? 'bottom' : 'top';\n      return strategy.withPositions([{\n        originX: primaryX,\n        originY: secondaryY,\n        overlayX: primaryX,\n        overlayY: primaryY\n      }, {\n        originX: primaryX,\n        originY: primaryY,\n        overlayX: primaryX,\n        overlayY: secondaryY\n      }, {\n        originX: secondaryX,\n        originY: secondaryY,\n        overlayX: secondaryX,\n        overlayY: primaryY\n      }, {\n        originX: secondaryX,\n        originY: primaryY,\n        overlayX: secondaryX,\n        overlayY: secondaryY\n      }]);\n    }\n    _getCloseStream(overlayRef) {\n      const ctrlShiftMetaModifiers = ['ctrlKey', 'shiftKey', 'metaKey'];\n      return merge(overlayRef.backdropClick(), overlayRef.detachments(), overlayRef.keydownEvents().pipe(filter(event => {\n        return event.keyCode === ESCAPE && !hasModifierKey(event) || this.datepickerInput && hasModifierKey(event, 'altKey') && event.keyCode === UP_ARROW && ctrlShiftMetaModifiers.every(modifier => !hasModifierKey(event, modifier));\n      })));\n    }\n    static ɵfac = function MatDatepickerBase_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerBase)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDatepickerBase,\n      inputs: {\n        calendarHeaderComponent: \"calendarHeaderComponent\",\n        startAt: \"startAt\",\n        startView: \"startView\",\n        color: \"color\",\n        touchUi: [2, \"touchUi\", \"touchUi\", booleanAttribute],\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        xPosition: \"xPosition\",\n        yPosition: \"yPosition\",\n        restoreFocus: [2, \"restoreFocus\", \"restoreFocus\", booleanAttribute],\n        dateClass: \"dateClass\",\n        panelClass: \"panelClass\",\n        opened: [2, \"opened\", \"opened\", booleanAttribute]\n      },\n      outputs: {\n        yearSelected: \"yearSelected\",\n        monthSelected: \"monthSelected\",\n        viewChanged: \"viewChanged\",\n        openedStream: \"opened\",\n        closedStream: \"closed\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return MatDatepickerBase;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepicker = /*#__PURE__*/(() => {\n  class MatDatepicker extends MatDatepickerBase {\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatDatepicker_BaseFactory;\n      return function MatDatepicker_Factory(__ngFactoryType__) {\n        return (ɵMatDatepicker_BaseFactory || (ɵMatDatepicker_BaseFactory = i0.ɵɵgetInheritedFactory(MatDatepicker)))(__ngFactoryType__ || MatDatepicker);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDatepicker,\n      selectors: [[\"mat-datepicker\"]],\n      exportAs: [\"matDatepicker\"],\n      features: [i0.ɵɵProvidersFeature([MAT_SINGLE_DATE_SELECTION_MODEL_PROVIDER, {\n        provide: MatDatepickerBase,\n        useExisting: MatDatepicker\n      }]), i0.ɵɵInheritDefinitionFeature],\n      decls: 0,\n      vars: 0,\n      template: function MatDatepicker_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDatepicker;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass MatDatepickerInputEvent {\n  target;\n  targetElement;\n  value;\n  constructor(target, targetElement) {\n    this.target = target;\n    this.targetElement = targetElement;\n    this.value = this.target.value;\n  }\n}\nlet MatDatepickerInputBase = /*#__PURE__*/(() => {\n  class MatDatepickerInputBase {\n    _elementRef = inject(ElementRef);\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _dateFormats = inject(MAT_DATE_FORMATS, {\n      optional: true\n    });\n    _isInitialized;\n    get value() {\n      return this._model ? this._getValueFromModel(this._model.selection) : this._pendingValue;\n    }\n    set value(value) {\n      this._assignValueProgrammatically(value, true);\n    }\n    _model;\n    get disabled() {\n      return !!this._disabled || this._parentDisabled();\n    }\n    set disabled(value) {\n      const newValue = value;\n      const element = this._elementRef.nativeElement;\n      if (this._disabled !== newValue) {\n        this._disabled = newValue;\n        this.stateChanges.next(undefined);\n      }\n      if (newValue && this._isInitialized && element.blur) {\n        element.blur();\n      }\n    }\n    _disabled;\n    dateChange = new EventEmitter();\n    dateInput = new EventEmitter();\n    stateChanges = new Subject();\n    _onTouched = () => {};\n    _validatorOnChange = () => {};\n    _cvaOnChange = () => {};\n    _valueChangesSubscription = Subscription.EMPTY;\n    _localeSubscription = Subscription.EMPTY;\n    _pendingValue;\n    _parseValidator = () => {\n      return this._lastValueValid ? null : {\n        'matDatepickerParse': {\n          'text': this._elementRef.nativeElement.value\n        }\n      };\n    };\n    _filterValidator = control => {\n      const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n      return !controlValue || this._matchesFilter(controlValue) ? null : {\n        'matDatepickerFilter': true\n      };\n    };\n    _minValidator = control => {\n      const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n      const min = this._getMinDate();\n      return !min || !controlValue || this._dateAdapter.compareDate(min, controlValue) <= 0 ? null : {\n        'matDatepickerMin': {\n          'min': min,\n          'actual': controlValue\n        }\n      };\n    };\n    _maxValidator = control => {\n      const controlValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n      const max = this._getMaxDate();\n      return !max || !controlValue || this._dateAdapter.compareDate(max, controlValue) >= 0 ? null : {\n        'matDatepickerMax': {\n          'max': max,\n          'actual': controlValue\n        }\n      };\n    };\n    _getValidators() {\n      return [this._parseValidator, this._minValidator, this._maxValidator, this._filterValidator];\n    }\n    _registerModel(model) {\n      this._model = model;\n      this._valueChangesSubscription.unsubscribe();\n      if (this._pendingValue) {\n        this._assignValue(this._pendingValue);\n      }\n      this._valueChangesSubscription = this._model.selectionChanged.subscribe(event => {\n        if (this._shouldHandleChangeEvent(event)) {\n          const value = this._getValueFromModel(event.selection);\n          this._lastValueValid = this._isValidValue(value);\n          this._cvaOnChange(value);\n          this._onTouched();\n          this._formatValue(value);\n          this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n          this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n        }\n      });\n    }\n    _lastValueValid = false;\n    constructor() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!this._dateAdapter) {\n          throw createMissingDateImplError('DateAdapter');\n        }\n        if (!this._dateFormats) {\n          throw createMissingDateImplError('MAT_DATE_FORMATS');\n        }\n      }\n      this._localeSubscription = this._dateAdapter.localeChanges.subscribe(() => {\n        this._assignValueProgrammatically(this.value, true);\n      });\n    }\n    ngAfterViewInit() {\n      this._isInitialized = true;\n    }\n    ngOnChanges(changes) {\n      if (dateInputsHaveChanged(changes, this._dateAdapter)) {\n        this.stateChanges.next(undefined);\n      }\n    }\n    ngOnDestroy() {\n      this._valueChangesSubscription.unsubscribe();\n      this._localeSubscription.unsubscribe();\n      this.stateChanges.complete();\n    }\n    registerOnValidatorChange(fn) {\n      this._validatorOnChange = fn;\n    }\n    validate(c) {\n      return this._validator ? this._validator(c) : null;\n    }\n    writeValue(value) {\n      this._assignValueProgrammatically(value, value !== this.value);\n    }\n    registerOnChange(fn) {\n      this._cvaOnChange = fn;\n    }\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    _onKeydown(event) {\n      const ctrlShiftMetaModifiers = ['ctrlKey', 'shiftKey', 'metaKey'];\n      const isAltDownArrow = hasModifierKey(event, 'altKey') && event.keyCode === DOWN_ARROW && ctrlShiftMetaModifiers.every(modifier => !hasModifierKey(event, modifier));\n      if (isAltDownArrow && !this._elementRef.nativeElement.readOnly) {\n        this._openPopup();\n        event.preventDefault();\n      }\n    }\n    _onInput(event) {\n      const value = event.target.value;\n      const lastValueWasValid = this._lastValueValid;\n      let date = this._dateAdapter.parse(value, this._dateFormats.parse.dateInput);\n      this._lastValueValid = this._isValidValue(date);\n      date = this._dateAdapter.getValidDateOrNull(date);\n      const hasChanged = !this._dateAdapter.sameDate(date, this.value);\n      if (!date || hasChanged) {\n        this._cvaOnChange(date);\n      } else {\n        if (value && !this.value) {\n          this._cvaOnChange(date);\n        }\n        if (lastValueWasValid !== this._lastValueValid) {\n          this._validatorOnChange();\n        }\n      }\n      if (hasChanged) {\n        this._assignValue(date);\n        this.dateInput.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n      }\n    }\n    _onChange() {\n      this.dateChange.emit(new MatDatepickerInputEvent(this, this._elementRef.nativeElement));\n    }\n    _onBlur() {\n      if (this.value) {\n        this._formatValue(this.value);\n      }\n      this._onTouched();\n    }\n    _formatValue(value) {\n      this._elementRef.nativeElement.value = value != null ? this._dateAdapter.format(value, this._dateFormats.display.dateInput) : '';\n    }\n    _assignValue(value) {\n      if (this._model) {\n        this._assignValueToModel(value);\n        this._pendingValue = null;\n      } else {\n        this._pendingValue = value;\n      }\n    }\n    _isValidValue(value) {\n      return !value || this._dateAdapter.isValid(value);\n    }\n    _parentDisabled() {\n      return false;\n    }\n    _assignValueProgrammatically(value, reformat) {\n      value = this._dateAdapter.deserialize(value);\n      this._lastValueValid = this._isValidValue(value);\n      value = this._dateAdapter.getValidDateOrNull(value);\n      this._assignValue(value);\n      if (reformat) {\n        this._formatValue(value);\n      }\n    }\n    _matchesFilter(value) {\n      const filter = this._getDateFilter();\n      return !filter || filter(value);\n    }\n    static ɵfac = function MatDatepickerInputBase_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerInputBase)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDatepickerInputBase,\n      inputs: {\n        value: \"value\",\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute]\n      },\n      outputs: {\n        dateChange: \"dateChange\",\n        dateInput: \"dateInput\"\n      },\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return MatDatepickerInputBase;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction dateInputsHaveChanged(changes, adapter) {\n  const keys = Object.keys(changes);\n  for (let key of keys) {\n    const {\n      previousValue,\n      currentValue\n    } = changes[key];\n    if (adapter.isDateInstance(previousValue) && adapter.isDateInstance(currentValue)) {\n      if (!adapter.sameDate(previousValue, currentValue)) {\n        return true;\n      }\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\nconst MAT_DATEPICKER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: /*#__PURE__*/forwardRef(() => MatDatepickerInput),\n  multi: true\n};\nconst MAT_DATEPICKER_VALIDATORS = {\n  provide: NG_VALIDATORS,\n  useExisting: /*#__PURE__*/forwardRef(() => MatDatepickerInput),\n  multi: true\n};\nlet MatDatepickerInput = /*#__PURE__*/(() => {\n  class MatDatepickerInput extends MatDatepickerInputBase {\n    _formField = inject(MAT_FORM_FIELD, {\n      optional: true\n    });\n    _closedSubscription = Subscription.EMPTY;\n    _openedSubscription = Subscription.EMPTY;\n    set matDatepicker(datepicker) {\n      if (datepicker) {\n        this._datepicker = datepicker;\n        this._ariaOwns.set(datepicker.opened ? datepicker.id : null);\n        this._closedSubscription = datepicker.closedStream.subscribe(() => {\n          this._onTouched();\n          this._ariaOwns.set(null);\n        });\n        this._openedSubscription = datepicker.openedStream.subscribe(() => {\n          this._ariaOwns.set(datepicker.id);\n        });\n        this._registerModel(datepicker.registerInput(this));\n      }\n    }\n    _datepicker;\n    _ariaOwns = signal(null, ...(ngDevMode ? [{\n      debugName: \"_ariaOwns\"\n    }] : []));\n    get min() {\n      return this._min;\n    }\n    set min(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      if (!this._dateAdapter.sameDate(validValue, this._min)) {\n        this._min = validValue;\n        this._validatorOnChange();\n      }\n    }\n    _min;\n    get max() {\n      return this._max;\n    }\n    set max(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      if (!this._dateAdapter.sameDate(validValue, this._max)) {\n        this._max = validValue;\n        this._validatorOnChange();\n      }\n    }\n    _max;\n    get dateFilter() {\n      return this._dateFilter;\n    }\n    set dateFilter(value) {\n      const wasMatchingValue = this._matchesFilter(this.value);\n      this._dateFilter = value;\n      if (this._matchesFilter(this.value) !== wasMatchingValue) {\n        this._validatorOnChange();\n      }\n    }\n    _dateFilter;\n    _validator;\n    constructor() {\n      super();\n      this._validator = Validators.compose(super._getValidators());\n    }\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    }\n    getOverlayLabelId() {\n      if (this._formField) {\n        return this._formField.getLabelId();\n      }\n      return this._elementRef.nativeElement.getAttribute('aria-labelledby');\n    }\n    getThemePalette() {\n      return this._formField ? this._formField.color : undefined;\n    }\n    getStartValue() {\n      return this.value;\n    }\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this._closedSubscription.unsubscribe();\n      this._openedSubscription.unsubscribe();\n    }\n    _openPopup() {\n      if (this._datepicker) {\n        this._datepicker.open();\n      }\n    }\n    _getValueFromModel(modelValue) {\n      return modelValue;\n    }\n    _assignValueToModel(value) {\n      if (this._model) {\n        this._model.updateSelection(value, this);\n      }\n    }\n    _getMinDate() {\n      return this._min;\n    }\n    _getMaxDate() {\n      return this._max;\n    }\n    _getDateFilter() {\n      return this._dateFilter;\n    }\n    _shouldHandleChangeEvent(event) {\n      return event.source !== this;\n    }\n    static ɵfac = function MatDatepickerInput_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerInput)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDatepickerInput,\n      selectors: [[\"input\", \"matDatepicker\", \"\"]],\n      hostAttrs: [1, \"mat-datepicker-input\"],\n      hostVars: 6,\n      hostBindings: function MatDatepickerInput_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function MatDatepickerInput_input_HostBindingHandler($event) {\n            return ctx._onInput($event);\n          })(\"change\", function MatDatepickerInput_change_HostBindingHandler() {\n            return ctx._onChange();\n          })(\"blur\", function MatDatepickerInput_blur_HostBindingHandler() {\n            return ctx._onBlur();\n          })(\"keydown\", function MatDatepickerInput_keydown_HostBindingHandler($event) {\n            return ctx._onKeydown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"disabled\", ctx.disabled);\n          i0.ɵɵattribute(\"aria-haspopup\", ctx._datepicker ? \"dialog\" : null)(\"aria-owns\", ctx._ariaOwns())(\"min\", ctx.min ? ctx._dateAdapter.toIso8601(ctx.min) : null)(\"max\", ctx.max ? ctx._dateAdapter.toIso8601(ctx.max) : null)(\"data-mat-calendar\", ctx._datepicker ? ctx._datepicker.id : null);\n        }\n      },\n      inputs: {\n        matDatepicker: \"matDatepicker\",\n        min: \"min\",\n        max: \"max\",\n        dateFilter: [0, \"matDatepickerFilter\", \"dateFilter\"]\n      },\n      exportAs: [\"matDatepickerInput\"],\n      features: [i0.ɵɵProvidersFeature([MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATEPICKER_VALIDATORS, {\n        provide: MAT_INPUT_VALUE_ACCESSOR,\n        useExisting: MatDatepickerInput\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatDatepickerInput;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerToggleIcon = /*#__PURE__*/(() => {\n  class MatDatepickerToggleIcon {\n    static ɵfac = function MatDatepickerToggleIcon_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerToggleIcon)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDatepickerToggleIcon,\n      selectors: [[\"\", \"matDatepickerToggleIcon\", \"\"]]\n    });\n  }\n  return MatDatepickerToggleIcon;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerToggle = /*#__PURE__*/(() => {\n  class MatDatepickerToggle {\n    _intl = inject(MatDatepickerIntl);\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _stateChanges = Subscription.EMPTY;\n    datepicker;\n    tabIndex;\n    ariaLabel;\n    get disabled() {\n      if (this._disabled === undefined && this.datepicker) {\n        return this.datepicker.disabled;\n      }\n      return !!this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = value;\n    }\n    _disabled;\n    disableRipple;\n    _customIcon;\n    _button;\n    constructor() {\n      const defaultTabIndex = inject(new HostAttributeToken('tabindex'), {\n        optional: true\n      });\n      const parsedTabIndex = Number(defaultTabIndex);\n      this.tabIndex = parsedTabIndex || parsedTabIndex === 0 ? parsedTabIndex : null;\n    }\n    ngOnChanges(changes) {\n      if (changes['datepicker']) {\n        this._watchStateChanges();\n      }\n    }\n    ngOnDestroy() {\n      this._stateChanges.unsubscribe();\n    }\n    ngAfterContentInit() {\n      this._watchStateChanges();\n    }\n    _open(event) {\n      if (this.datepicker && !this.disabled) {\n        this.datepicker.open();\n        event.stopPropagation();\n      }\n    }\n    _watchStateChanges() {\n      const datepickerStateChanged = this.datepicker ? this.datepicker.stateChanges : of();\n      const inputStateChanged = this.datepicker && this.datepicker.datepickerInput ? this.datepicker.datepickerInput.stateChanges : of();\n      const datepickerToggled = this.datepicker ? merge(this.datepicker.openedStream, this.datepicker.closedStream) : of();\n      this._stateChanges.unsubscribe();\n      this._stateChanges = merge(this._intl.changes, datepickerStateChanged, inputStateChanged, datepickerToggled).subscribe(() => this._changeDetectorRef.markForCheck());\n    }\n    static ɵfac = function MatDatepickerToggle_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerToggle)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDatepickerToggle,\n      selectors: [[\"mat-datepicker-toggle\"]],\n      contentQueries: function MatDatepickerToggle_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, MatDatepickerToggleIcon, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._customIcon = _t.first);\n        }\n      },\n      viewQuery: function MatDatepickerToggle_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c2, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._button = _t.first);\n        }\n      },\n      hostAttrs: [1, \"mat-datepicker-toggle\"],\n      hostVars: 8,\n      hostBindings: function MatDatepickerToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatDatepickerToggle_click_HostBindingHandler($event) {\n            return ctx._open($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"tabindex\", null)(\"data-mat-calendar\", ctx.datepicker ? ctx.datepicker.id : null);\n          i0.ɵɵclassProp(\"mat-datepicker-toggle-active\", ctx.datepicker && ctx.datepicker.opened)(\"mat-accent\", ctx.datepicker && ctx.datepicker.color === \"accent\")(\"mat-warn\", ctx.datepicker && ctx.datepicker.color === \"warn\");\n        }\n      },\n      inputs: {\n        datepicker: [0, \"for\", \"datepicker\"],\n        tabIndex: \"tabIndex\",\n        ariaLabel: [0, \"aria-label\", \"ariaLabel\"],\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        disableRipple: \"disableRipple\"\n      },\n      exportAs: [\"matDatepickerToggle\"],\n      features: [i0.ɵɵNgOnChangesFeature],\n      ngContentSelectors: _c4,\n      decls: 4,\n      vars: 7,\n      consts: [[\"button\", \"\"], [\"matIconButton\", \"\", \"type\", \"button\", 3, \"tabIndex\", \"disabled\", \"disableRipple\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"24px\", \"height\", \"24px\", \"fill\", \"currentColor\", \"focusable\", \"false\", \"aria-hidden\", \"true\", 1, \"mat-datepicker-toggle-default-icon\"], [\"d\", \"M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z\"]],\n      template: function MatDatepickerToggle_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c3);\n          i0.ɵɵelementStart(0, \"button\", 1, 0);\n          i0.ɵɵconditionalCreate(2, MatDatepickerToggle_Conditional_2_Template, 2, 0, \":svg:svg\", 2);\n          i0.ɵɵprojection(3);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"tabIndex\", ctx.disabled ? -1 : ctx.tabIndex)(\"disabled\", ctx.disabled)(\"disableRipple\", ctx.disableRipple);\n          i0.ɵɵattribute(\"aria-haspopup\", ctx.datepicker ? \"dialog\" : null)(\"aria-label\", ctx.ariaLabel || ctx._intl.openCalendarLabel)(\"aria-expanded\", ctx.datepicker ? ctx.datepicker.opened : null);\n          i0.ɵɵadvance(2);\n          i0.ɵɵconditional(!ctx._customIcon ? 2 : -1);\n        }\n      },\n      dependencies: [MatIconButton],\n      styles: [\".mat-datepicker-toggle{pointer-events:auto;color:var(--mat-datepicker-toggle-icon-color, var(--mat-sys-on-surface-variant))}.mat-datepicker-toggle button{color:inherit}.mat-datepicker-toggle-active{color:var(--mat-datepicker-toggle-active-state-icon-color, var(--mat-sys-primary))}@media(forced-colors: active){.mat-datepicker-toggle-default-icon{color:CanvasText}}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDatepickerToggle;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDateRangeInput = /*#__PURE__*/(() => {\n  class MatDateRangeInput {\n    _changeDetectorRef = inject(ChangeDetectorRef);\n    _elementRef = inject(ElementRef);\n    _dateAdapter = inject(DateAdapter, {\n      optional: true\n    });\n    _formField = inject(MAT_FORM_FIELD, {\n      optional: true\n    });\n    _closedSubscription = Subscription.EMPTY;\n    _openedSubscription = Subscription.EMPTY;\n    _startInput;\n    _endInput;\n    get value() {\n      return this._model ? this._model.selection : null;\n    }\n    id = inject(_IdGenerator).getId('mat-date-range-input-');\n    focused = false;\n    get shouldLabelFloat() {\n      return this.focused || !this.empty;\n    }\n    controlType = 'mat-date-range-input';\n    get placeholder() {\n      const start = this._startInput?._getPlaceholder() || '';\n      const end = this._endInput?._getPlaceholder() || '';\n      return start || end ? `${start} ${this.separator} ${end}` : '';\n    }\n    get rangePicker() {\n      return this._rangePicker;\n    }\n    set rangePicker(rangePicker) {\n      if (rangePicker) {\n        this._model = rangePicker.registerInput(this);\n        this._rangePicker = rangePicker;\n        this._closedSubscription.unsubscribe();\n        this._openedSubscription.unsubscribe();\n        this._ariaOwns.set(this.rangePicker.opened ? rangePicker.id : null);\n        this._closedSubscription = rangePicker.closedStream.subscribe(() => {\n          this._startInput?._onTouched();\n          this._endInput?._onTouched();\n          this._ariaOwns.set(null);\n        });\n        this._openedSubscription = rangePicker.openedStream.subscribe(() => {\n          this._ariaOwns.set(rangePicker.id);\n        });\n        this._registerModel(this._model);\n      }\n    }\n    _rangePicker;\n    _ariaOwns = signal(null, ...(ngDevMode ? [{\n      debugName: \"_ariaOwns\"\n    }] : []));\n    get required() {\n      return this._required ?? (this._isTargetRequired(this) || this._isTargetRequired(this._startInput) || this._isTargetRequired(this._endInput)) ?? false;\n    }\n    set required(value) {\n      this._required = value;\n    }\n    _required;\n    get dateFilter() {\n      return this._dateFilter;\n    }\n    set dateFilter(value) {\n      const start = this._startInput;\n      const end = this._endInput;\n      const wasMatchingStart = start && start._matchesFilter(start.value);\n      const wasMatchingEnd = end && end._matchesFilter(start.value);\n      this._dateFilter = value;\n      if (start && start._matchesFilter(start.value) !== wasMatchingStart) {\n        start._validatorOnChange();\n      }\n      if (end && end._matchesFilter(end.value) !== wasMatchingEnd) {\n        end._validatorOnChange();\n      }\n    }\n    _dateFilter;\n    get min() {\n      return this._min;\n    }\n    set min(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      if (!this._dateAdapter.sameDate(validValue, this._min)) {\n        this._min = validValue;\n        this._revalidate();\n      }\n    }\n    _min;\n    get max() {\n      return this._max;\n    }\n    set max(value) {\n      const validValue = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(value));\n      if (!this._dateAdapter.sameDate(validValue, this._max)) {\n        this._max = validValue;\n        this._revalidate();\n      }\n    }\n    _max;\n    get disabled() {\n      return this._startInput && this._endInput ? this._startInput.disabled && this._endInput.disabled : this._groupDisabled;\n    }\n    set disabled(value) {\n      if (value !== this._groupDisabled) {\n        this._groupDisabled = value;\n        this.stateChanges.next(undefined);\n      }\n    }\n    _groupDisabled = false;\n    get errorState() {\n      if (this._startInput && this._endInput) {\n        return this._startInput.errorState || this._endInput.errorState;\n      }\n      return false;\n    }\n    get empty() {\n      const startEmpty = this._startInput ? this._startInput.isEmpty() : false;\n      const endEmpty = this._endInput ? this._endInput.isEmpty() : false;\n      return startEmpty && endEmpty;\n    }\n    _ariaDescribedBy = null;\n    _model;\n    separator = '–';\n    comparisonStart = null;\n    comparisonEnd = null;\n    ngControl;\n    stateChanges = new Subject();\n    disableAutomaticLabeling = true;\n    constructor() {\n      if (!this._dateAdapter && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        throw createMissingDateImplError('DateAdapter');\n      }\n      if (this._formField?._elementRef.nativeElement.classList.contains('mat-mdc-form-field')) {\n        this._elementRef.nativeElement.classList.add('mat-mdc-input-element', 'mat-mdc-form-field-input-control', 'mdc-text-field__input');\n      }\n      this.ngControl = inject(ControlContainer, {\n        optional: true,\n        self: true\n      });\n    }\n    get describedByIds() {\n      const element = this._elementRef.nativeElement;\n      const existingDescribedBy = element.getAttribute('aria-describedby');\n      return existingDescribedBy?.split(' ') || [];\n    }\n    setDescribedByIds(ids) {\n      this._ariaDescribedBy = ids.length ? ids.join(' ') : null;\n    }\n    onContainerClick() {\n      if (!this.focused && !this.disabled) {\n        if (!this._model || !this._model.selection.start) {\n          this._startInput.focus();\n        } else {\n          this._endInput.focus();\n        }\n      }\n    }\n    ngAfterContentInit() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        if (!this._startInput) {\n          throw Error('mat-date-range-input must contain a matStartDate input');\n        }\n        if (!this._endInput) {\n          throw Error('mat-date-range-input must contain a matEndDate input');\n        }\n      }\n      if (this._model) {\n        this._registerModel(this._model);\n      }\n      merge(this._startInput.stateChanges, this._endInput.stateChanges).subscribe(() => {\n        this.stateChanges.next(undefined);\n      });\n    }\n    ngOnChanges(changes) {\n      if (dateInputsHaveChanged(changes, this._dateAdapter)) {\n        this.stateChanges.next(undefined);\n      }\n    }\n    ngOnDestroy() {\n      this._closedSubscription.unsubscribe();\n      this._openedSubscription.unsubscribe();\n      this.stateChanges.complete();\n    }\n    getStartValue() {\n      return this.value ? this.value.start : null;\n    }\n    getThemePalette() {\n      return this._formField ? this._formField.color : undefined;\n    }\n    getConnectedOverlayOrigin() {\n      return this._formField ? this._formField.getConnectedOverlayOrigin() : this._elementRef;\n    }\n    getOverlayLabelId() {\n      return this._formField ? this._formField.getLabelId() : null;\n    }\n    _getInputMirrorValue(part) {\n      const input = part === 'start' ? this._startInput : this._endInput;\n      return input ? input.getMirrorValue() : '';\n    }\n    _shouldHidePlaceholders() {\n      return this._startInput ? !this._startInput.isEmpty() : false;\n    }\n    _handleChildValueChange() {\n      this.stateChanges.next(undefined);\n      this._changeDetectorRef.markForCheck();\n    }\n    _openDatepicker() {\n      if (this._rangePicker) {\n        this._rangePicker.open();\n      }\n    }\n    _shouldHideSeparator() {\n      return (!this._formField || this._formField.getLabelId() && !this._formField._shouldLabelFloat()) && this.empty;\n    }\n    _getAriaLabelledby() {\n      const formField = this._formField;\n      return formField && formField._hasFloatingLabel() ? formField._labelId : null;\n    }\n    _getStartDateAccessibleName() {\n      return this._startInput._getAccessibleName();\n    }\n    _getEndDateAccessibleName() {\n      return this._endInput._getAccessibleName();\n    }\n    _updateFocus(origin) {\n      this.focused = origin !== null;\n      this.stateChanges.next();\n    }\n    _revalidate() {\n      if (this._startInput) {\n        this._startInput._validatorOnChange();\n      }\n      if (this._endInput) {\n        this._endInput._validatorOnChange();\n      }\n    }\n    _registerModel(model) {\n      if (this._startInput) {\n        this._startInput._registerModel(model);\n      }\n      if (this._endInput) {\n        this._endInput._registerModel(model);\n      }\n    }\n    _isTargetRequired(target) {\n      return target?.ngControl?.control?.hasValidator(Validators.required);\n    }\n    static ɵfac = function MatDateRangeInput_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDateRangeInput)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDateRangeInput,\n      selectors: [[\"mat-date-range-input\"]],\n      hostAttrs: [\"role\", \"group\", 1, \"mat-date-range-input\"],\n      hostVars: 8,\n      hostBindings: function MatDateRangeInput_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"id\", ctx.id)(\"aria-labelledby\", ctx._getAriaLabelledby())(\"aria-describedby\", ctx._ariaDescribedBy)(\"data-mat-calendar\", ctx.rangePicker ? ctx.rangePicker.id : null);\n          i0.ɵɵclassProp(\"mat-date-range-input-hide-placeholders\", ctx._shouldHidePlaceholders())(\"mat-date-range-input-required\", ctx.required);\n        }\n      },\n      inputs: {\n        rangePicker: \"rangePicker\",\n        required: [2, \"required\", \"required\", booleanAttribute],\n        dateFilter: \"dateFilter\",\n        min: \"min\",\n        max: \"max\",\n        disabled: [2, \"disabled\", \"disabled\", booleanAttribute],\n        separator: \"separator\",\n        comparisonStart: \"comparisonStart\",\n        comparisonEnd: \"comparisonEnd\"\n      },\n      exportAs: [\"matDateRangeInput\"],\n      features: [i0.ɵɵProvidersFeature([{\n        provide: MatFormFieldControl,\n        useExisting: MatDateRangeInput\n      }]), i0.ɵɵNgOnChangesFeature],\n      ngContentSelectors: _c6,\n      decls: 11,\n      vars: 5,\n      consts: [[\"cdkMonitorSubtreeFocus\", \"\", 1, \"mat-date-range-input-container\", 3, \"cdkFocusChange\"], [1, \"mat-date-range-input-wrapper\"], [\"aria-hidden\", \"true\", 1, \"mat-date-range-input-mirror\"], [1, \"mat-date-range-input-separator\"], [1, \"mat-date-range-input-wrapper\", \"mat-date-range-input-end-wrapper\"]],\n      template: function MatDateRangeInput_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef(_c5);\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵlistener(\"cdkFocusChange\", function MatDateRangeInput_Template_div_cdkFocusChange_0_listener($event) {\n            return ctx._updateFocus($event);\n          });\n          i0.ɵɵelementStart(1, \"div\", 1);\n          i0.ɵɵprojection(2);\n          i0.ɵɵelementStart(3, \"span\", 2);\n          i0.ɵɵtext(4);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵelementStart(5, \"span\", 3);\n          i0.ɵɵtext(6);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(7, \"div\", 4);\n          i0.ɵɵprojection(8, 1);\n          i0.ɵɵelementStart(9, \"span\", 2);\n          i0.ɵɵtext(10);\n          i0.ɵɵelementEnd()()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(4);\n          i0.ɵɵtextInterpolate(ctx._getInputMirrorValue(\"start\"));\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"mat-date-range-input-separator-hidden\", ctx._shouldHideSeparator());\n          i0.ɵɵadvance();\n          i0.ɵɵtextInterpolate(ctx.separator);\n          i0.ɵɵadvance(4);\n          i0.ɵɵtextInterpolate(ctx._getInputMirrorValue(\"end\"));\n        }\n      },\n      dependencies: [CdkMonitorFocus],\n      styles: [\".mat-date-range-input{display:block;width:100%}.mat-date-range-input-container{display:flex;align-items:center}.mat-date-range-input-separator{transition:opacity 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);margin:0 4px;color:var(--mat-datepicker-range-input-separator-color, var(--mat-sys-on-surface))}.mat-form-field-disabled .mat-date-range-input-separator{color:var(--mat-datepicker-range-input-disabled-state-separator-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}._mat-animation-noopable .mat-date-range-input-separator{transition:none}.mat-date-range-input-separator-hidden{-webkit-user-select:none;user-select:none;opacity:0;transition:none}.mat-date-range-input-wrapper{position:relative;overflow:hidden;max-width:calc(50% - 4px)}.mat-date-range-input-end-wrapper{flex-grow:1}.mat-date-range-input-inner{position:absolute;top:0;left:0;font:inherit;background:rgba(0,0,0,0);color:currentColor;border:none;outline:none;padding:0;margin:0;vertical-align:bottom;text-align:inherit;-webkit-appearance:none;width:100%;height:100%}.mat-date-range-input-inner:-moz-ui-invalid{box-shadow:none}.mat-date-range-input-inner::placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-date-range-input-inner::-moz-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-date-range-input-inner::-webkit-input-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-date-range-input-inner:-ms-input-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-date-range-input-inner[disabled]{color:var(--mat-datepicker-range-input-disabled-state-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-hide-placeholder .mat-date-range-input-inner::placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::placeholder{-webkit-user-select:none;user-select:none;color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}@media(forced-colors: active){.mat-form-field-hide-placeholder .mat-date-range-input-inner::placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::placeholder{opacity:0}}.mat-form-field-hide-placeholder .mat-date-range-input-inner::-moz-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::-moz-placeholder{-webkit-user-select:none;user-select:none;color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}@media(forced-colors: active){.mat-form-field-hide-placeholder .mat-date-range-input-inner::-moz-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::-moz-placeholder{opacity:0}}.mat-form-field-hide-placeholder .mat-date-range-input-inner::-webkit-input-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::-webkit-input-placeholder{-webkit-user-select:none;user-select:none;color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}@media(forced-colors: active){.mat-form-field-hide-placeholder .mat-date-range-input-inner::-webkit-input-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner::-webkit-input-placeholder{opacity:0}}.mat-form-field-hide-placeholder .mat-date-range-input-inner:-ms-input-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner:-ms-input-placeholder{-webkit-user-select:none;user-select:none;color:rgba(0,0,0,0) !important;-webkit-text-fill-color:rgba(0,0,0,0);transition:none}@media(forced-colors: active){.mat-form-field-hide-placeholder .mat-date-range-input-inner:-ms-input-placeholder,.mat-date-range-input-hide-placeholders .mat-date-range-input-inner:-ms-input-placeholder{opacity:0}}._mat-animation-noopable .mat-date-range-input-inner::placeholder{transition:none}._mat-animation-noopable .mat-date-range-input-inner::-moz-placeholder{transition:none}._mat-animation-noopable .mat-date-range-input-inner::-webkit-input-placeholder{transition:none}._mat-animation-noopable .mat-date-range-input-inner:-ms-input-placeholder{transition:none}.mat-date-range-input-mirror{-webkit-user-select:none;user-select:none;visibility:hidden;white-space:nowrap;display:inline-block;min-width:2px}.mat-mdc-form-field-type-mat-date-range-input .mat-mdc-form-field-infix{width:200px}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDateRangeInput;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction _computeAriaAccessibleName(element) {\n  return _computeAriaAccessibleNameInternal(element, true);\n}\nfunction ssrSafeIsElement(node) {\n  return node.nodeType === Node.ELEMENT_NODE;\n}\nfunction ssrSafeIsHTMLInputElement(node) {\n  return node.nodeName === 'INPUT';\n}\nfunction ssrSafeIsHTMLTextAreaElement(node) {\n  return node.nodeName === 'TEXTAREA';\n}\nfunction _computeAriaAccessibleNameInternal(currentNode, isDirectlyReferenced) {\n  if (ssrSafeIsElement(currentNode) && isDirectlyReferenced) {\n    const labelledbyIds = currentNode.getAttribute?.('aria-labelledby')?.split(/\\s+/g) || [];\n    const validIdRefs = labelledbyIds.reduce((validIds, id) => {\n      const elem = document.getElementById(id);\n      if (elem) {\n        validIds.push(elem);\n      }\n      return validIds;\n    }, []);\n    if (validIdRefs.length) {\n      return validIdRefs.map(idRef => {\n        return _computeAriaAccessibleNameInternal(idRef, false);\n      }).join(' ');\n    }\n  }\n  if (ssrSafeIsElement(currentNode)) {\n    const ariaLabel = currentNode.getAttribute('aria-label')?.trim();\n    if (ariaLabel) {\n      return ariaLabel;\n    }\n  }\n  if (ssrSafeIsHTMLInputElement(currentNode) || ssrSafeIsHTMLTextAreaElement(currentNode)) {\n    if (currentNode.labels?.length) {\n      return Array.from(currentNode.labels).map(x => _computeAriaAccessibleNameInternal(x, false)).join(' ');\n    }\n    const placeholder = currentNode.getAttribute('placeholder')?.trim();\n    if (placeholder) {\n      return placeholder;\n    }\n    const title = currentNode.getAttribute('title')?.trim();\n    if (title) {\n      return title;\n    }\n  }\n  return (currentNode.textContent || '').replace(/\\s+/g, ' ').trim();\n}\nlet MatDateRangeInputPartBase = /*#__PURE__*/(() => {\n  class MatDateRangeInputPartBase extends MatDatepickerInputBase {\n    _rangeInput = inject(MatDateRangeInput);\n    _elementRef = inject(ElementRef);\n    _defaultErrorStateMatcher = inject(ErrorStateMatcher);\n    _injector = inject(Injector);\n    _rawValue = signal('', ...(ngDevMode ? [{\n      debugName: \"_rawValue\"\n    }] : []));\n    _parentForm = inject(NgForm, {\n      optional: true\n    });\n    _parentFormGroup = inject(FormGroupDirective, {\n      optional: true\n    });\n    ngControl;\n    _dir = inject(Directionality, {\n      optional: true\n    });\n    _errorStateTracker;\n    get errorStateMatcher() {\n      return this._errorStateTracker.matcher;\n    }\n    set errorStateMatcher(value) {\n      this._errorStateTracker.matcher = value;\n    }\n    get errorState() {\n      return this._errorStateTracker.errorState;\n    }\n    set errorState(value) {\n      this._errorStateTracker.errorState = value;\n    }\n    constructor() {\n      super();\n      this._errorStateTracker = new _ErrorStateTracker(this._defaultErrorStateMatcher, null, this._parentFormGroup, this._parentForm, this.stateChanges);\n    }\n    ngOnInit() {\n      const ngControl = this._injector.get(NgControl, null, {\n        optional: true,\n        self: true\n      });\n      if (ngControl) {\n        this.ngControl = ngControl;\n        this._errorStateTracker.ngControl = ngControl;\n      }\n    }\n    ngAfterContentInit() {\n      this._register();\n    }\n    ngDoCheck() {\n      if (this.ngControl) {\n        this.updateErrorState();\n      }\n      this._rawValue.set(this._elementRef.nativeElement.value);\n    }\n    isEmpty() {\n      return this._rawValue().length === 0;\n    }\n    _getPlaceholder() {\n      return this._elementRef.nativeElement.placeholder;\n    }\n    focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    getMirrorValue() {\n      const value = this._rawValue();\n      return value.length > 0 ? value : this._getPlaceholder();\n    }\n    updateErrorState() {\n      this._errorStateTracker.updateErrorState();\n    }\n    _onInput(event) {\n      super._onInput(event);\n      this._rangeInput._handleChildValueChange();\n    }\n    _openPopup() {\n      this._rangeInput._openDatepicker();\n    }\n    _getMinDate() {\n      return this._rangeInput.min;\n    }\n    _getMaxDate() {\n      return this._rangeInput.max;\n    }\n    _getDateFilter() {\n      return this._rangeInput.dateFilter;\n    }\n    _parentDisabled() {\n      return this._rangeInput._groupDisabled;\n    }\n    _shouldHandleChangeEvent({\n      source\n    }) {\n      return source !== this._rangeInput._startInput && source !== this._rangeInput._endInput;\n    }\n    _assignValueProgrammatically(value, reformat) {\n      super._assignValueProgrammatically(value, reformat);\n      const opposite = this === this._rangeInput._startInput ? this._rangeInput._endInput : this._rangeInput._startInput;\n      opposite?._validatorOnChange();\n      this._rawValue.set(this._elementRef.nativeElement.value);\n    }\n    _formatValue(value) {\n      super._formatValue(value);\n      this._rangeInput._handleChildValueChange();\n    }\n    _getAccessibleName() {\n      return _computeAriaAccessibleName(this._elementRef.nativeElement);\n    }\n    static ɵfac = function MatDateRangeInputPartBase_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDateRangeInputPartBase)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDateRangeInputPartBase,\n      inputs: {\n        errorStateMatcher: \"errorStateMatcher\"\n      },\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatDateRangeInputPartBase;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatStartDate = /*#__PURE__*/(() => {\n  class MatStartDate extends MatDateRangeInputPartBase {\n    _startValidator = control => {\n      const start = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n      const end = this._model ? this._model.selection.end : null;\n      return !start || !end || this._dateAdapter.compareDate(start, end) <= 0 ? null : {\n        'matStartDateInvalid': {\n          'end': end,\n          'actual': start\n        }\n      };\n    };\n    _validator = Validators.compose([...super._getValidators(), this._startValidator]);\n    _register() {\n      this._rangeInput._startInput = this;\n    }\n    _getValueFromModel(modelValue) {\n      return modelValue.start;\n    }\n    _shouldHandleChangeEvent(change) {\n      if (!super._shouldHandleChangeEvent(change)) {\n        return false;\n      } else {\n        return !change.oldValue?.start ? !!change.selection.start : !change.selection.start || !!this._dateAdapter.compareDate(change.oldValue.start, change.selection.start);\n      }\n    }\n    _assignValueToModel(value) {\n      if (this._model) {\n        const range = new DateRange(value, this._model.selection.end);\n        this._model.updateSelection(range, this);\n        this._rangeInput._handleChildValueChange();\n      }\n    }\n    _onKeydown(event) {\n      const endInput = this._rangeInput._endInput;\n      const element = this._elementRef.nativeElement;\n      const isLtr = this._dir?.value !== 'rtl';\n      if ((event.keyCode === RIGHT_ARROW && isLtr || event.keyCode === LEFT_ARROW && !isLtr) && element.selectionStart === element.value.length && element.selectionEnd === element.value.length) {\n        event.preventDefault();\n        endInput._elementRef.nativeElement.setSelectionRange(0, 0);\n        endInput.focus();\n      } else {\n        super._onKeydown(event);\n      }\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatStartDate_BaseFactory;\n      return function MatStartDate_Factory(__ngFactoryType__) {\n        return (ɵMatStartDate_BaseFactory || (ɵMatStartDate_BaseFactory = i0.ɵɵgetInheritedFactory(MatStartDate)))(__ngFactoryType__ || MatStartDate);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatStartDate,\n      selectors: [[\"input\", \"matStartDate\", \"\"]],\n      hostAttrs: [\"type\", \"text\", 1, \"mat-start-date\", \"mat-date-range-input-inner\"],\n      hostVars: 5,\n      hostBindings: function MatStartDate_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function MatStartDate_input_HostBindingHandler($event) {\n            return ctx._onInput($event);\n          })(\"change\", function MatStartDate_change_HostBindingHandler() {\n            return ctx._onChange();\n          })(\"keydown\", function MatStartDate_keydown_HostBindingHandler($event) {\n            return ctx._onKeydown($event);\n          })(\"blur\", function MatStartDate_blur_HostBindingHandler() {\n            return ctx._onBlur();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"disabled\", ctx.disabled);\n          i0.ɵɵattribute(\"aria-haspopup\", ctx._rangeInput.rangePicker ? \"dialog\" : null)(\"aria-owns\", ctx._rangeInput._ariaOwns() || null)(\"min\", ctx._getMinDate() ? ctx._dateAdapter.toIso8601(ctx._getMinDate()) : null)(\"max\", ctx._getMaxDate() ? ctx._dateAdapter.toIso8601(ctx._getMaxDate()) : null);\n        }\n      },\n      outputs: {\n        dateChange: \"dateChange\",\n        dateInput: \"dateInput\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: MatStartDate,\n        multi: true\n      }, {\n        provide: NG_VALIDATORS,\n        useExisting: MatStartDate,\n        multi: true\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatStartDate;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatEndDate = /*#__PURE__*/(() => {\n  class MatEndDate extends MatDateRangeInputPartBase {\n    _endValidator = control => {\n      const end = this._dateAdapter.getValidDateOrNull(this._dateAdapter.deserialize(control.value));\n      const start = this._model ? this._model.selection.start : null;\n      return !end || !start || this._dateAdapter.compareDate(end, start) >= 0 ? null : {\n        'matEndDateInvalid': {\n          'start': start,\n          'actual': end\n        }\n      };\n    };\n    _register() {\n      this._rangeInput._endInput = this;\n    }\n    _validator = Validators.compose([...super._getValidators(), this._endValidator]);\n    _getValueFromModel(modelValue) {\n      return modelValue.end;\n    }\n    _shouldHandleChangeEvent(change) {\n      if (!super._shouldHandleChangeEvent(change)) {\n        return false;\n      } else {\n        return !change.oldValue?.end ? !!change.selection.end : !change.selection.end || !!this._dateAdapter.compareDate(change.oldValue.end, change.selection.end);\n      }\n    }\n    _assignValueToModel(value) {\n      if (this._model) {\n        const range = new DateRange(this._model.selection.start, value);\n        this._model.updateSelection(range, this);\n      }\n    }\n    _moveCaretToEndOfStartInput() {\n      const startInput = this._rangeInput._startInput._elementRef.nativeElement;\n      const value = startInput.value;\n      if (value.length > 0) {\n        startInput.setSelectionRange(value.length, value.length);\n      }\n      startInput.focus();\n    }\n    _onKeydown(event) {\n      const element = this._elementRef.nativeElement;\n      const isLtr = this._dir?.value !== 'rtl';\n      if (event.keyCode === BACKSPACE && !element.value) {\n        this._moveCaretToEndOfStartInput();\n      } else if ((event.keyCode === LEFT_ARROW && isLtr || event.keyCode === RIGHT_ARROW && !isLtr) && element.selectionStart === 0 && element.selectionEnd === 0) {\n        event.preventDefault();\n        this._moveCaretToEndOfStartInput();\n      } else {\n        super._onKeydown(event);\n      }\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatEndDate_BaseFactory;\n      return function MatEndDate_Factory(__ngFactoryType__) {\n        return (ɵMatEndDate_BaseFactory || (ɵMatEndDate_BaseFactory = i0.ɵɵgetInheritedFactory(MatEndDate)))(__ngFactoryType__ || MatEndDate);\n      };\n    })();\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatEndDate,\n      selectors: [[\"input\", \"matEndDate\", \"\"]],\n      hostAttrs: [\"type\", \"text\", 1, \"mat-end-date\", \"mat-date-range-input-inner\"],\n      hostVars: 5,\n      hostBindings: function MatEndDate_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function MatEndDate_input_HostBindingHandler($event) {\n            return ctx._onInput($event);\n          })(\"change\", function MatEndDate_change_HostBindingHandler() {\n            return ctx._onChange();\n          })(\"keydown\", function MatEndDate_keydown_HostBindingHandler($event) {\n            return ctx._onKeydown($event);\n          })(\"blur\", function MatEndDate_blur_HostBindingHandler() {\n            return ctx._onBlur();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵdomProperty(\"disabled\", ctx.disabled);\n          i0.ɵɵattribute(\"aria-haspopup\", ctx._rangeInput.rangePicker ? \"dialog\" : null)(\"aria-owns\", ctx._rangeInput._ariaOwns() || null)(\"min\", ctx._getMinDate() ? ctx._dateAdapter.toIso8601(ctx._getMinDate()) : null)(\"max\", ctx._getMaxDate() ? ctx._dateAdapter.toIso8601(ctx._getMaxDate()) : null);\n        }\n      },\n      outputs: {\n        dateChange: \"dateChange\",\n        dateInput: \"dateInput\"\n      },\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: MatEndDate,\n        multi: true\n      }, {\n        provide: NG_VALIDATORS,\n        useExisting: MatEndDate,\n        multi: true\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return MatEndDate;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDateRangePicker = /*#__PURE__*/(() => {\n  class MatDateRangePicker extends MatDatepickerBase {\n    _forwardContentValues(instance) {\n      super._forwardContentValues(instance);\n      const input = this.datepickerInput;\n      if (input) {\n        instance.comparisonStart = input.comparisonStart;\n        instance.comparisonEnd = input.comparisonEnd;\n        instance.startDateAccessibleName = input._getStartDateAccessibleName();\n        instance.endDateAccessibleName = input._getEndDateAccessibleName();\n      }\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵMatDateRangePicker_BaseFactory;\n      return function MatDateRangePicker_Factory(__ngFactoryType__) {\n        return (ɵMatDateRangePicker_BaseFactory || (ɵMatDateRangePicker_BaseFactory = i0.ɵɵgetInheritedFactory(MatDateRangePicker)))(__ngFactoryType__ || MatDateRangePicker);\n      };\n    })();\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDateRangePicker,\n      selectors: [[\"mat-date-range-picker\"]],\n      exportAs: [\"matDateRangePicker\"],\n      features: [i0.ɵɵProvidersFeature([MAT_RANGE_DATE_SELECTION_MODEL_PROVIDER, {\n        provide: MAT_DATE_RANGE_SELECTION_STRATEGY,\n        useFactory: () => {\n          const parent = inject(MAT_DATE_RANGE_SELECTION_STRATEGY, {\n            optional: true,\n            skipSelf: true\n          });\n          return parent || new DefaultMatCalendarRangeStrategy(inject(DateAdapter));\n        }\n      }, {\n        provide: MatDatepickerBase,\n        useExisting: MatDateRangePicker\n      }]), i0.ɵɵInheritDefinitionFeature],\n      decls: 0,\n      vars: 0,\n      template: function MatDateRangePicker_Template(rf, ctx) {},\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDateRangePicker;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerApply = /*#__PURE__*/(() => {\n  class MatDatepickerApply {\n    _datepicker = inject(MatDatepickerBase);\n    constructor() {}\n    _applySelection() {\n      this._datepicker._applyPendingSelection();\n      this._datepicker.close();\n    }\n    static ɵfac = function MatDatepickerApply_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerApply)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDatepickerApply,\n      selectors: [[\"\", \"matDatepickerApply\", \"\"], [\"\", \"matDateRangePickerApply\", \"\"]],\n      hostBindings: function MatDatepickerApply_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatDatepickerApply_click_HostBindingHandler() {\n            return ctx._applySelection();\n          });\n        }\n      }\n    });\n  }\n  return MatDatepickerApply;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerCancel = /*#__PURE__*/(() => {\n  class MatDatepickerCancel {\n    _datepicker = inject(MatDatepickerBase);\n    constructor() {}\n    static ɵfac = function MatDatepickerCancel_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerCancel)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: MatDatepickerCancel,\n      selectors: [[\"\", \"matDatepickerCancel\", \"\"], [\"\", \"matDateRangePickerCancel\", \"\"]],\n      hostBindings: function MatDatepickerCancel_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function MatDatepickerCancel_click_HostBindingHandler() {\n            return ctx._datepicker.close();\n          });\n        }\n      }\n    });\n  }\n  return MatDatepickerCancel;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerActions = /*#__PURE__*/(() => {\n  class MatDatepickerActions {\n    _datepicker = inject(MatDatepickerBase);\n    _viewContainerRef = inject(ViewContainerRef);\n    _template;\n    _portal;\n    constructor() {}\n    ngAfterViewInit() {\n      this._portal = new TemplatePortal(this._template, this._viewContainerRef);\n      this._datepicker.registerActions(this._portal);\n    }\n    ngOnDestroy() {\n      this._datepicker.removeActions(this._portal);\n      if (this._portal && this._portal.isAttached) {\n        this._portal?.detach();\n      }\n    }\n    static ɵfac = function MatDatepickerActions_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerActions)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatDatepickerActions,\n      selectors: [[\"mat-datepicker-actions\"], [\"mat-date-range-picker-actions\"]],\n      viewQuery: function MatDatepickerActions_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(TemplateRef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._template = _t.first);\n        }\n      },\n      ngContentSelectors: _c1,\n      decls: 1,\n      vars: 0,\n      consts: [[1, \"mat-datepicker-actions\"]],\n      template: function MatDatepickerActions_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵdomTemplate(0, MatDatepickerActions_ng_template_0_Template, 2, 0, \"ng-template\");\n        }\n      },\n      styles: [\".mat-datepicker-actions{display:flex;justify-content:flex-end;align-items:center;padding:0 8px 8px 8px}.mat-datepicker-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-datepicker-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatDatepickerActions;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatDatepickerModule = /*#__PURE__*/(() => {\n  class MatDatepickerModule {\n    static ɵfac = function MatDatepickerModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatDatepickerModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatDatepickerModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [MatDatepickerIntl],\n      imports: [MatButtonModule, OverlayModule, A11yModule, PortalModule, MatDatepickerContent, MatDatepickerToggle, MatCalendarHeader, BidiModule, CdkScrollableModule]\n    });\n  }\n  return MatDatepickerModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { DateRange, DefaultMatCalendarRangeStrategy, MAT_DATEPICKER_SCROLL_STRATEGY, MAT_DATEPICKER_VALIDATORS, MAT_DATEPICKER_VALUE_ACCESSOR, MAT_DATE_RANGE_SELECTION_STRATEGY, MatCalendar, MatCalendarBody, MatCalendarCell, MatCalendarHeader, MatDateRangeInput, MatDateRangePicker, MatDateSelectionModel, MatDatepicker, MatDatepickerActions, MatDatepickerApply, MatDatepickerCancel, MatDatepickerContent, MatDatepickerInput, MatDatepickerInputEvent, MatDatepickerIntl, MatDatepickerModule, MatDatepickerToggle, MatDatepickerToggleIcon, MatEndDate, MatMonthView, MatMultiYearView, MatRangeDateSelectionModel, MatSingleDateSelectionModel, MatStartDate, MatYearView, yearsPerPage, yearsPerRow };\n//# sourceMappingURL=datepicker.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}