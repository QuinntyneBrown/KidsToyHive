{"ast":null,"code":"import _asyncToGenerator from \"C:/projects/KidsToyHive/src/KidsToyHive.App/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { MessageType } from \"./IHubProtocol\";\nimport { isArrayBuffer } from \"./Utils\";\n/** @private */\nexport class MessageBuffer {\n  constructor(protocol, connection, bufferSize) {\n    this._bufferSize = 100000;\n    this._messages = [];\n    this._totalMessageCount = 0;\n    this._waitForSequenceMessage = false;\n    // Message IDs start at 1 and always increment by 1\n    this._nextReceivingSequenceId = 1;\n    this._latestReceivedSequenceId = 0;\n    this._bufferedByteCount = 0;\n    this._reconnectInProgress = false;\n    this._protocol = protocol;\n    this._connection = connection;\n    this._bufferSize = bufferSize;\n  }\n  _send(message) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const serializedMessage = _this._protocol.writeMessage(message);\n      let backpressurePromise = Promise.resolve();\n      // Only count invocation messages. Acks, pings, etc. don't need to be resent on reconnect\n      if (_this._isInvocationMessage(message)) {\n        _this._totalMessageCount++;\n        let backpressurePromiseResolver = () => {};\n        let backpressurePromiseRejector = () => {};\n        if (isArrayBuffer(serializedMessage)) {\n          _this._bufferedByteCount += serializedMessage.byteLength;\n        } else {\n          _this._bufferedByteCount += serializedMessage.length;\n        }\n        if (_this._bufferedByteCount >= _this._bufferSize) {\n          backpressurePromise = new Promise((resolve, reject) => {\n            backpressurePromiseResolver = resolve;\n            backpressurePromiseRejector = reject;\n          });\n        }\n        _this._messages.push(new BufferedItem(serializedMessage, _this._totalMessageCount, backpressurePromiseResolver, backpressurePromiseRejector));\n      }\n      try {\n        // If this is set it means we are reconnecting or resending\n        // We don't want to send on a disconnected connection\n        // And we don't want to send if resend is running since that would mean sending\n        // this message twice\n        if (!_this._reconnectInProgress) {\n          yield _this._connection.send(serializedMessage);\n        }\n      } catch {\n        _this._disconnected();\n      }\n      yield backpressurePromise;\n    })();\n  }\n  _ack(ackMessage) {\n    let newestAckedMessage = -1;\n    // Find index of newest message being acked\n    for (let index = 0; index < this._messages.length; index++) {\n      const element = this._messages[index];\n      if (element._id <= ackMessage.sequenceId) {\n        newestAckedMessage = index;\n        if (isArrayBuffer(element._message)) {\n          this._bufferedByteCount -= element._message.byteLength;\n        } else {\n          this._bufferedByteCount -= element._message.length;\n        }\n        // resolve items that have already been sent and acked\n        element._resolver();\n      } else if (this._bufferedByteCount < this._bufferSize) {\n        // resolve items that now fall under the buffer limit but haven't been acked\n        element._resolver();\n      } else {\n        break;\n      }\n    }\n    if (newestAckedMessage !== -1) {\n      // We're removing everything including the message pointed to, so add 1\n      this._messages = this._messages.slice(newestAckedMessage + 1);\n    }\n  }\n  _shouldProcessMessage(message) {\n    if (this._waitForSequenceMessage) {\n      if (message.type !== MessageType.Sequence) {\n        return false;\n      } else {\n        this._waitForSequenceMessage = false;\n        return true;\n      }\n    }\n    // No special processing for acks, pings, etc.\n    if (!this._isInvocationMessage(message)) {\n      return true;\n    }\n    const currentId = this._nextReceivingSequenceId;\n    this._nextReceivingSequenceId++;\n    if (currentId <= this._latestReceivedSequenceId) {\n      if (currentId === this._latestReceivedSequenceId) {\n        // Should only hit this if we just reconnected and the server is sending\n        // Messages it has buffered, which would mean it hasn't seen an Ack for these messages\n        this._ackTimer();\n      }\n      // Ignore, this is a duplicate message\n      return false;\n    }\n    this._latestReceivedSequenceId = currentId;\n    // Only start the timer for sending an Ack message when we have a message to ack. This also conveniently solves\n    // timer throttling by not having a recursive timer, and by starting the timer via a network call (recv)\n    this._ackTimer();\n    return true;\n  }\n  _resetSequence(message) {\n    if (message.sequenceId > this._nextReceivingSequenceId) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      this._connection.stop(new Error(\"Sequence ID greater than amount of messages we've received.\"));\n      return;\n    }\n    this._nextReceivingSequenceId = message.sequenceId;\n  }\n  _disconnected() {\n    this._reconnectInProgress = true;\n    this._waitForSequenceMessage = true;\n  }\n  _resend() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const sequenceId = _this2._messages.length !== 0 ? _this2._messages[0]._id : _this2._totalMessageCount + 1;\n      yield _this2._connection.send(_this2._protocol.writeMessage({\n        type: MessageType.Sequence,\n        sequenceId\n      }));\n      // Get a local variable to the _messages, just in case messages are acked while resending\n      // Which would slice the _messages array (which creates a new copy)\n      const messages = _this2._messages;\n      for (const element of messages) {\n        yield _this2._connection.send(element._message);\n      }\n      _this2._reconnectInProgress = false;\n    })();\n  }\n  _dispose(error) {\n    error !== null && error !== void 0 ? error : error = new Error(\"Unable to reconnect to server.\");\n    // Unblock backpressure if any\n    for (const element of this._messages) {\n      element._rejector(error);\n    }\n  }\n  _isInvocationMessage(message) {\n    // There is no way to check if something implements an interface.\n    // So we individually check the messages in a switch statement.\n    // To make sure we don't miss any message types we rely on the compiler\n    // seeing the function returns a value and it will do the\n    // exhaustive check for us on the switch statement, since we don't use 'case default'\n    switch (message.type) {\n      case MessageType.Invocation:\n      case MessageType.StreamItem:\n      case MessageType.Completion:\n      case MessageType.StreamInvocation:\n      case MessageType.CancelInvocation:\n        return true;\n      case MessageType.Close:\n      case MessageType.Sequence:\n      case MessageType.Ping:\n      case MessageType.Ack:\n        return false;\n    }\n  }\n  _ackTimer() {\n    var _this3 = this;\n    if (this._ackTimerHandle === undefined) {\n      this._ackTimerHandle = setTimeout(/*#__PURE__*/_asyncToGenerator(function* () {\n        try {\n          if (!_this3._reconnectInProgress) {\n            yield _this3._connection.send(_this3._protocol.writeMessage({\n              type: MessageType.Ack,\n              sequenceId: _this3._latestReceivedSequenceId\n            }));\n          }\n          // Ignore errors, that means the connection is closed and we don't care about the Ack message anymore.\n        } catch {}\n        clearTimeout(_this3._ackTimerHandle);\n        _this3._ackTimerHandle = undefined;\n        // 1 second delay so we don't spam Ack messages if there are many messages being received at once.\n      }), 1000);\n    }\n  }\n}\nclass BufferedItem {\n  constructor(message, id, resolver, rejector) {\n    this._message = message;\n    this._id = id;\n    this._resolver = resolver;\n    this._rejector = rejector;\n  }\n}\n//# sourceMappingURL=MessageBuffer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}