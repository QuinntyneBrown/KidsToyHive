{"ast":null,"code":"/**\n * @license Angular v21.0.5\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { Attribute } from './_attribute-chunk.mjs';\nconst Property = {\n  JSACTION: '__jsaction',\n  OWNER: '__owner'\n};\nconst parseCache = {};\nfunction get(element) {\n  return element[Property.JSACTION];\n}\nfunction getDefaulted(element) {\n  const cache = get(element) ?? {};\n  set(element, cache);\n  return cache;\n}\nfunction set(element, actionMap) {\n  element[Property.JSACTION] = actionMap;\n}\nfunction getParsed(text) {\n  return parseCache[text];\n}\nfunction setParsed(text, parsed) {\n  parseCache[text] = parsed;\n}\nconst EventType = {\n  AUXCLICK: 'auxclick',\n  CHANGE: 'change',\n  CLICK: 'click',\n  CLICKMOD: 'clickmod',\n  CLICKONLY: 'clickonly',\n  DBLCLICK: 'dblclick',\n  FOCUS: 'focus',\n  FOCUSIN: 'focusin',\n  BLUR: 'blur',\n  FOCUSOUT: 'focusout',\n  SUBMIT: 'submit',\n  KEYDOWN: 'keydown',\n  KEYPRESS: 'keypress',\n  KEYUP: 'keyup',\n  MOUSEUP: 'mouseup',\n  MOUSEDOWN: 'mousedown',\n  MOUSEOVER: 'mouseover',\n  MOUSEOUT: 'mouseout',\n  MOUSEENTER: 'mouseenter',\n  MOUSELEAVE: 'mouseleave',\n  MOUSEMOVE: 'mousemove',\n  POINTERUP: 'pointerup',\n  POINTERDOWN: 'pointerdown',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  POINTERMOVE: 'pointermove',\n  POINTERCANCEL: 'pointercancel',\n  GOTPOINTERCAPTURE: 'gotpointercapture',\n  LOSTPOINTERCAPTURE: 'lostpointercapture',\n  ERROR: 'error',\n  LOAD: 'load',\n  UNLOAD: 'unload',\n  TOUCHSTART: 'touchstart',\n  TOUCHEND: 'touchend',\n  TOUCHMOVE: 'touchmove',\n  INPUT: 'input',\n  SCROLL: 'scroll',\n  TOGGLE: 'toggle',\n  CUSTOM: '_custom'\n};\nconst MOUSE_SPECIAL_EVENT_TYPES = [EventType.MOUSEENTER, EventType.MOUSELEAVE, 'pointerenter', 'pointerleave'];\nconst BUBBLE_EVENT_TYPES = [EventType.CLICK, EventType.DBLCLICK, EventType.FOCUSIN, EventType.FOCUSOUT, EventType.KEYDOWN, EventType.KEYUP, EventType.KEYPRESS, EventType.MOUSEOVER, EventType.MOUSEOUT, EventType.SUBMIT, EventType.TOUCHSTART, EventType.TOUCHEND, EventType.TOUCHMOVE, 'touchcancel', 'auxclick', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'beforeinput', 'input', 'select', 'copy', 'cut', 'paste', 'mousedown', 'mouseup', 'wheel', 'contextmenu', 'dragover', 'dragenter', 'dragleave', 'drop', 'dragstart', 'dragend', 'pointerdown', 'pointermove', 'pointerup', 'pointercancel', 'pointerover', 'pointerout', 'gotpointercapture', 'lostpointercapture', 'ended', 'loadedmetadata', 'pagehide', 'pageshow', 'visibilitychange', 'beforematch'];\nconst CAPTURE_EVENT_TYPES = [EventType.FOCUS, EventType.BLUR, EventType.ERROR, EventType.LOAD, EventType.TOGGLE];\nconst isCaptureEventType = eventType => CAPTURE_EVENT_TYPES.indexOf(eventType) >= 0;\nconst EARLY_EVENT_TYPES = /*#__PURE__*/BUBBLE_EVENT_TYPES.concat(CAPTURE_EVENT_TYPES);\nconst isEarlyEventType = eventType => EARLY_EVENT_TYPES.indexOf(eventType) >= 0;\nfunction getBrowserEventType(eventType) {\n  if (eventType === EventType.MOUSEENTER) {\n    return EventType.MOUSEOVER;\n  } else if (eventType === EventType.MOUSELEAVE) {\n    return EventType.MOUSEOUT;\n  } else if (eventType === EventType.POINTERENTER) {\n    return EventType.POINTEROVER;\n  } else if (eventType === EventType.POINTERLEAVE) {\n    return EventType.POINTEROUT;\n  }\n  return eventType;\n}\nfunction addEventListener(element, eventType, handler, passive) {\n  let capture = false;\n  if (isCaptureEventType(eventType)) {\n    capture = true;\n  }\n  const options = typeof passive === 'boolean' ? {\n    capture,\n    passive\n  } : capture;\n  element.addEventListener(eventType, handler, options);\n  return {\n    eventType,\n    handler,\n    capture,\n    passive\n  };\n}\nfunction removeEventListener(element, info) {\n  if (element.removeEventListener) {\n    const options = typeof info.passive === 'boolean' ? {\n      capture: info.capture\n    } : info.capture;\n    element.removeEventListener(info.eventType, info.handler, options);\n  } else if (element.detachEvent) {\n    element.detachEvent(`on${info.eventType}`, info.handler);\n  }\n}\nfunction preventDefault(e) {\n  e.preventDefault ? e.preventDefault() : e.returnValue = false;\n}\nlet isMac = typeof navigator !== 'undefined' && /*#__PURE__*//Macintosh/.test(navigator.userAgent);\nfunction isMiddleClick(e) {\n  return e.which === 2 || e.which == null && e.button === 4;\n}\nfunction isModifiedClickEvent(e) {\n  return isMac && e.metaKey || !isMac && e.ctrlKey || isMiddleClick(e) || e.shiftKey;\n}\nfunction isMouseSpecialEvent(e, type, element) {\n  const related = e.relatedTarget;\n  return (e.type === EventType.MOUSEOVER && type === EventType.MOUSEENTER || e.type === EventType.MOUSEOUT && type === EventType.MOUSELEAVE || e.type === EventType.POINTEROVER && type === EventType.POINTERENTER || e.type === EventType.POINTEROUT && type === EventType.POINTERLEAVE) && (!related || related !== element && !element.contains(related));\n}\nfunction createMouseSpecialEvent(e, target) {\n  const copy = {};\n  for (const property in e) {\n    if (property === 'srcElement' || property === 'target') {\n      continue;\n    }\n    const key = property;\n    const value = e[key];\n    if (typeof value === 'function') {\n      continue;\n    }\n    copy[key] = value;\n  }\n  if (e.type === EventType.MOUSEOVER) {\n    copy['type'] = EventType.MOUSEENTER;\n  } else if (e.type === EventType.MOUSEOUT) {\n    copy['type'] = EventType.MOUSELEAVE;\n  } else if (e.type === EventType.POINTEROVER) {\n    copy['type'] = EventType.POINTERENTER;\n  } else {\n    copy['type'] = EventType.POINTERLEAVE;\n  }\n  copy['target'] = copy['srcElement'] = target;\n  copy['bubbles'] = false;\n  copy['_originalEvent'] = e;\n  return copy;\n}\nconst isIos = typeof navigator !== 'undefined' && /*#__PURE__*//iPhone|iPad|iPod/.test(navigator.userAgent);\nclass EventContractContainer {\n  element;\n  handlerInfos = [];\n  constructor(element) {\n    this.element = element;\n  }\n  addEventListener(eventType, getHandler, passive) {\n    if (isIos) {\n      this.element.style.cursor = 'pointer';\n    }\n    this.handlerInfos.push(addEventListener(this.element, eventType, getHandler(this.element), passive));\n  }\n  cleanUp() {\n    for (let i = 0; i < this.handlerInfos.length; i++) {\n      removeEventListener(this.element, this.handlerInfos[i]);\n    }\n    this.handlerInfos = [];\n  }\n}\nconst Char = {\n  NAMESPACE_ACTION_SEPARATOR: '.',\n  EVENT_ACTION_SEPARATOR: ':'\n};\nfunction getEventType(eventInfo) {\n  return eventInfo.eventType;\n}\nfunction setEventType(eventInfo, eventType) {\n  eventInfo.eventType = eventType;\n}\nfunction getEvent(eventInfo) {\n  return eventInfo.event;\n}\nfunction setEvent(eventInfo, event) {\n  eventInfo.event = event;\n}\nfunction getTargetElement(eventInfo) {\n  return eventInfo.targetElement;\n}\nfunction setTargetElement(eventInfo, targetElement) {\n  eventInfo.targetElement = targetElement;\n}\nfunction getContainer(eventInfo) {\n  return eventInfo.eic;\n}\nfunction setContainer(eventInfo, container) {\n  eventInfo.eic = container;\n}\nfunction getTimestamp(eventInfo) {\n  return eventInfo.timeStamp;\n}\nfunction setTimestamp(eventInfo, timestamp) {\n  eventInfo.timeStamp = timestamp;\n}\nfunction getAction(eventInfo) {\n  return eventInfo.eia;\n}\nfunction setAction(eventInfo, actionName, actionElement) {\n  eventInfo.eia = [actionName, actionElement];\n}\nfunction unsetAction(eventInfo) {\n  eventInfo.eia = undefined;\n}\nfunction getActionElement(actionInfo) {\n  return actionInfo[1];\n}\nfunction getIsReplay(eventInfo) {\n  return eventInfo.eirp;\n}\nfunction setIsReplay(eventInfo, replay) {\n  eventInfo.eirp = replay;\n}\nfunction getResolved(eventInfo) {\n  return eventInfo.eir;\n}\nfunction setResolved(eventInfo, resolved) {\n  eventInfo.eir = resolved;\n}\nfunction cloneEventInfo(eventInfo) {\n  return {\n    eventType: eventInfo.eventType,\n    event: eventInfo.event,\n    targetElement: eventInfo.targetElement,\n    eic: eventInfo.eic,\n    eia: eventInfo.eia,\n    timeStamp: eventInfo.timeStamp,\n    eirp: eventInfo.eirp,\n    eiack: eventInfo.eiack,\n    eir: eventInfo.eir\n  };\n}\nfunction createEventInfoFromParameters(eventType, event, targetElement, container, timestamp, action, isReplay, a11yClickKey) {\n  return {\n    eventType,\n    event,\n    targetElement,\n    eic: container,\n    timeStamp: timestamp,\n    eia: action,\n    eirp: isReplay,\n    eiack: a11yClickKey\n  };\n}\nclass EventInfoWrapper {\n  eventInfo;\n  constructor(eventInfo) {\n    this.eventInfo = eventInfo;\n  }\n  getEventType() {\n    return getEventType(this.eventInfo);\n  }\n  setEventType(eventType) {\n    setEventType(this.eventInfo, eventType);\n  }\n  getEvent() {\n    return getEvent(this.eventInfo);\n  }\n  setEvent(event) {\n    setEvent(this.eventInfo, event);\n  }\n  getTargetElement() {\n    return getTargetElement(this.eventInfo);\n  }\n  setTargetElement(targetElement) {\n    setTargetElement(this.eventInfo, targetElement);\n  }\n  getContainer() {\n    return getContainer(this.eventInfo);\n  }\n  setContainer(container) {\n    setContainer(this.eventInfo, container);\n  }\n  getTimestamp() {\n    return getTimestamp(this.eventInfo);\n  }\n  setTimestamp(timestamp) {\n    setTimestamp(this.eventInfo, timestamp);\n  }\n  getAction() {\n    const action = getAction(this.eventInfo);\n    if (!action) return undefined;\n    return {\n      name: action[0],\n      element: action[1]\n    };\n  }\n  setAction(action) {\n    if (!action) {\n      unsetAction(this.eventInfo);\n      return;\n    }\n    setAction(this.eventInfo, action.name, action.element);\n  }\n  getIsReplay() {\n    return getIsReplay(this.eventInfo);\n  }\n  setIsReplay(replay) {\n    setIsReplay(this.eventInfo, replay);\n  }\n  getResolved() {\n    return getResolved(this.eventInfo);\n  }\n  setResolved(resolved) {\n    setResolved(this.eventInfo, resolved);\n  }\n  clone() {\n    return new EventInfoWrapper(cloneEventInfo(this.eventInfo));\n  }\n}\nconst EMPTY_ACTION_MAP = {};\nconst REGEXP_SEMICOLON = /\\s*;\\s*/;\nconst DEFAULT_EVENT_TYPE = EventType.CLICK;\nclass ActionResolver {\n  a11yClickSupport = false;\n  clickModSupport = true;\n  syntheticMouseEventSupport;\n  updateEventInfoForA11yClick = undefined;\n  preventDefaultForA11yClick = undefined;\n  populateClickOnlyAction = undefined;\n  constructor({\n    syntheticMouseEventSupport = false,\n    clickModSupport = true\n  } = {}) {\n    this.syntheticMouseEventSupport = syntheticMouseEventSupport;\n    this.clickModSupport = clickModSupport;\n  }\n  resolveEventType(eventInfo) {\n    if (this.clickModSupport && getEventType(eventInfo) === EventType.CLICK && isModifiedClickEvent(getEvent(eventInfo))) {\n      setEventType(eventInfo, EventType.CLICKMOD);\n    } else if (this.a11yClickSupport) {\n      this.updateEventInfoForA11yClick(eventInfo);\n    }\n  }\n  resolveAction(eventInfo) {\n    if (getResolved(eventInfo)) {\n      return;\n    }\n    this.populateAction(eventInfo, getTargetElement(eventInfo));\n    setResolved(eventInfo, true);\n  }\n  resolveParentAction(eventInfo) {\n    const action = getAction(eventInfo);\n    const actionElement = action && getActionElement(action);\n    unsetAction(eventInfo);\n    const parentNode = actionElement && this.getParentNode(actionElement);\n    if (!parentNode) {\n      return;\n    }\n    this.populateAction(eventInfo, parentNode);\n  }\n  populateAction(eventInfo, currentTarget) {\n    let actionElement = currentTarget;\n    while (actionElement && actionElement !== getContainer(eventInfo)) {\n      if (actionElement.nodeType === Node.ELEMENT_NODE) {\n        this.populateActionOnElement(actionElement, eventInfo);\n      }\n      if (getAction(eventInfo)) {\n        break;\n      }\n      actionElement = this.getParentNode(actionElement);\n    }\n    const action = getAction(eventInfo);\n    if (!action) {\n      return;\n    }\n    if (this.a11yClickSupport) {\n      this.preventDefaultForA11yClick(eventInfo);\n    }\n    if (this.syntheticMouseEventSupport) {\n      if (getEventType(eventInfo) === EventType.MOUSEENTER || getEventType(eventInfo) === EventType.MOUSELEAVE || getEventType(eventInfo) === EventType.POINTERENTER || getEventType(eventInfo) === EventType.POINTERLEAVE) {\n        if (isMouseSpecialEvent(getEvent(eventInfo), getEventType(eventInfo), getActionElement(action))) {\n          const copiedEvent = createMouseSpecialEvent(getEvent(eventInfo), getActionElement(action));\n          setEvent(eventInfo, copiedEvent);\n          setTargetElement(eventInfo, getActionElement(action));\n        } else {\n          unsetAction(eventInfo);\n        }\n      }\n    }\n  }\n  getParentNode(element) {\n    const owner = element[Property.OWNER];\n    if (owner) {\n      return owner;\n    }\n    const parentNode = element.parentNode;\n    if (parentNode?.nodeName === '#document-fragment') {\n      return parentNode?.host ?? null;\n    }\n    return parentNode;\n  }\n  populateActionOnElement(actionElement, eventInfo) {\n    const actionMap = this.parseActions(actionElement);\n    const actionName = actionMap[getEventType(eventInfo)];\n    if (actionName !== undefined) {\n      setAction(eventInfo, actionName, actionElement);\n    }\n    if (this.a11yClickSupport) {\n      this.populateClickOnlyAction(actionElement, eventInfo, actionMap);\n    }\n  }\n  parseActions(actionElement) {\n    let actionMap = get(actionElement);\n    if (!actionMap) {\n      const jsactionAttribute = actionElement.getAttribute(Attribute.JSACTION);\n      if (!jsactionAttribute) {\n        actionMap = EMPTY_ACTION_MAP;\n        set(actionElement, actionMap);\n      } else {\n        actionMap = getParsed(jsactionAttribute);\n        if (!actionMap) {\n          actionMap = {};\n          const values = jsactionAttribute.split(REGEXP_SEMICOLON);\n          for (let idx = 0; idx < values.length; idx++) {\n            const value = values[idx];\n            if (!value) {\n              continue;\n            }\n            const colon = value.indexOf(Char.EVENT_ACTION_SEPARATOR);\n            const hasColon = colon !== -1;\n            const type = hasColon ? value.substr(0, colon).trim() : DEFAULT_EVENT_TYPE;\n            const action = hasColon ? value.substr(colon + 1).trim() : value;\n            actionMap[type] = action;\n          }\n          setParsed(jsactionAttribute, actionMap);\n        }\n        set(actionElement, actionMap);\n      }\n    }\n    return actionMap;\n  }\n  addA11yClickSupport(updateEventInfoForA11yClick, preventDefaultForA11yClick, populateClickOnlyAction) {\n    this.a11yClickSupport = true;\n    this.updateEventInfoForA11yClick = updateEventInfoForA11yClick;\n    this.preventDefaultForA11yClick = preventDefaultForA11yClick;\n    this.populateClickOnlyAction = populateClickOnlyAction;\n  }\n}\nvar Restriction = /*#__PURE__*/function (Restriction) {\n  Restriction[Restriction[\"I_AM_THE_JSACTION_FRAMEWORK\"] = 0] = \"I_AM_THE_JSACTION_FRAMEWORK\";\n  return Restriction;\n}(Restriction || {});\nclass Dispatcher {\n  dispatchDelegate;\n  actionResolver;\n  eventReplayer;\n  eventReplayScheduled = false;\n  replayEventInfoWrappers = [];\n  constructor(dispatchDelegate, {\n    actionResolver,\n    eventReplayer\n  } = {}) {\n    this.dispatchDelegate = dispatchDelegate;\n    this.actionResolver = actionResolver;\n    this.eventReplayer = eventReplayer;\n  }\n  dispatch(eventInfo) {\n    const eventInfoWrapper = new EventInfoWrapper(eventInfo);\n    this.actionResolver?.resolveEventType(eventInfo);\n    this.actionResolver?.resolveAction(eventInfo);\n    const action = eventInfoWrapper.getAction();\n    if (action && shouldPreventDefaultBeforeDispatching(action.element, eventInfoWrapper)) {\n      preventDefault(eventInfoWrapper.getEvent());\n    }\n    if (this.eventReplayer && eventInfoWrapper.getIsReplay()) {\n      this.scheduleEventInfoWrapperReplay(eventInfoWrapper);\n      return;\n    }\n    this.dispatchDelegate(eventInfoWrapper);\n  }\n  scheduleEventInfoWrapperReplay(eventInfoWrapper) {\n    this.replayEventInfoWrappers.push(eventInfoWrapper);\n    if (this.eventReplayScheduled) {\n      return;\n    }\n    this.eventReplayScheduled = true;\n    Promise.resolve().then(() => {\n      this.eventReplayScheduled = false;\n      this.eventReplayer(this.replayEventInfoWrappers);\n    });\n  }\n}\nfunction shouldPreventDefaultBeforeDispatching(actionElement, eventInfoWrapper) {\n  return actionElement.tagName === 'A' && (eventInfoWrapper.getEventType() === EventType.CLICK || eventInfoWrapper.getEventType() === EventType.CLICKMOD);\n}\nconst PROPAGATION_STOPPED_SYMBOL = /* @__PURE__ */Symbol.for('propagationStopped');\nconst EventPhase = {\n  REPLAY: 101\n};\nconst PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser dispatch, `preventDefault` would have no ' + 'effect. You can check whether an event is being replayed by accessing the event phase: ' + '`event.eventPhase === EventPhase.REPLAY`.';\nconst PREVENT_DEFAULT_ERROR_MESSAGE = `\\`preventDefault\\` called during event replay.`;\nconst COMPOSED_PATH_ERROR_MESSAGE_DETAILS = ' Because event replay occurs after browser ' + 'dispatch, `composedPath()` will be empty. Iterate parent nodes from `event.target` or ' + '`event.currentTarget` if you need to check elements in the event path.';\nconst COMPOSED_PATH_ERROR_MESSAGE = `\\`composedPath\\` called during event replay.`;\nclass EventDispatcher {\n  dispatchDelegate;\n  clickModSupport;\n  actionResolver;\n  dispatcher;\n  constructor(dispatchDelegate, clickModSupport = true) {\n    this.dispatchDelegate = dispatchDelegate;\n    this.clickModSupport = clickModSupport;\n    this.actionResolver = new ActionResolver({\n      clickModSupport\n    });\n    this.dispatcher = new Dispatcher(eventInfoWrapper => {\n      this.dispatchToDelegate(eventInfoWrapper);\n    }, {\n      actionResolver: this.actionResolver\n    });\n  }\n  dispatch(eventInfo) {\n    this.dispatcher.dispatch(eventInfo);\n  }\n  dispatchToDelegate(eventInfoWrapper) {\n    if (eventInfoWrapper.getIsReplay()) {\n      prepareEventForReplay(eventInfoWrapper);\n    }\n    prepareEventForBubbling(eventInfoWrapper);\n    while (eventInfoWrapper.getAction()) {\n      prepareEventForDispatch(eventInfoWrapper);\n      if (isCaptureEventType(eventInfoWrapper.getEventType()) && eventInfoWrapper.getAction().element !== eventInfoWrapper.getTargetElement()) {\n        return;\n      }\n      this.dispatchDelegate(eventInfoWrapper.getEvent(), eventInfoWrapper.getAction().name);\n      if (propagationStopped(eventInfoWrapper)) {\n        return;\n      }\n      this.actionResolver.resolveParentAction(eventInfoWrapper.eventInfo);\n    }\n  }\n}\nfunction prepareEventForBubbling(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const originalStopPropagation = eventInfoWrapper.getEvent().stopPropagation.bind(event);\n  const stopPropagation = () => {\n    event[PROPAGATION_STOPPED_SYMBOL] = true;\n    originalStopPropagation();\n  };\n  patchEventInstance(event, 'stopPropagation', stopPropagation);\n  patchEventInstance(event, 'stopImmediatePropagation', stopPropagation);\n}\nfunction propagationStopped(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  return !!event[PROPAGATION_STOPPED_SYMBOL];\n}\nfunction prepareEventForReplay(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const target = eventInfoWrapper.getTargetElement();\n  const originalPreventDefault = event.preventDefault.bind(event);\n  patchEventInstance(event, 'target', target);\n  patchEventInstance(event, 'eventPhase', EventPhase.REPLAY);\n  patchEventInstance(event, 'preventDefault', () => {\n    originalPreventDefault();\n    throw new Error(PREVENT_DEFAULT_ERROR_MESSAGE + (ngDevMode ? PREVENT_DEFAULT_ERROR_MESSAGE_DETAILS : ''));\n  });\n  patchEventInstance(event, 'composedPath', () => {\n    throw new Error(COMPOSED_PATH_ERROR_MESSAGE + (ngDevMode ? COMPOSED_PATH_ERROR_MESSAGE_DETAILS : ''));\n  });\n}\nfunction prepareEventForDispatch(eventInfoWrapper) {\n  const event = eventInfoWrapper.getEvent();\n  const currentTarget = eventInfoWrapper.getAction()?.element;\n  if (currentTarget) {\n    patchEventInstance(event, 'currentTarget', currentTarget, {\n      configurable: true\n    });\n  }\n}\nfunction patchEventInstance(event, property, value, {\n  configurable = false\n} = {}) {\n  Object.defineProperty(event, property, {\n    value,\n    configurable\n  });\n}\nfunction registerDispatcher$1(eventContract, dispatcher) {\n  eventContract.ecrd(eventInfo => {\n    dispatcher.dispatch(eventInfo);\n  }, Restriction.I_AM_THE_JSACTION_FRAMEWORK);\n}\nfunction createEarlyJsactionData(container) {\n  const q = [];\n  const d = eventInfo => {\n    q.push(eventInfo);\n  };\n  const h = event => {\n    d(createEventInfoFromParameters(event.type, event, event.target, container, Date.now()));\n  };\n  return {\n    c: container,\n    q,\n    et: [],\n    etc: [],\n    d,\n    h\n  };\n}\nfunction addEvents(earlyJsactionData, types, capture) {\n  for (let i = 0; i < types.length; i++) {\n    const eventType = types[i];\n    const eventTypes = capture ? earlyJsactionData.etc : earlyJsactionData.et;\n    eventTypes.push(eventType);\n    earlyJsactionData.c.addEventListener(eventType, earlyJsactionData.h, capture);\n  }\n}\nfunction getQueuedEventInfos(earlyJsactionData) {\n  return earlyJsactionData?.q ?? [];\n}\nfunction registerDispatcher(earlyJsactionData, dispatcher) {\n  if (!earlyJsactionData) {\n    return;\n  }\n  earlyJsactionData.d = dispatcher;\n}\nfunction removeAllEventListeners(earlyJsactionData) {\n  if (!earlyJsactionData) {\n    return;\n  }\n  removeEventListeners(earlyJsactionData.c, earlyJsactionData.et, earlyJsactionData.h);\n  removeEventListeners(earlyJsactionData.c, earlyJsactionData.etc, earlyJsactionData.h, true);\n}\nfunction removeEventListeners(container, eventTypes, earlyEventHandler, capture) {\n  for (let i = 0; i < eventTypes.length; i++) {\n    container.removeEventListener(eventTypes[i], earlyEventHandler, capture);\n  }\n}\nconst MOUSE_SPECIAL_SUPPORT = false;\nlet EventContract = /*#__PURE__*/(() => {\n  class EventContract {\n    static MOUSE_SPECIAL_SUPPORT = MOUSE_SPECIAL_SUPPORT;\n    containerManager;\n    eventHandlers = {};\n    browserEventTypeToExtraEventTypes = {};\n    dispatcher = null;\n    queuedEventInfos = [];\n    constructor(containerManager) {\n      this.containerManager = containerManager;\n    }\n    handleEvent(eventType, event, container) {\n      const eventInfo = createEventInfoFromParameters(eventType, event, event.target, container, Date.now());\n      this.handleEventInfo(eventInfo);\n    }\n    handleEventInfo(eventInfo) {\n      if (!this.dispatcher) {\n        setIsReplay(eventInfo, true);\n        this.queuedEventInfos?.push(eventInfo);\n        return;\n      }\n      this.dispatcher(eventInfo);\n    }\n    addEvent(eventType, prefixedEventType, passive) {\n      if (eventType in this.eventHandlers || !this.containerManager) {\n        return;\n      }\n      if (!EventContract.MOUSE_SPECIAL_SUPPORT && MOUSE_SPECIAL_EVENT_TYPES.indexOf(eventType) >= 0) {\n        return;\n      }\n      const eventHandler = (eventType, event, container) => {\n        this.handleEvent(eventType, event, container);\n      };\n      this.eventHandlers[eventType] = eventHandler;\n      const browserEventType = getBrowserEventType(prefixedEventType || eventType);\n      if (browserEventType !== eventType) {\n        const eventTypes = this.browserEventTypeToExtraEventTypes[browserEventType] || [];\n        eventTypes.push(eventType);\n        this.browserEventTypeToExtraEventTypes[browserEventType] = eventTypes;\n      }\n      this.containerManager.addEventListener(browserEventType, element => {\n        return event => {\n          eventHandler(eventType, event, element);\n        };\n      }, passive);\n    }\n    replayEarlyEvents(earlyJsactionData = window._ejsa) {\n      if (!earlyJsactionData) {\n        return;\n      }\n      this.replayEarlyEventInfos(earlyJsactionData.q);\n      removeAllEventListeners(earlyJsactionData);\n      delete window._ejsa;\n    }\n    replayEarlyEventInfos(earlyEventInfos) {\n      for (let i = 0; i < earlyEventInfos.length; i++) {\n        const earlyEventInfo = earlyEventInfos[i];\n        const eventTypes = this.getEventTypesForBrowserEventType(earlyEventInfo.eventType);\n        for (let j = 0; j < eventTypes.length; j++) {\n          const eventInfo = cloneEventInfo(earlyEventInfo);\n          setEventType(eventInfo, eventTypes[j]);\n          this.handleEventInfo(eventInfo);\n        }\n      }\n    }\n    getEventTypesForBrowserEventType(browserEventType) {\n      const eventTypes = [];\n      if (this.eventHandlers[browserEventType]) {\n        eventTypes.push(browserEventType);\n      }\n      if (this.browserEventTypeToExtraEventTypes[browserEventType]) {\n        eventTypes.push(...this.browserEventTypeToExtraEventTypes[browserEventType]);\n      }\n      return eventTypes;\n    }\n    handler(eventType) {\n      return this.eventHandlers[eventType];\n    }\n    cleanUp() {\n      this.containerManager?.cleanUp();\n      this.containerManager = null;\n      this.eventHandlers = {};\n      this.browserEventTypeToExtraEventTypes = {};\n      this.dispatcher = null;\n      this.queuedEventInfos = [];\n    }\n    registerDispatcher(dispatcher, restriction) {\n      this.ecrd(dispatcher, restriction);\n    }\n    ecrd(dispatcher, restriction) {\n      this.dispatcher = dispatcher;\n      if (this.queuedEventInfos?.length) {\n        for (let i = 0; i < this.queuedEventInfos.length; i++) {\n          this.handleEventInfo(this.queuedEventInfos[i]);\n        }\n        this.queuedEventInfos = null;\n      }\n    }\n  }\n  return EventContract;\n})();\nfunction bootstrapAppScopedEarlyEventContract(container, appId, bubbleEventTypes, captureEventTypes, dataContainer = window) {\n  const earlyJsactionData = createEarlyJsactionData(container);\n  if (!dataContainer._ejsas) {\n    dataContainer._ejsas = {};\n  }\n  dataContainer._ejsas[appId] = earlyJsactionData;\n  addEvents(earlyJsactionData, bubbleEventTypes);\n  addEvents(earlyJsactionData, captureEventTypes, true);\n}\nfunction getAppScopedQueuedEventInfos(appId, dataContainer = window) {\n  return getQueuedEventInfos(dataContainer._ejsas?.[appId]);\n}\nfunction registerAppScopedDispatcher(restriction, appId, dispatcher, dataContainer = window) {\n  registerDispatcher(dataContainer._ejsas?.[appId], dispatcher);\n}\nfunction removeAllAppScopedEventListeners(appId, dataContainer = window) {\n  removeAllEventListeners(dataContainer._ejsas?.[appId]);\n}\nfunction clearAppScopedEarlyEventContract(appId, dataContainer = window) {\n  if (!dataContainer._ejsas) {\n    return;\n  }\n  dataContainer._ejsas[appId] = undefined;\n}\nexport { Attribute, EventContract, EventContractContainer, EventDispatcher, EventInfoWrapper, EventPhase, bootstrapAppScopedEarlyEventContract, clearAppScopedEarlyEventContract, getDefaulted as getActionCache, getAppScopedQueuedEventInfos, isCaptureEventType, isEarlyEventType, registerAppScopedDispatcher, registerDispatcher$1 as registerDispatcher, removeAllAppScopedEventListeners };\n//# sourceMappingURL=primitives-event-dispatch.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}