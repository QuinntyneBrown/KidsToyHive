{"ast":null,"code":"import _asyncToGenerator from \"C:/projects/KidsToyHive/src/KidsToyHive..App/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v21.0.5\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nimport { DOCUMENT, Location } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { ɵisPromise as _isPromise, ɵRuntimeError as _RuntimeError, Injectable, ɵisNgModule as _isNgModule, isStandalone, createEnvironmentInjector, InjectionToken, EventEmitter, input, inject, ViewContainerRef, ChangeDetectorRef, Directive, Input, Output, reflectComponentType, Component, ɵisInjectable as _isInjectable, runInInjectionContext, makeEnvironmentProviders, Compiler, NgModuleFactory, ɵresolveComponentResources as _resolveComponentResources, afterNextRender, signal, EnvironmentInjector, DestroyRef, untracked, ɵConsole as _Console, ɵPendingTasksInternal as _PendingTasksInternal, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, ɵformatRuntimeError as _formatRuntimeError } from '@angular/core';\nimport { isObservable, from, of, BehaviorSubject, combineLatest, EmptyError, Observable, concat, defer, pipe, throwError, EMPTY, Subject, Subscription } from 'rxjs';\nimport { first, map, switchMap, take, startWith, filter, takeUntil, mergeMap, concatMap, tap, catchError, scan, defaultIfEmpty, last as last$1, takeLast, finalize } from 'rxjs/operators';\nimport * as i1 from '@angular/platform-browser';\nconst PRIMARY_OUTLET = 'primary';\nconst RouteTitleKey = /* @__PURE__ */Symbol('RouteTitle');\nclass ParamsAsMap {\n  params;\n  constructor(params) {\n    this.params = params || {};\n  }\n  has(name) {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n  get(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n    return null;\n  }\n  getAll(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n    return [];\n  }\n  get keys() {\n    return Object.keys(this.params);\n  }\n}\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  const parts = route.path.split('/');\n  if (parts.length > segments.length) {\n    return null;\n  }\n  if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    return null;\n  }\n  const posParams = {};\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part[0] === ':';\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      return null;\n    }\n  }\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams\n  };\n}\nfunction firstValueFrom(source) {\n  return new Promise((resolve, reject) => {\n    source.pipe(first()).subscribe({\n      next: value => resolve(value),\n      error: err => reject(err)\n    });\n  });\n}\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\nfunction shallowEqual(a, b) {\n  const k1 = a ? getDataKeys(a) : undefined;\n  const k2 = b ? getDataKeys(b) : undefined;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getDataKeys(obj) {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\nfunction equalArraysOrString(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\nfunction last(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\nfunction wrapIntoObservable(value) {\n  if (isObservable(value)) {\n    return value;\n  }\n  if (_isPromise(value)) {\n    return from(Promise.resolve(value));\n  }\n  return of(value);\n}\nfunction wrapIntoPromise(value) {\n  if (isObservable(value)) {\n    return firstValueFrom(value);\n  }\n  return Promise.resolve(value);\n}\nconst pathCompareMap = {\n  'exact': equalSegmentGroups,\n  'subset': containsSegmentGroup\n};\nconst paramCompareMap = {\n  'exact': equalParams,\n  'subset': containsParams,\n  'ignored': () => true\n};\nfunction containsTree(container, containee, options) {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === 'exact' && container.fragment !== containee.fragment);\n}\nfunction equalParams(container, containee) {\n  return shallowEqual(container, containee);\n}\nfunction equalSegmentGroups(container, containee, matrixParams) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;\n  }\n  return true;\n}\nfunction containsParams(container, containee) {\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(key => equalArraysOrString(container[key], containee[key]));\n}\nfunction containsSegmentGroup(container, containee, matrixParams) {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\nclass UrlTree {\n  root;\n  queryParams;\n  fragment;\n  _queryParamMap;\n  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new _RuntimeError(4015, 'The root `UrlSegmentGroup` should not contain `segments`. ' + 'Instead, these segments belong in the `children` so they can be associated with a named outlet.');\n      }\n    }\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  toString() {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n}\nclass UrlSegmentGroup {\n  segments;\n  children;\n  parent = null;\n  constructor(segments, children) {\n    this.segments = segments;\n    this.children = children;\n    Object.values(children).forEach(v => v.parent = this);\n  }\n  hasChildren() {\n    return this.numberOfChildren > 0;\n  }\n  get numberOfChildren() {\n    return Object.keys(this.children).length;\n  }\n  toString() {\n    return serializePaths(this);\n  }\n}\nclass UrlSegment {\n  path;\n  parameters;\n  _parameterMap;\n  constructor(path, parameters) {\n    this.path = path;\n    this.parameters = parameters;\n  }\n  get parameterMap() {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n  toString() {\n    return serializePath(this);\n  }\n}\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\nfunction mapChildrenIntoArray(segment, fn) {\n  let res = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\nlet UrlSerializer = /*#__PURE__*/(() => {\n  class UrlSerializer {\n    static ɵfac = function UrlSerializer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UrlSerializer)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: UrlSerializer,\n      factory: () => (() => new DefaultUrlSerializer())(),\n      providedIn: 'root'\n    });\n  }\n  return UrlSerializer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DefaultUrlSerializer {\n  parse(url) {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n  serialize(tree) {\n    const segment = `/${serializeSegment(tree.root, true)}`;\n    const query = serializeQueryParams(tree.queryParams);\n    const fragment = typeof tree.fragment === `string` ? `#${encodeUriFragment(tree.fragment)}` : '';\n    return `${segment}${query}${fragment}`;\n  }\n}\nconst DEFAULT_SERIALIZER = /*#__PURE__*/new DefaultUrlSerializer();\nfunction serializePaths(segment) {\n  return segment.segments.map(p => serializePath(p)).join('/');\n}\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';\n    const children = [];\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n    return children.length > 0 ? `${primary}(${children.join('//')})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v, k) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n    return `${serializePaths(segment)}/(${children.join('//')})`;\n  }\n}\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');\n}\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, ';');\n}\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, '%28').replace(/\\)/g, '%29').replace(/%26/gi, '&');\n}\nfunction decode(s) {\n  return decodeURIComponent(s);\n}\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, '%20'));\n}\nfunction serializePath(path) {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\nfunction serializeMatrixParams(params) {\n  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join('');\n}\nfunction serializeQueryParams(params) {\n  const strParams = Object.entries(params).map(([name, value]) => {\n    return Array.isArray(value) ? value.map(v => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join('&') : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n  }).filter(s => s);\n  return strParams.length ? `?${strParams.join('&')}` : '';\n}\nconst SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str) {\n  const match = str.match(SEGMENT_RE);\n  return match ? match[0] : '';\n}\nconst MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str) {\n  const match = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match ? match[0] : '';\n}\nconst QUERY_PARAM_RE = /^[^=?&#]+/;\nfunction matchQueryParams(str) {\n  const match = str.match(QUERY_PARAM_RE);\n  return match ? match[0] : '';\n}\nconst QUERY_PARAM_VALUE_RE = /^[^&#]+/;\nfunction matchUrlQueryParamValue(str) {\n  const match = str.match(QUERY_PARAM_VALUE_RE);\n  return match ? match[0] : '';\n}\nclass UrlParser {\n  url;\n  remaining;\n  constructor(url) {\n    this.url = url;\n    this.remaining = url;\n  }\n  parseRootSegment() {\n    this.consumeOptional('/');\n    if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {\n      return new UrlSegmentGroup([], {});\n    }\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n  parseQueryParams() {\n    const params = {};\n    if (this.consumeOptional('?')) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional('&'));\n    }\n    return params;\n  }\n  parseFragment() {\n    return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;\n  }\n  parseChildren() {\n    if (this.remaining === '') {\n      return {};\n    }\n    this.consumeOptional('/');\n    const segments = [];\n    if (!this.peekStartsWith('(')) {\n      segments.push(this.parseSegment());\n    }\n    while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {\n      this.capture('/');\n      segments.push(this.parseSegment());\n    }\n    let children = {};\n    if (this.peekStartsWith('/(')) {\n      this.capture('/');\n      children = this.parseParens(true);\n    }\n    let res = {};\n    if (this.peekStartsWith('(')) {\n      res = this.parseParens(false);\n    }\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n    return res;\n  }\n  parseSegment() {\n    const path = matchSegments(this.remaining);\n    if (path === '' && this.peekStartsWith(';')) {\n      throw new _RuntimeError(4009, (typeof ngDevMode === 'undefined' || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n  parseMatrixParams() {\n    const params = {};\n    while (this.consumeOptional(';')) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n  parseParam(params) {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    params[decode(key)] = decode(value);\n  }\n  parseQueryParam(params) {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = '';\n    if (this.consumeOptional('=')) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n    if (params.hasOwnProperty(decodedKey)) {\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      params[decodedKey] = decodedVal;\n    }\n  }\n  parseParens(allowPrimary) {\n    const segments = {};\n    this.capture('(');\n    while (!this.consumeOptional(')') && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n      const next = this.remaining[path.length];\n      if (next !== '/' && next !== ')' && next !== ';') {\n        throw new _RuntimeError(4010, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot parse url '${this.url}'`);\n      }\n      let outletName;\n      if (path.indexOf(':') > -1) {\n        outletName = path.slice(0, path.indexOf(':'));\n        this.capture(outletName);\n        this.capture(':');\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n      const children = this.parseChildren();\n      segments[outletName ?? PRIMARY_OUTLET] = Object.keys(children).length === 1 && children[PRIMARY_OUTLET] ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n      this.consumeOptional('//');\n    }\n    return segments;\n  }\n  peekStartsWith(str) {\n    return this.remaining.startsWith(str);\n  }\n  consumeOptional(str) {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n  capture(str) {\n    if (!this.consumeOptional(str)) {\n      throw new _RuntimeError(4011, (typeof ngDevMode === 'undefined' || ngDevMode) && `Expected \"${str}\".`);\n    }\n  }\n}\nfunction createRoot(rootCandidate) {\n  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {\n    [PRIMARY_OUTLET]: rootCandidate\n  }) : rootCandidate;\n}\nfunction squashSegmentGroup(segmentGroup) {\n  const newChildren = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n  return s;\n}\nfunction isUrlTree(v) {\n  return v instanceof UrlTree;\n}\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null, urlSerializer = new DefaultUrlSerializer()) {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment, urlSerializer);\n}\nfunction createSegmentGroupFromRoute(route) {\n  let targetGroup;\n  function createSegmentGroupFromRouteRecursive(currentRoute) {\n    const childOutlets = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n  return targetGroup ?? rootSegmentGroup;\n}\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment, urlSerializer) {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment, urlSerializer);\n  }\n  const nav = computeNavigation(commands);\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment, urlSerializer);\n  }\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer);\n}\nfunction isMatrixParams(command) {\n  return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;\n}\nfunction isCommandWithOutlets(command) {\n  return typeof command === 'object' && command != null && command.outlets;\n}\nfunction normalizeQueryParams(k, v, urlSerializer) {\n  k ||= 'ɵ';\n  const tree = new UrlTree();\n  tree.queryParams = {\n    [k]: v\n  };\n  return urlSerializer.parse(urlSerializer.serialize(tree)).queryParams[k];\n}\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer) {\n  const qp = {};\n  for (const [key, value] of Object.entries(queryParams ?? {})) {\n    qp[key] = Array.isArray(value) ? value.map(v => normalizeQueryParams(key, v, urlSerializer)) : normalizeQueryParams(key, value, urlSerializer);\n  }\n  let rootCandidate;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\nfunction replaceSegment(current, oldSegment, newSegment) {\n  const children = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\nclass Navigation {\n  isAbsolute;\n  numberOfDoubleDots;\n  commands;\n  constructor(isAbsolute, numberOfDoubleDots, commands) {\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new _RuntimeError(4003, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Root segment cannot have matrix parameters');\n    }\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last(commands)) {\n      throw new _RuntimeError(4004, (typeof ngDevMode === 'undefined' || ngDevMode) && '{outlets:{}} has to be the last command');\n    }\n  }\n  toRoot() {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';\n  }\n}\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === 'string' && commands.length === 1 && commands[0] === '/') {\n    return new Navigation(true, 0, commands);\n  }\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n  const res = commands.reduce((res, cmd, cmdIdx) => {\n    if (typeof cmd === 'object' && cmd != null) {\n      if (cmd.outlets) {\n        const outlets = {};\n        Object.entries(cmd.outlets).forEach(([name, commands]) => {\n          outlets[name] = typeof commands === 'string' ? commands.split('/') : commands;\n        });\n        return [...res, {\n          outlets\n        }];\n      }\n      if (cmd.segmentPath) {\n        return [...res, cmd.segmentPath];\n      }\n    }\n    if (!(typeof cmd === 'string')) {\n      return [...res, cmd];\n    }\n    if (cmdIdx === 0) {\n      cmd.split('/').forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === '.') ;else if (partIndex == 0 && urlPart === '') {\n          isAbsolute = true;\n        } else if (urlPart === '..') {\n          numberOfDoubleDots++;\n        } else if (urlPart != '') {\n          res.push(urlPart);\n        }\n      });\n      return res;\n    }\n    return [...res, cmd];\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nclass Position {\n  segmentGroup;\n  processChildren;\n  index;\n  constructor(segmentGroup, processChildren, index) {\n    this.segmentGroup = segmentGroup;\n    this.processChildren = processChildren;\n    this.index = index;\n  }\n}\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n  if (!target) {\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent;\n    if (!g) {\n      throw new _RuntimeError(4005, (typeof ngDevMode === 'undefined' || ngDevMode) && \"Invalid number of '../'\");\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\nfunction getOutlets(commands) {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n  return {\n    [PRIMARY_OUTLET]: commands\n  };\n}\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children = {};\n    if (Object.keys(outlets).some(o => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n    Object.entries(outlets).forEach(([outlet, commands]) => {\n      if (typeof commands === 'string') {\n        commands = [commands];\n      }\n      if (commands !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);\n      }\n    });\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === undefined) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n  const noMatch = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === undefined) break;\n    if (curr && next && typeof next === 'object' && next.outlets === undefined) {\n      if (!compare(curr, next, path)) return noMatch;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify(commands[0])));\n      i++;\n      continue;\n    }\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\nfunction createNewSegmentChildren(outlets) {\n  const children = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === 'string') {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\nfunction stringify(params) {\n  const res = {};\n  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);\n  return res;\n}\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\nconst IMPERATIVE_NAVIGATION = 'imperative';\nvar EventType = /*#__PURE__*/function (EventType) {\n  EventType[EventType[\"NavigationStart\"] = 0] = \"NavigationStart\";\n  EventType[EventType[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\n  EventType[EventType[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\n  EventType[EventType[\"NavigationError\"] = 3] = \"NavigationError\";\n  EventType[EventType[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\n  EventType[EventType[\"ResolveStart\"] = 5] = \"ResolveStart\";\n  EventType[EventType[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\n  EventType[EventType[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\n  EventType[EventType[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\n  EventType[EventType[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\n  EventType[EventType[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\n  EventType[EventType[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\n  EventType[EventType[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\n  EventType[EventType[\"ActivationStart\"] = 13] = \"ActivationStart\";\n  EventType[EventType[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\n  EventType[EventType[\"Scroll\"] = 15] = \"Scroll\";\n  EventType[EventType[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\n  return EventType;\n}(EventType || {});\nclass RouterEvent {\n  id;\n  url;\n  constructor(id, url) {\n    this.id = id;\n    this.url = url;\n  }\n}\nclass NavigationStart extends RouterEvent {\n  type = EventType.NavigationStart;\n  navigationTrigger;\n  restoredState;\n  constructor(id, url, navigationTrigger = 'imperative', restoredState = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n  toString() {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n}\nclass NavigationEnd extends RouterEvent {\n  urlAfterRedirects;\n  type = EventType.NavigationEnd;\n  constructor(id, url, urlAfterRedirects) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n  }\n  toString() {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n}\nvar NavigationCancellationCode = /*#__PURE__*/function (NavigationCancellationCode) {\n  NavigationCancellationCode[NavigationCancellationCode[\"Redirect\"] = 0] = \"Redirect\";\n  NavigationCancellationCode[NavigationCancellationCode[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\n  NavigationCancellationCode[NavigationCancellationCode[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\n  NavigationCancellationCode[NavigationCancellationCode[\"GuardRejected\"] = 3] = \"GuardRejected\";\n  NavigationCancellationCode[NavigationCancellationCode[\"Aborted\"] = 4] = \"Aborted\";\n  return NavigationCancellationCode;\n}(NavigationCancellationCode || {});\nvar NavigationSkippedCode = /*#__PURE__*/function (NavigationSkippedCode) {\n  NavigationSkippedCode[NavigationSkippedCode[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\n  NavigationSkippedCode[NavigationSkippedCode[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\n  return NavigationSkippedCode;\n}(NavigationSkippedCode || {});\nclass NavigationCancel extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationCancel;\n  constructor(id, url, reason, code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n  toString() {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n}\nclass NavigationSkipped extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationSkipped;\n  constructor(id, url, reason, code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n}\nclass NavigationError extends RouterEvent {\n  error;\n  target;\n  type = EventType.NavigationError;\n  constructor(id, url, error, target) {\n    super(id, url);\n    this.error = error;\n    this.target = target;\n  }\n  toString() {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n}\nclass RoutesRecognized extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.RoutesRecognized;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass GuardsCheckStart extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.GuardsCheckStart;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass GuardsCheckEnd extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  shouldActivate;\n  type = EventType.GuardsCheckEnd;\n  constructor(id, url, urlAfterRedirects, state, shouldActivate) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n    this.shouldActivate = shouldActivate;\n  }\n  toString() {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n}\nclass ResolveStart extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveStart;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass ResolveEnd extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveEnd;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n}\nclass RouteConfigLoadStart {\n  route;\n  type = EventType.RouteConfigLoadStart;\n  constructor(route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n}\nclass RouteConfigLoadEnd {\n  route;\n  type = EventType.RouteConfigLoadEnd;\n  constructor(route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n}\nclass ChildActivationStart {\n  snapshot;\n  type = EventType.ChildActivationStart;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationStart(path: '${path}')`;\n  }\n}\nclass ChildActivationEnd {\n  snapshot;\n  type = EventType.ChildActivationEnd;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n}\nclass ActivationStart {\n  snapshot;\n  type = EventType.ActivationStart;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationStart(path: '${path}')`;\n  }\n}\nclass ActivationEnd {\n  snapshot;\n  type = EventType.ActivationEnd;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';\n    return `ActivationEnd(path: '${path}')`;\n  }\n}\nclass Scroll {\n  routerEvent;\n  position;\n  anchor;\n  type = EventType.Scroll;\n  constructor(routerEvent, position, anchor) {\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n  }\n  toString() {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n}\nclass BeforeActivateRoutes {}\nclass RedirectRequest {\n  url;\n  navigationBehaviorOptions;\n  constructor(url, navigationBehaviorOptions) {\n    this.url = url;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n}\nfunction isPublicRouterEvent(e) {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\nfunction stringifyEvent(routerEvent) {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ''}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n  }\n  return route._injector ?? currentInjector;\n}\nfunction validateConfig(config, parentPath = '', requireStandaloneComponents = false) {\n  for (let i = 0; i < config.length; i++) {\n    const route = config[i];\n    const fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\nfunction assertStandalone(fullPath, component) {\n  if (component && _isNgModule(component)) {\n    throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, ` + `but it must be used with standalone components. Use 'loadChildren' instead.`);\n  } else if (component && !isStandalone(component)) {\n    throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n  }\n}\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (!route) {\n      throw new _RuntimeError(4014, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n    }\n    if (Array.isArray(route)) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n    }\n    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n    }\n    if (route.redirectTo && route.children) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n    }\n    if (route.children && route.loadChildren) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n    }\n    if (route.component && route.loadComponent) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\n    }\n    if (route.redirectTo) {\n      if (route.component || route.loadComponent) {\n        throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\n      }\n      if (route.canMatch || route.canActivate) {\n        throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? 'canMatch' : 'canActivate'} cannot be used together.` + `Redirects happen before guards are executed.`);\n      }\n    }\n    if (route.path && route.matcher) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n    }\n    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n      throw new _RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n    }\n    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new _RuntimeError(4014, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\nfunction sortByMatchingOutlets(routes, outletName) {\n  const sortedConfig = routes.filter(r => getOutlet(r) === outletName);\n  sortedConfig.push(...routes.filter(r => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\nfunction getClosestRouteInjector(snapshot) {\n  if (!snapshot) return null;\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n  return null;\n}\nclass OutletContext {\n  rootInjector;\n  outlet = null;\n  route = null;\n  children;\n  attachRef = null;\n  get injector() {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n  constructor(rootInjector) {\n    this.rootInjector = rootInjector;\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n}\nlet ChildrenOutletContexts = /*#__PURE__*/(() => {\n  class ChildrenOutletContexts {\n    rootInjector;\n    contexts = new Map();\n    constructor(rootInjector) {\n      this.rootInjector = rootInjector;\n    }\n    onChildOutletCreated(childName, outlet) {\n      const context = this.getOrCreateContext(childName);\n      context.outlet = outlet;\n      this.contexts.set(childName, context);\n    }\n    onChildOutletDestroyed(childName) {\n      const context = this.getContext(childName);\n      if (context) {\n        context.outlet = null;\n        context.attachRef = null;\n      }\n    }\n    onOutletDeactivated() {\n      const contexts = this.contexts;\n      this.contexts = new Map();\n      return contexts;\n    }\n    onOutletReAttached(contexts) {\n      this.contexts = contexts;\n    }\n    getOrCreateContext(childName) {\n      let context = this.getContext(childName);\n      if (!context) {\n        context = new OutletContext(this.rootInjector);\n        this.contexts.set(childName, context);\n      }\n      return context;\n    }\n    getContext(childName) {\n      return this.contexts.get(childName) || null;\n    }\n    static ɵfac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ChildrenOutletContexts)(i0.ɵɵinject(i0.EnvironmentInjector));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ChildrenOutletContexts,\n      factory: ChildrenOutletContexts.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ChildrenOutletContexts;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass Tree {\n  _root;\n  constructor(root) {\n    this._root = root;\n  }\n  get root() {\n    return this._root.value;\n  }\n  parent(t) {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n  children(t) {\n    const n = findNode(t, this._root);\n    return n ? n.children.map(t => t.value) : [];\n  }\n  firstChild(t) {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n  siblings(t) {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n    const c = p[p.length - 2].children.map(c => c.value);\n    return c.filter(cc => cc !== t);\n  }\n  pathFromRoot(t) {\n    return findPath(t, this._root).map(s => s.value);\n  }\n}\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n  for (const child of node.children) {\n    const node = findNode(value, child);\n    if (node) return node;\n  }\n  return null;\n}\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n  return [];\n}\nclass TreeNode {\n  value;\n  children;\n  constructor(value, children) {\n    this.value = value;\n    this.children = children;\n  }\n  toString() {\n    return `TreeNode(${this.value})`;\n  }\n}\nfunction nodeChildrenAsMap(node) {\n  const map = {};\n  if (node) {\n    node.children.forEach(child => map[child.value.outlet] = child);\n  }\n  return map;\n}\nclass RouterState extends Tree {\n  snapshot;\n  constructor(root, snapshot) {\n    super(root);\n    this.snapshot = snapshot;\n    setRouterState(this, root);\n  }\n  toString() {\n    return this.snapshot.toString();\n  }\n}\nfunction createEmptyState(rootComponent) {\n  const snapshot = createEmptyStateSnapshot(rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject('');\n  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\nfunction createEmptyStateSnapshot(rootComponent) {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = '';\n  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});\n  return new RouterStateSnapshot('', new TreeNode(activated, []));\n}\nclass ActivatedRoute {\n  urlSubject;\n  paramsSubject;\n  queryParamsSubject;\n  fragmentSubject;\n  dataSubject;\n  outlet;\n  component;\n  snapshot;\n  _futureSnapshot;\n  _routerState;\n  _paramMap;\n  _queryParamMap;\n  title;\n  url;\n  params;\n  queryParams;\n  fragment;\n  data;\n  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {\n    this.urlSubject = urlSubject;\n    this.paramsSubject = paramsSubject;\n    this.queryParamsSubject = queryParamsSubject;\n    this.fragmentSubject = fragmentSubject;\n    this.dataSubject = dataSubject;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map(d => d[RouteTitleKey])) ?? of(undefined);\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n  get routeConfig() {\n    return this._futureSnapshot.routeConfig;\n  }\n  get root() {\n    return this._routerState.root;\n  }\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  get children() {\n    return this._routerState.children(this);\n  }\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  get paramMap() {\n    this._paramMap ??= this.params.pipe(map(p => convertToParamMap(p)));\n    return this._paramMap;\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= this.queryParams.pipe(map(p => convertToParamMap(p)));\n    return this._queryParamMap;\n  }\n  toString() {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n}\nfunction getInherited(route, parent, paramsInheritanceStrategy = 'emptyOnly') {\n  let inherited;\n  const {\n    routeConfig\n  } = route;\n  if (parent !== null && (paramsInheritanceStrategy === 'always' || routeConfig?.path === '' || !parent.component && !parent.routeConfig?.loadComponent)) {\n    inherited = {\n      params: {\n        ...parent.params,\n        ...route.params\n      },\n      data: {\n        ...parent.data,\n        ...route.data\n      },\n      resolve: {\n        ...route.data,\n        ...parent.data,\n        ...routeConfig?.data,\n        ...route._resolvedData\n      }\n    };\n  } else {\n    inherited = {\n      params: {\n        ...route.params\n      },\n      data: {\n        ...route.data\n      },\n      resolve: {\n        ...route.data,\n        ...(route._resolvedData ?? {})\n      }\n    };\n  }\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\nclass ActivatedRouteSnapshot {\n  url;\n  params;\n  queryParams;\n  fragment;\n  data;\n  outlet;\n  component;\n  routeConfig;\n  _resolve;\n  _resolvedData;\n  _routerState;\n  _paramMap;\n  _queryParamMap;\n  get title() {\n    return this.data?.[RouteTitleKey];\n  }\n  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n  get root() {\n    return this._routerState.root;\n  }\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  get children() {\n    return this._routerState.children(this);\n  }\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  get paramMap() {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  toString() {\n    const url = this.url.map(segment => segment.toString()).join('/');\n    const matched = this.routeConfig ? this.routeConfig.path : '';\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n}\nclass RouterStateSnapshot extends Tree {\n  url;\n  constructor(url, root) {\n    super(root);\n    this.url = url;\n    setRouterState(this, root);\n  }\n  toString() {\n    return serializeNode(this._root);\n  }\n}\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach(c => setRouterState(state, c));\n}\nfunction serializeNode(node) {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(', ')} } ` : '';\n  return `${node.value}${c}`;\n}\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\nfunction equalParamsAndUrlSegments(a, b) {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));\n}\nfunction hasStaticTitle(config) {\n  return typeof config.title === 'string' || config.title === null;\n}\nconst ROUTER_OUTLET_DATA = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RouterOutlet data' : '');\nlet RouterOutlet = /*#__PURE__*/(() => {\n  class RouterOutlet {\n    activated = null;\n    get activatedComponentRef() {\n      return this.activated;\n    }\n    _activatedRoute = null;\n    name = PRIMARY_OUTLET;\n    activateEvents = new EventEmitter();\n    deactivateEvents = new EventEmitter();\n    attachEvents = new EventEmitter();\n    detachEvents = new EventEmitter();\n    routerOutletData = input(...(ngDevMode ? [undefined, {\n      debugName: \"routerOutletData\"\n    }] : []));\n    parentContexts = inject(ChildrenOutletContexts);\n    location = inject(ViewContainerRef);\n    changeDetector = inject(ChangeDetectorRef);\n    inputBinder = inject(INPUT_BINDER, {\n      optional: true\n    });\n    supportsBindingToComponentInputs = true;\n    ngOnChanges(changes) {\n      if (changes['name']) {\n        const {\n          firstChange,\n          previousValue\n        } = changes['name'];\n        if (firstChange) {\n          return;\n        }\n        if (this.isTrackedInParentContexts(previousValue)) {\n          this.deactivate();\n          this.parentContexts.onChildOutletDestroyed(previousValue);\n        }\n        this.initializeOutletWithName();\n      }\n    }\n    ngOnDestroy() {\n      if (this.isTrackedInParentContexts(this.name)) {\n        this.parentContexts.onChildOutletDestroyed(this.name);\n      }\n      this.inputBinder?.unsubscribeFromRouteData(this);\n    }\n    isTrackedInParentContexts(outletName) {\n      return this.parentContexts.getContext(outletName)?.outlet === this;\n    }\n    ngOnInit() {\n      this.initializeOutletWithName();\n    }\n    initializeOutletWithName() {\n      this.parentContexts.onChildOutletCreated(this.name, this);\n      if (this.activated) {\n        return;\n      }\n      const context = this.parentContexts.getContext(this.name);\n      if (context?.route) {\n        if (context.attachRef) {\n          this.attach(context.attachRef, context.route);\n        } else {\n          this.activateWith(context.route, context.injector);\n        }\n      }\n    }\n    get isActivated() {\n      return !!this.activated;\n    }\n    get component() {\n      if (!this.activated) throw new _RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n      return this.activated.instance;\n    }\n    get activatedRoute() {\n      if (!this.activated) throw new _RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n      return this._activatedRoute;\n    }\n    get activatedRouteData() {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n      return {};\n    }\n    detach() {\n      if (!this.activated) throw new _RuntimeError(4012, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Outlet is not activated');\n      this.location.detach();\n      const cmp = this.activated;\n      this.activated = null;\n      this._activatedRoute = null;\n      this.detachEvents.emit(cmp.instance);\n      return cmp;\n    }\n    attach(ref, activatedRoute) {\n      this.activated = ref;\n      this._activatedRoute = activatedRoute;\n      this.location.insert(ref.hostView);\n      this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n      this.attachEvents.emit(ref.instance);\n    }\n    deactivate() {\n      if (this.activated) {\n        const c = this.component;\n        this.activated.destroy();\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n      }\n    }\n    activateWith(activatedRoute, environmentInjector) {\n      if (this.isActivated) {\n        throw new _RuntimeError(4013, (typeof ngDevMode === 'undefined' || ngDevMode) && 'Cannot activate an already activated outlet');\n      }\n      this._activatedRoute = activatedRoute;\n      const location = this.location;\n      const snapshot = activatedRoute.snapshot;\n      const component = snapshot.component;\n      const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n      const injector = new OutletInjector(activatedRoute, childContexts, location.injector, this.routerOutletData);\n      this.activated = location.createComponent(component, {\n        index: location.length,\n        injector,\n        environmentInjector: environmentInjector\n      });\n      this.changeDetector.markForCheck();\n      this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n      this.activateEvents.emit(this.activated.instance);\n    }\n    static ɵfac = function RouterOutlet_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterOutlet)();\n    };\n    static ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: RouterOutlet,\n      selectors: [[\"router-outlet\"]],\n      inputs: {\n        name: \"name\",\n        routerOutletData: [1, \"routerOutletData\"]\n      },\n      outputs: {\n        activateEvents: \"activate\",\n        deactivateEvents: \"deactivate\",\n        attachEvents: \"attach\",\n        detachEvents: \"detach\"\n      },\n      exportAs: [\"outlet\"],\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return RouterOutlet;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass OutletInjector {\n  route;\n  childContexts;\n  parent;\n  outletData;\n  constructor(route, childContexts, parent, outletData) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n    this.outletData = outletData;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n    return this.parent.get(token, notFoundValue);\n  }\n}\nconst INPUT_BINDER = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Router Input Binder' : '');\nlet RoutedComponentInputBinder = /*#__PURE__*/(() => {\n  class RoutedComponentInputBinder {\n    outletDataSubscriptions = new Map();\n    bindActivatedRouteToOutletComponent(outlet) {\n      this.unsubscribeFromRouteData(outlet);\n      this.subscribeToRouteData(outlet);\n    }\n    unsubscribeFromRouteData(outlet) {\n      this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n      this.outletDataSubscriptions.delete(outlet);\n    }\n    subscribeToRouteData(outlet) {\n      const {\n        activatedRoute\n      } = outlet;\n      const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {\n        data = {\n          ...queryParams,\n          ...params,\n          ...data\n        };\n        if (index === 0) {\n          return of(data);\n        }\n        return Promise.resolve(data);\n      })).subscribe(data => {\n        if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n        const mirror = reflectComponentType(activatedRoute.component);\n        if (!mirror) {\n          this.unsubscribeFromRouteData(outlet);\n          return;\n        }\n        for (const {\n          templateName\n        } of mirror.inputs) {\n          outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n        }\n      });\n      this.outletDataSubscriptions.set(outlet, dataSubscription);\n    }\n    static ɵfac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RoutedComponentInputBinder)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RoutedComponentInputBinder,\n      factory: RoutedComponentInputBinder.ɵfac\n    });\n  }\n  return RoutedComponentInputBinder;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ɵEmptyOutletComponent = /*#__PURE__*/(() => {\n  class ɵEmptyOutletComponent {\n    static ɵfac = function ɵEmptyOutletComponent_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || ɵEmptyOutletComponent)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: ɵEmptyOutletComponent,\n      selectors: [[\"ng-component\"]],\n      exportAs: [\"emptyRouterOutlet\"],\n      decls: 1,\n      vars: 0,\n      template: function _EmptyOutletComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"router-outlet\");\n        }\n      },\n      dependencies: [RouterOutlet],\n      encapsulation: 2\n    });\n  }\n  return ɵEmptyOutletComponent;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction standardizeConfig(r) {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {\n    ...r,\n    children\n  } : {\n    ...r\n  };\n  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = ɵEmptyOutletComponent;\n  }\n  return c;\n}\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);\n  return new RouterState(root, curr);\n}\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree = detachedRouteHandle.route;\n        tree.value._futureSnapshot = curr.value;\n        tree.children = curr.children.map(c => createNode(routeReuseStrategy, c));\n        return tree;\n      }\n    }\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map(c => createNode(routeReuseStrategy, c));\n    return new TreeNode(value, children);\n  }\n}\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map(child => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\nclass RedirectCommand {\n  redirectTo;\n  navigationBehaviorOptions;\n  constructor(redirectTo, navigationBehaviorOptions) {\n    this.redirectTo = redirectTo;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n}\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\nfunction redirectingNavigationError(urlSerializer, redirect) {\n  const {\n    redirectTo,\n    navigationBehaviorOptions\n  } = isUrlTree(redirect) ? {\n    redirectTo: redirect,\n    navigationBehaviorOptions: undefined\n  } : redirect;\n  const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\nfunction navigationCancelingError(message, code) {\n  const error = new Error(`NavigationCancelingError: ${message || ''}`);\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\nfunction isRedirectingNavigationCancelingError(error) {\n  return isNavigationCancelingError(error) && isUrlTree(error.url);\n}\nfunction isNavigationCancelingError(error) {\n  return !!error && error[NAVIGATION_CANCELING_ERROR];\n}\nlet warnedAboutUnsupportedInputBinding = false;\nconst activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map(t => {\n  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);\n  return t;\n});\nclass ActivateRoutes {\n  routeReuseStrategy;\n  futureState;\n  currState;\n  forwardEvent;\n  inputBindingEnabled;\n  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n    this.inputBindingEnabled = inputBindingEnabled;\n  }\n  activate(parentContexts) {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n  deactivateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n    Object.values(children).forEach(v => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n  deactivateRoutes(futureNode, currNode, parentContext) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    if (future === curr) {\n      if (future.component) {\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n  deactivateRouteAndItsChildren(route, parentContexts) {\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n  detachAndStoreRouteSubtree(route, parentContexts) {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {\n        componentRef,\n        route,\n        contexts\n      });\n    }\n  }\n  deactivateRouteAndOutlet(route, parentContexts) {\n    const context = parentContexts.getContext(route.value.outlet);\n    const contexts = context && route.value.component ? context.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context) {\n      if (context.outlet) {\n        context.outlet.deactivate();\n        context.children.onOutletDeactivated();\n      }\n      context.attachRef = null;\n      context.route = null;\n    }\n  }\n  activateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n  activateRoutes(futureNode, currNode, parentContexts) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    advanceActivatedRoute(future);\n    if (future === curr) {\n      if (future.component) {\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = this.routeReuseStrategy.retrieve(future.snapshot);\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context.children);\n        } else {\n          context.attachRef = null;\n          context.route = future;\n          if (context.outlet) {\n            context.outlet.activateWith(future, context.injector);\n          }\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const context = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context.outlet;\n      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {\n        console.warn(`'withComponentInputBinding' feature is enabled but ` + `this application is using an outlet that may not support binding to component inputs.`);\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n}\nclass CanActivate {\n  path;\n  route;\n  constructor(path) {\n    this.path = path;\n    this.route = this.path[this.path.length - 1];\n  }\n}\nclass CanDeactivate {\n  component;\n  route;\n  constructor(component, route) {\n    this.component = component;\n    this.route = route;\n  }\n}\nfunction getAllRouteGuards(future, curr, parentContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\nfunction getCanActivateChild(p) {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {\n    node: p,\n    guards: canActivateChild\n  };\n}\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n  const NOT_FOUND = Symbol();\n  const result = injector.get(tokenOrFunction, NOT_FOUND);\n  if (result === NOT_FOUND) {\n    if (typeof tokenOrFunction === 'function' && !_isInjectable(tokenOrFunction)) {\n      return tokenOrFunction;\n    } else {\n      return injector.get(tokenOrFunction);\n    }\n  }\n  return result;\n}\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const prevChildren = nodeChildrenAsMap(currNode);\n  futureNode.children.forEach(c => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\n  return checks;\n}\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n    if (future.component) {\n      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n    if (shouldRun && context && context.outlet && context.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context, checks);\n    }\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n  return checks;\n}\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n  if (typeof mode === 'function') {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case 'pathParamsChange':\n      return !equalPath(curr.url, future.url);\n    case 'pathParamsOrQueryParamsChange':\n      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);\n    case 'always':\n      return true;\n    case 'paramsOrQueryParamsChange':\n      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n    case 'paramsChange':\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\nfunction deactivateRouteAndItsChildren(route, context, checks) {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context, checks);\n    } else if (context) {\n      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context && context.outlet && context.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\nfunction isFunction(v) {\n  return typeof v === 'function';\n}\nfunction isBoolean(v) {\n  return typeof v === 'boolean';\n}\nfunction isCanLoad(guard) {\n  return guard && isFunction(guard.canLoad);\n}\nfunction isCanActivate(guard) {\n  return guard && isFunction(guard.canActivate);\n}\nfunction isCanActivateChild(guard) {\n  return guard && isFunction(guard.canActivateChild);\n}\nfunction isCanDeactivate(guard) {\n  return guard && isFunction(guard.canDeactivate);\n}\nfunction isCanMatch(guard) {\n  return guard && isFunction(guard.canMatch);\n}\nfunction isEmptyError(e) {\n  return e instanceof EmptyError || e?.name === 'EmptyError';\n}\nconst INITIAL_VALUE = /* @__PURE__ */Symbol('INITIAL_VALUE');\nfunction prioritizedGuardValue() {\n  return switchMap(obs => {\n    return combineLatest(obs.map(o => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map(results => {\n      for (const result of results) {\n        if (result === true) {\n          continue;\n        } else if (result === INITIAL_VALUE) {\n          return INITIAL_VALUE;\n        } else if (result === false || isRedirect(result)) {\n          return result;\n        }\n      }\n      return true;\n    }), filter(item => item !== INITIAL_VALUE), take(1));\n  });\n}\nfunction isRedirect(val) {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\nfunction abortSignalToObservable(signal) {\n  if (signal.aborted) {\n    return of(undefined).pipe(take(1));\n  }\n  return new Observable(subscriber => {\n    const handler = () => {\n      subscriber.next();\n      subscriber.complete();\n    };\n    signal.addEventListener('abort', handler);\n    return () => signal.removeEventListener('abort', handler);\n  });\n}\nfunction takeUntilAbort(signal) {\n  return takeUntil(abortSignalToObservable(signal));\n}\nfunction checkGuards(injector, forwardEvent) {\n  return mergeMap(t => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {\n        canActivateChecks,\n        canDeactivateChecks\n      }\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of({\n        ...t,\n        guardsResult: true\n      });\n    }\n    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap(canDeactivate => {\n      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);\n    }), map(guardsResult => ({\n      ...t,\n      guardsResult\n    })));\n  });\n}\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\n  return from(checks).pipe(mergeMap(check => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first(result => {\n    return result !== true;\n  }, true));\n}\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\n  return from(checks).pipe(concatMap(check => {\n    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\n  }), first(result => {\n    return result !== true;\n  }, true));\n}\nfunction fireActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction runCanActivate(futureRSS, futureARS, injector) {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n  const canActivateObservables = canActivate.map(canActivate => {\n    return defer(() => {\n      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n      const guard = getTokenOrFunctionIdentity(canActivate, closestInjector);\n      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanActivateChild(futureRSS, path, injector) {\n  const futureARS = path[path.length - 1];\n  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(p => getCanActivateChild(p)).filter(_ => _ !== null);\n  const canActivateChildGuardsMapped = canActivateChildGuards.map(d => {\n    return defer(() => {\n      const guardsMapped = d.guards.map(canActivateChild => {\n        const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map(c => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity(c, closestInjector);\n    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanLoadGuards(injector, route, segments, urlSerializer, abortSignal) {\n  const canLoad = route.canLoad;\n  if (canLoad === undefined || canLoad.length === 0) {\n    return of(true);\n  }\n  const canLoadObservables = canLoad.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    const obs$ = wrapIntoObservable(guardVal);\n    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;\n  });\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nfunction redirectIfUrlTree(urlSerializer) {\n  return pipe(tap(result => {\n    if (typeof result === 'boolean') return;\n    throw redirectingNavigationError(urlSerializer, result);\n  }), map(result => result === true));\n}\nfunction runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal) {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n  const canMatchObservables = canMatch.map(injectionToken => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    let obs$ = wrapIntoObservable(guardVal);\n    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;\n  });\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nlet NoMatch$1 = class NoMatch extends Error {\n  segmentGroup;\n  constructor(segmentGroup) {\n    super();\n    this.segmentGroup = segmentGroup || null;\n    Object.setPrototypeOf(this, NoMatch.prototype);\n  }\n};\nlet AbsoluteRedirect$1 = class AbsoluteRedirect extends Error {\n  urlTree;\n  constructor(urlTree) {\n    super();\n    this.urlTree = urlTree;\n    Object.setPrototypeOf(this, AbsoluteRedirect.prototype);\n  }\n};\nfunction namedOutletsRedirect$1(redirectTo) {\n  throw new _RuntimeError(4000, (typeof ngDevMode === 'undefined' || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`);\n}\nfunction canLoadFails$1(route) {\n  throw navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected);\n}\nlet ApplyRedirects$1 = class ApplyRedirects {\n  urlSerializer;\n  urlTree;\n  constructor(urlSerializer, urlTree) {\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n  }\n  lineralizeSegments(route, urlTree) {\n    return _asyncToGenerator(function* () {\n      let res = [];\n      let c = urlTree.root;\n      while (true) {\n        res = res.concat(c.segments);\n        if (c.numberOfChildren === 0) {\n          return res;\n        }\n        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n          throw namedOutletsRedirect$1(`${route.redirectTo}`);\n        }\n        c = c.children[PRIMARY_OUTLET];\n      }\n    })();\n  }\n  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const redirect = yield getRedirectResult$1(redirectTo, currentSnapshot, injector);\n      if (redirect instanceof UrlTree) {\n        throw new AbsoluteRedirect$1(redirect);\n      }\n      const newTree = _this.applyRedirectCreateUrlTree(redirect, _this.urlSerializer.parse(redirect), segments, posParams);\n      if (redirect[0] === '/') {\n        throw new AbsoluteRedirect$1(newTree);\n      }\n      return newTree;\n    })();\n  }\n  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n  }\n  createQueryParams(redirectToParams, actualParams) {\n    const res = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n  createSegmentGroup(redirectTo, group, segments, posParams) {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n    let children = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n    return redirectToSegments.map(s => s.path[0] === ':' ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));\n  }\n  findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos) throw new _RuntimeError(4001, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n  findOrReturn(redirectToUrlSegment, actualSegments) {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n};\nfunction getRedirectResult$1(redirectTo, currentSnapshot, injector) {\n  if (typeof redirectTo === 'string') {\n    return Promise.resolve(redirectTo);\n  }\n  const redirectToFn = redirectTo;\n  const {\n    queryParams,\n    fragment,\n    routeConfig,\n    url,\n    outlet,\n    params,\n    data,\n    title\n  } = currentSnapshot;\n  return firstValueFrom(wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({\n    params,\n    data,\n    queryParams,\n    fragment,\n    routeConfig,\n    url,\n    outlet,\n    title\n  }))));\n}\nconst noMatch$1 = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer, abortSignal) {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal).pipe(map(v => v === true ? result : {\n    ...noMatch$1\n  }));\n}\nfunction match(segmentGroup, route, segments) {\n  if (route.path === '**') {\n    return createWildcardMatchResult(segments);\n  }\n  if (route.path === '') {\n    if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {\n        ...noMatch$1\n      };\n    }\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return {\n    ...noMatch$1\n  };\n  const posParams = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters = res.consumed.length > 0 ? {\n    ...posParams,\n    ...res.consumed[res.consumed.length - 1].parameters\n  } : posParams;\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    parameters,\n    positionalParamSegments: res.posParams ?? {}\n  };\n}\nfunction createWildcardMatchResult(segments) {\n  return {\n    matched: true,\n    parameters: segments.length > 0 ? last(segments).parameters : {},\n    consumedSegments: segments,\n    remainingSegments: [],\n    positionalParamSegments: {}\n  };\n}\nfunction split(segmentGroup, consumedSegments, slicedSegments, config) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: s,\n      slicedSegments: []\n    };\n  }\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));\n    return {\n      segmentGroup: s,\n      slicedSegments\n    };\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {\n    segmentGroup: s,\n    slicedSegments\n  };\n}\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {\n  const res = {};\n  for (const r of routes) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return {\n    ...children,\n    ...res\n  };\n}\nfunction createChildrenForEmptyPaths(routes, primarySegment) {\n  const res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {\n  return routes.some(r => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n  return r.path === '';\n}\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\nlet NoLeftoversInUrl$1 = class NoLeftoversInUrl {};\nfunction recognize$2(_x, _x2, _x3, _x4, _x5, _x6) {\n  return _recognize$.apply(this, arguments);\n}\nfunction _recognize$() {\n  _recognize$ = _asyncToGenerator(function* (injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly', abortSignal) {\n    return new Recognizer$1(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal).recognize();\n  });\n  return _recognize$.apply(this, arguments);\n}\nconst MAX_ALLOWED_REDIRECTS$1 = 31;\nlet Recognizer$1 = class Recognizer {\n  injector;\n  configLoader;\n  rootComponentType;\n  config;\n  urlTree;\n  paramsInheritanceStrategy;\n  urlSerializer;\n  abortSignal;\n  applyRedirects;\n  absoluteRedirectCount = 0;\n  allowRedirects = true;\n  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal) {\n    this.injector = injector;\n    this.configLoader = configLoader;\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.urlSerializer = urlSerializer;\n    this.abortSignal = abortSignal;\n    this.applyRedirects = new ApplyRedirects$1(this.urlSerializer, this.urlTree);\n  }\n  noMatchError(e) {\n    return new _RuntimeError(4002, typeof ngDevMode === 'undefined' || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);\n  }\n  recognize() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const rootSegmentGroup = split(_this2.urlTree.root, [], [], _this2.config).segmentGroup;\n      const {\n        children,\n        rootSnapshot\n      } = yield _this2.match(rootSegmentGroup);\n      const rootNode = new TreeNode(rootSnapshot, children);\n      const routeState = new RouterStateSnapshot('', rootNode);\n      const tree = createUrlTreeFromSnapshot(rootSnapshot, [], _this2.urlTree.queryParams, _this2.urlTree.fragment);\n      tree.queryParams = _this2.urlTree.queryParams;\n      routeState.url = _this2.urlSerializer.serialize(tree);\n      return {\n        state: routeState,\n        tree\n      };\n    })();\n  }\n  match(rootSegmentGroup) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({\n        ..._this3.urlTree.queryParams\n      }), _this3.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, _this3.rootComponentType, null, {});\n      try {\n        const children = yield _this3.processSegmentGroup(_this3.injector, _this3.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot);\n        return {\n          children,\n          rootSnapshot\n        };\n      } catch (e) {\n        if (e instanceof AbsoluteRedirect$1) {\n          _this3.urlTree = e.urlTree;\n          return _this3.match(e.urlTree.root);\n        }\n        if (e instanceof NoMatch$1) {\n          throw _this3.noMatchError(e);\n        }\n        throw e;\n      }\n    })();\n  }\n  processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n        return _this4.processChildren(injector, config, segmentGroup, parentRoute);\n      }\n      const child = yield _this4.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute);\n      return child instanceof TreeNode ? [child] : [];\n    })();\n  }\n  processChildren(injector, config, segmentGroup, parentRoute) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const childOutlets = [];\n      for (const child of Object.keys(segmentGroup.children)) {\n        if (child === 'primary') {\n          childOutlets.unshift(child);\n        } else {\n          childOutlets.push(child);\n        }\n      }\n      let children = [];\n      for (const childOutlet of childOutlets) {\n        const child = segmentGroup.children[childOutlet];\n        const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n        const outletChildren = yield _this5.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n        children.push(...outletChildren);\n      }\n      const mergedChildren = mergeEmptyPathMatches$1(children);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        checkOutletNameUniqueness$1(mergedChildren);\n      }\n      sortActivatedRouteSnapshots$1(mergedChildren);\n      return mergedChildren;\n    })();\n  }\n  processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      for (const r of routes) {\n        try {\n          return yield _this6.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute);\n        } catch (e) {\n          if (e instanceof NoMatch$1 || isEmptyError(e)) {\n            continue;\n          }\n          throw e;\n        }\n      }\n      if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n        return new NoLeftoversInUrl$1();\n      }\n      throw new NoMatch$1(segmentGroup);\n    })();\n  }\n  processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n        throw new NoMatch$1(rawSegment);\n      }\n      if (route.redirectTo === undefined) {\n        return _this7.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n      }\n      if (_this7.allowRedirects && allowRedirects) {\n        return _this7.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\n      }\n      throw new NoMatch$1(rawSegment);\n    })();\n  }\n  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        matched,\n        parameters,\n        consumedSegments,\n        positionalParamSegments,\n        remainingSegments\n      } = match(segmentGroup, route, segments);\n      if (!matched) throw new NoMatch$1(segmentGroup);\n      if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n        _this8.absoluteRedirectCount++;\n        if (_this8.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS$1) {\n          if (ngDevMode) {\n            throw new _RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${_this8.urlTree}' to '${route.redirectTo}'.\\n` + `This is currently a dev mode only error but will become a` + ` call stack size exceeded error in production in a future major version.`);\n          }\n          _this8.allowRedirects = false;\n        }\n      }\n      const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({\n        ..._this8.urlTree.queryParams\n      }), _this8.urlTree.fragment, getData$1(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve$1(route));\n      const inherited = getInherited(currentSnapshot, parentRoute, _this8.paramsInheritanceStrategy);\n      currentSnapshot.params = Object.freeze(inherited.params);\n      currentSnapshot.data = Object.freeze(inherited.data);\n      if (_this8.abortSignal.aborted) {\n        throw new Error(_this8.abortSignal.reason);\n      }\n      const newTree = yield _this8.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n      const newSegments = yield _this8.applyRedirects.lineralizeSegments(route, newTree);\n      return _this8.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n    })();\n  }\n  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (_this9.abortSignal.aborted) {\n        throw new Error(_this9.abortSignal.reason);\n      }\n      const result = yield firstValueFrom(matchWithChecks(rawSegment, route, segments, injector, _this9.urlSerializer, _this9.abortSignal));\n      if (route.path === '**') {\n        rawSegment.children = {};\n      }\n      if (!result?.matched) {\n        throw new NoMatch$1(rawSegment);\n      }\n      injector = route._injector ?? injector;\n      const {\n        routes: childConfig\n      } = yield _this9.getChildConfig(injector, route, segments);\n      const childInjector = route._loadedInjector ?? injector;\n      const {\n        parameters,\n        consumedSegments,\n        remainingSegments\n      } = result;\n      const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({\n        ..._this9.urlTree.queryParams\n      }), _this9.urlTree.fragment, getData$1(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve$1(route));\n      const inherited = getInherited(snapshot, parentRoute, _this9.paramsInheritanceStrategy);\n      snapshot.params = Object.freeze(inherited.params);\n      snapshot.data = Object.freeze(inherited.data);\n      const {\n        segmentGroup,\n        slicedSegments\n      } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        const children = yield _this9.processChildren(childInjector, childConfig, segmentGroup, snapshot);\n        return new TreeNode(snapshot, children);\n      }\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return new TreeNode(snapshot, []);\n      }\n      const matchedOnOutlet = getOutlet(route) === outlet;\n      const child = yield _this9.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot);\n      return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n    })();\n  }\n  getChildConfig(injector, route, segments) {\n    var _this0 = this;\n    return _asyncToGenerator(function* () {\n      if (route.children) {\n        return {\n          routes: route.children,\n          injector\n        };\n      }\n      if (route.loadChildren) {\n        if (route._loadedRoutes !== undefined) {\n          return {\n            routes: route._loadedRoutes,\n            injector: route._loadedInjector\n          };\n        }\n        if (_this0.abortSignal.aborted) {\n          throw new Error(_this0.abortSignal.reason);\n        }\n        const shouldLoadResult = yield firstValueFrom(runCanLoadGuards(injector, route, segments, _this0.urlSerializer, _this0.abortSignal));\n        if (shouldLoadResult) {\n          const cfg = yield _this0.configLoader.loadChildren(injector, route);\n          route._loadedRoutes = cfg.routes;\n          route._loadedInjector = cfg.injector;\n          return cfg;\n        }\n        throw canLoadFails$1(route);\n      }\n      return {\n        routes: [],\n        injector\n      };\n    })();\n  }\n};\nfunction sortActivatedRouteSnapshots$1(nodes) {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\nfunction hasEmptyPathConfig$1(node) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\nfunction mergeEmptyPathMatches$1(nodes) {\n  const result = [];\n  const mergedNodes = new Set();\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig$1(node)) {\n      result.push(node);\n      continue;\n    }\n    const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches$1(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter(n => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness$1(nodes) {\n  const names = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new _RuntimeError(4006, (typeof ngDevMode === 'undefined' || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\nfunction getData$1(route) {\n  return route.data || {};\n}\nfunction getResolve$1(route) {\n  return route.resolve || {};\n}\nclass NoMatch {\n  segmentGroup;\n  constructor(segmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n}\nclass AbsoluteRedirect extends Error {\n  urlTree;\n  constructor(urlTree) {\n    super();\n    this.urlTree = urlTree;\n  }\n}\nfunction noMatch(segmentGroup) {\n  return throwError(new NoMatch(segmentGroup));\n}\nfunction namedOutletsRedirect(redirectTo) {\n  return throwError(new _RuntimeError(4000, (typeof ngDevMode === 'undefined' || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\nfunction canLoadFails(route) {\n  return throwError(navigationCancelingError((typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected));\n}\nclass ApplyRedirects {\n  urlSerializer;\n  urlTree;\n  constructor(urlSerializer, urlTree) {\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n  }\n  lineralizeSegments(route, urlTree) {\n    let res = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(`${route.redirectTo}`);\n      }\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n    return getRedirectResult(redirectTo, currentSnapshot, injector).pipe(map(redirect => {\n      if (redirect instanceof UrlTree) {\n        throw new AbsoluteRedirect(redirect);\n      }\n      const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);\n      if (redirect[0] === '/') {\n        throw new AbsoluteRedirect(newTree);\n      }\n      return newTree;\n    }));\n  }\n  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n  }\n  createQueryParams(redirectToParams, actualParams) {\n    const res = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === 'string' && v[0] === ':';\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n  createSegmentGroup(redirectTo, group, segments, posParams) {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n    let children = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n    return redirectToSegments.map(s => s.path[0] === ':' ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));\n  }\n  findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos) throw new _RuntimeError(4001, (typeof ngDevMode === 'undefined' || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n  findOrReturn(redirectToUrlSegment, actualSegments) {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\nfunction getRedirectResult(redirectTo, currentSnapshot, injector) {\n  if (typeof redirectTo === 'string') {\n    return of(redirectTo);\n  }\n  const redirectToFn = redirectTo;\n  const {\n    queryParams,\n    fragment,\n    routeConfig,\n    url,\n    outlet,\n    params,\n    data,\n    title\n  } = currentSnapshot;\n  return wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({\n    params,\n    data,\n    queryParams,\n    fragment,\n    routeConfig,\n    url,\n    outlet,\n    title\n  })));\n}\nclass NoLeftoversInUrl {}\nfunction recognize$1(injector, configLoader, rootComponentType, config, urlTree, urlSerializer, paramsInheritanceStrategy = 'emptyOnly', abortSignal) {\n  return new Recognizer(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();\n}\nconst MAX_ALLOWED_REDIRECTS = 31;\nclass Recognizer {\n  injector;\n  configLoader;\n  rootComponentType;\n  config;\n  urlTree;\n  paramsInheritanceStrategy;\n  urlSerializer;\n  applyRedirects;\n  absoluteRedirectCount = 0;\n  allowRedirects = true;\n  constructor(injector, configLoader, rootComponentType, config, urlTree, paramsInheritanceStrategy, urlSerializer) {\n    this.injector = injector;\n    this.configLoader = configLoader;\n    this.rootComponentType = rootComponentType;\n    this.config = config;\n    this.urlTree = urlTree;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.urlSerializer = urlSerializer;\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n  noMatchError(e) {\n    return new _RuntimeError(4002, typeof ngDevMode === 'undefined' || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);\n  }\n  recognize() {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n    return this.match(rootSegmentGroup).pipe(map(({\n      children,\n      rootSnapshot\n    }) => {\n      const rootNode = new TreeNode(rootSnapshot, children);\n      const routeState = new RouterStateSnapshot('', rootNode);\n      const tree = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\n      tree.queryParams = this.urlTree.queryParams;\n      routeState.url = this.urlSerializer.serialize(tree);\n      return {\n        state: routeState,\n        tree\n      };\n    }));\n  }\n  match(rootSegmentGroup) {\n    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});\n    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map(children => {\n      return {\n        children,\n        rootSnapshot\n      };\n    }), catchError(e => {\n      if (e instanceof AbsoluteRedirect) {\n        this.urlTree = e.urlTree;\n        return this.match(e.urlTree.root);\n      }\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n      throw e;\n    }));\n  }\n  processSegmentGroup(injector, config, segmentGroup, outlet, parentRoute) {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config, segmentGroup, parentRoute);\n    }\n    return this.processSegment(injector, config, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map(child => child instanceof TreeNode ? [child] : []));\n  }\n  processChildren(injector, config, segmentGroup, parentRoute) {\n    const childOutlets = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === 'primary') {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(concatMap(childOutlet => {\n      const child = segmentGroup.children[childOutlet];\n      const sortedConfig = sortByMatchingOutlets(config, childOutlet);\n      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n    }), scan((children, outletChildren) => {\n      children.push(...outletChildren);\n      return children;\n    }), defaultIfEmpty(null), last$1(), mergeMap(children => {\n      if (children === null) return noMatch(segmentGroup);\n      const mergedChildren = mergeEmptyPathMatches(children);\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        checkOutletNameUniqueness(mergedChildren);\n      }\n      sortActivatedRouteSnapshots(mergedChildren);\n      return of(mergedChildren);\n    }));\n  }\n  processSegment(injector, routes, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n    return from(routes).pipe(concatMap(r => {\n      return this.processSegmentAgainstRoute(r._injector ?? injector, routes, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError(e => {\n        if (e instanceof NoMatch) {\n          return of(null);\n        }\n        throw e;\n      }));\n    }), first(x => !!x), catchError(e => {\n      if (isEmptyError(e)) {\n        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n          return of(new NoLeftoversInUrl());\n        }\n        return noMatch(segmentGroup);\n      }\n      throw e;\n    }));\n  }\n  processSegmentAgainstRoute(injector, routes, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n      return noMatch(rawSegment);\n    }\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n    }\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes, route, segments, outlet, parentRoute);\n    }\n    return noMatch(rawSegment);\n  }\n  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes, route, segments, outlet, parentRoute) {\n    const {\n      matched,\n      parameters,\n      consumedSegments,\n      positionalParamSegments,\n      remainingSegments\n    } = match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n    if (typeof route.redirectTo === 'string' && route.redirectTo[0] === '/') {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new _RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\\n` + `This is currently a dev mode only error but will become a` + ` call stack size exceeded error in production in a future major version.`);\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze({\n      ...this.urlTree.queryParams\n    }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree$ = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n    return newTree$.pipe(switchMap(newTree => this.applyRedirects.lineralizeSegments(route, newTree)), mergeMap(newSegments => {\n      return this.processSegment(injector, routes, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n    }));\n  }\n  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === '**') {\n      rawSegment.children = {};\n    }\n    return matchResult.pipe(switchMap(result => {\n      if (!result.matched) {\n        return noMatch(rawSegment);\n      }\n      injector = route._injector ?? injector;\n      return this.getChildConfig(injector, route, segments).pipe(switchMap(({\n        routes: childConfig\n      }) => {\n        const childInjector = route._loadedInjector ?? injector;\n        const {\n          parameters,\n          consumedSegments,\n          remainingSegments\n        } = result;\n        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze({\n          ...this.urlTree.queryParams\n        }), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n        snapshot.params = Object.freeze(inherited.params);\n        snapshot.data = Object.freeze(inherited.data);\n        const {\n          segmentGroup,\n          slicedSegments\n        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map(children => {\n            return new TreeNode(snapshot, children);\n          }));\n        }\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of(new TreeNode(snapshot, []));\n        }\n        const matchedOnOutlet = getOutlet(route) === outlet;\n        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map(child => {\n          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n        }));\n      }));\n    }));\n  }\n  getChildConfig(injector, route, segments) {\n    if (route.children) {\n      return of({\n        routes: route.children,\n        injector\n      });\n    }\n    if (route.loadChildren) {\n      if (route._loadedRoutes !== undefined) {\n        return of({\n          routes: route._loadedRoutes,\n          injector: route._loadedInjector\n        });\n      }\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap(shouldLoadResult => {\n        if (shouldLoadResult) {\n          return from(this.configLoader.loadChildren(injector, route)).pipe(tap(cfg => {\n            route._loadedRoutes = cfg.routes;\n            route._loadedInjector = cfg.injector;\n          }));\n        }\n        return canLoadFails(route);\n      }));\n    }\n    return of({\n      routes: [],\n      injector\n    });\n  }\n}\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\nfunction hasEmptyPathConfig(node) {\n  const config = node.value.routeConfig;\n  return config && config.path === '';\n}\nfunction mergeEmptyPathMatches(nodes) {\n  const result = [];\n  const mergedNodes = new Set();\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n    const duplicateEmptyPathNode = result.find(resultNode => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== undefined) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter(n => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness(nodes) {\n  const names = {};\n  nodes.forEach(n => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map(s => s.toString()).join('/');\n      const c = n.value.url.map(s => s.toString()).join('/');\n      throw new _RuntimeError(4006, (typeof ngDevMode === 'undefined' || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\nfunction getData(route) {\n  return route.data || {};\n}\nfunction getResolve(route) {\n  return route.resolve || {};\n}\nconst RECOGNIZE_IMPL = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'RECOGNIZE_IMPL' : '', {\n  factory: () => {\n    return recognize$2;\n  }\n});\nfunction provideSometimesSyncRecognize() {\n  return makeEnvironmentProviders([{\n    provide: RECOGNIZE_IMPL,\n    useValue: recognize$1\n  }]);\n}\nfunction recognize(injector, configLoader, rootComponentType, config, serializer, paramsInheritanceStrategy, abortSignal) {\n  const recognizeImpl = injector.get(RECOGNIZE_IMPL);\n  return mergeMap(t => of(t).pipe(switchMap(t => recognizeImpl(injector, configLoader, rootComponentType, config, t.extractedUrl, serializer, paramsInheritanceStrategy, abortSignal)), map(({\n    state: targetSnapshot,\n    tree: urlAfterRedirects\n  }) => {\n    return {\n      ...t,\n      targetSnapshot,\n      urlAfterRedirects\n    };\n  })));\n}\nfunction resolveData(paramsInheritanceStrategy, injector) {\n  return mergeMap(t => {\n    const {\n      targetSnapshot,\n      guards: {\n        canActivateChecks\n      }\n    } = t;\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    const routesWithResolversToRun = new Set(canActivateChecks.map(check => check.route));\n    const routesNeedingDataUpdates = new Set();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(concatMap(route => {\n      if (routesWithResolversToRun.has(route)) {\n        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);\n      } else {\n        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n        return of(void 0);\n      }\n    }), tap(() => routesProcessed++), takeLast(1), mergeMap(_ => routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY));\n  });\n}\nfunction flattenRouteTree(route) {\n  const descendants = route.children.map(child => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\n  const config = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config?.title !== undefined && !hasStaticTitle(config)) {\n    resolve[RouteTitleKey] = config.title;\n  }\n  return defer(() => {\n    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map(resolvedData => {\n      futureARS._resolvedData = resolvedData;\n      futureARS.data = {\n        ...futureARS.data,\n        ...resolvedData\n      };\n      return null;\n    }));\n  });\n}\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data = {};\n  return from(keys).pipe(mergeMap(key => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap(value => {\n    if (value instanceof RedirectCommand) {\n      throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n    }\n    data[key] = value;\n  }))), takeLast(1), map(() => data), catchError(e => isEmptyError(e) ? EMPTY : throwError(e)));\n}\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\nfunction switchTap(next) {\n  return switchMap(v => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\nlet TitleStrategy = /*#__PURE__*/(() => {\n  class TitleStrategy {\n    buildTitle(snapshot) {\n      let pageTitle;\n      let route = snapshot.root;\n      while (route !== undefined) {\n        pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n        route = route.children.find(child => child.outlet === PRIMARY_OUTLET);\n      }\n      return pageTitle;\n    }\n    getResolvedTitleForRoute(snapshot) {\n      return snapshot.data[RouteTitleKey];\n    }\n    static ɵfac = function TitleStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TitleStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: TitleStrategy,\n      factory: () => (() => inject(DefaultTitleStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return TitleStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DefaultTitleStrategy = /*#__PURE__*/(() => {\n  class DefaultTitleStrategy extends TitleStrategy {\n    title;\n    constructor(title) {\n      super();\n      this.title = title;\n    }\n    updateTitle(snapshot) {\n      const title = this.buildTitle(snapshot);\n      if (title !== undefined) {\n        this.title.setTitle(title);\n      }\n    }\n    static ɵfac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultTitleStrategy)(i0.ɵɵinject(i1.Title));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultTitleStrategy,\n      factory: DefaultTitleStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultTitleStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ROUTER_CONFIGURATION = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'router config' : '', {\n  factory: () => ({})\n});\nconst ROUTES = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'ROUTES' : '');\nlet RouterConfigLoader = /*#__PURE__*/(() => {\n  class RouterConfigLoader {\n    componentLoaders = new WeakMap();\n    childrenLoaders = new WeakMap();\n    onLoadStartListener;\n    onLoadEndListener;\n    compiler = inject(Compiler);\n    loadComponent(injector, route) {\n      var _this1 = this;\n      return _asyncToGenerator(function* () {\n        if (_this1.componentLoaders.get(route)) {\n          return _this1.componentLoaders.get(route);\n        } else if (route._loadedComponent) {\n          return Promise.resolve(route._loadedComponent);\n        }\n        if (_this1.onLoadStartListener) {\n          _this1.onLoadStartListener(route);\n        }\n        const loader = _asyncToGenerator(function* () {\n          try {\n            const loaded = yield wrapIntoPromise(runInInjectionContext(injector, () => route.loadComponent()));\n            const component = yield maybeResolveResources(maybeUnwrapDefaultExport(loaded));\n            if (_this1.onLoadEndListener) {\n              _this1.onLoadEndListener(route);\n            }\n            (typeof ngDevMode === 'undefined' || ngDevMode) && assertStandalone(route.path ?? '', component);\n            route._loadedComponent = component;\n            return component;\n          } finally {\n            _this1.componentLoaders.delete(route);\n          }\n        })();\n        _this1.componentLoaders.set(route, loader);\n        return loader;\n      })();\n    }\n    loadChildren(parentInjector, route) {\n      var _this10 = this;\n      if (this.childrenLoaders.get(route)) {\n        return this.childrenLoaders.get(route);\n      } else if (route._loadedRoutes) {\n        return Promise.resolve({\n          routes: route._loadedRoutes,\n          injector: route._loadedInjector\n        });\n      }\n      if (this.onLoadStartListener) {\n        this.onLoadStartListener(route);\n      }\n      const loader = _asyncToGenerator(function* () {\n        try {\n          const result = yield loadChildren(route, _this10.compiler, parentInjector, _this10.onLoadEndListener);\n          route._loadedRoutes = result.routes;\n          route._loadedInjector = result.injector;\n          return result;\n        } finally {\n          _this10.childrenLoaders.delete(route);\n        }\n      })();\n      this.childrenLoaders.set(route, loader);\n      return loader;\n    }\n    static ɵfac = function RouterConfigLoader_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouterConfigLoader)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouterConfigLoader,\n      factory: RouterConfigLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return RouterConfigLoader;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction loadChildren(_x7, _x8, _x9, _x0) {\n  return _loadChildren.apply(this, arguments);\n}\nfunction _loadChildren() {\n  _loadChildren = _asyncToGenerator(function* (route, compiler, parentInjector, onLoadEndListener) {\n    const loaded = yield wrapIntoPromise(runInInjectionContext(parentInjector, () => route.loadChildren()));\n    const t = yield maybeResolveResources(maybeUnwrapDefaultExport(loaded));\n    let factoryOrRoutes;\n    if (t instanceof NgModuleFactory || Array.isArray(t)) {\n      factoryOrRoutes = t;\n    } else {\n      factoryOrRoutes = yield compiler.compileModuleAsync(t);\n    }\n    if (onLoadEndListener) {\n      onLoadEndListener(route);\n    }\n    let injector;\n    let rawRoutes;\n    let requireStandaloneComponents = false;\n    if (Array.isArray(factoryOrRoutes)) {\n      rawRoutes = factoryOrRoutes;\n      requireStandaloneComponents = true;\n    } else {\n      injector = factoryOrRoutes.create(parentInjector).injector;\n      rawRoutes = injector.get(ROUTES, [], {\n        optional: true,\n        self: true\n      }).flat();\n    }\n    const routes = rawRoutes.map(standardizeConfig);\n    (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(routes, route.path, requireStandaloneComponents);\n    return {\n      routes,\n      injector\n    };\n  });\n  return _loadChildren.apply(this, arguments);\n}\nfunction isWrappedDefaultExport(value) {\n  return value && typeof value === 'object' && 'default' in value;\n}\nfunction maybeUnwrapDefaultExport(input) {\n  return isWrappedDefaultExport(input) ? input['default'] : input;\n}\nfunction maybeResolveResources(_x1) {\n  return _maybeResolveResources.apply(this, arguments);\n}\nfunction _maybeResolveResources() {\n  _maybeResolveResources = _asyncToGenerator(function* (value) {\n    if ((typeof ngJitMode === 'undefined' || ngJitMode) && typeof fetch === 'function') {\n      try {\n        yield _resolveComponentResources(fetch);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n    return value;\n  });\n  return _maybeResolveResources.apply(this, arguments);\n}\nlet UrlHandlingStrategy = /*#__PURE__*/(() => {\n  class UrlHandlingStrategy {\n    static ɵfac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || UrlHandlingStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: UrlHandlingStrategy,\n      factory: () => (() => inject(DefaultUrlHandlingStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return UrlHandlingStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DefaultUrlHandlingStrategy = /*#__PURE__*/(() => {\n  class DefaultUrlHandlingStrategy {\n    shouldProcessUrl(url) {\n      return true;\n    }\n    extract(url) {\n      return url;\n    }\n    merge(newUrlPart, wholeUrl) {\n      return newUrlPart;\n    }\n    static ɵfac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DefaultUrlHandlingStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultUrlHandlingStrategy,\n      factory: DefaultUrlHandlingStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultUrlHandlingStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CREATE_VIEW_TRANSITION = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'view transition helper' : '');\nconst VIEW_TRANSITION_OPTIONS = /*#__PURE__*/new InjectionToken(typeof ngDevMode !== 'undefined' && ngDevMode ? 'view transition options' : '');\nfunction createViewTransition(injector, from, to) {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document = injector.get(DOCUMENT);\n  if (!document.startViewTransition || transitionOptions.skipNextTransition) {\n    transitionOptions.skipNextTransition = false;\n    return new Promise(resolve => setTimeout(resolve));\n  }\n  let resolveViewTransitionStarted;\n  const viewTransitionStarted = new Promise(resolve => {\n    resolveViewTransitionStarted = resolve;\n  });\n  const transition = document.startViewTransition(() => {\n    resolveViewTransitionStarted();\n    return createRenderPromise(injector);\n  });\n  transition.ready.catch(error => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  transition.finished.catch(error => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      console.error(error);\n    }\n  });\n  const {\n    onViewTransitionCreated\n  } = transitionOptions;\n  if (onViewTransitionCreated) {\n    runInInjectionContext(injector, () => onViewTransitionCreated({\n      transition,\n      from,\n      to\n    }));\n  }\n  return viewTransitionStarted;\n}\nfunction createRenderPromise(injector) {\n  return new Promise(resolve => {\n    afterNextRender({\n      read: () => setTimeout(resolve)\n    }, {\n      injector\n    });\n  });\n}\nconst noop = () => {};\nconst NAVIGATION_ERROR_HANDLER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'navigation error handler' : '');\nlet NavigationTransitions = /*#__PURE__*/(() => {\n  class NavigationTransitions {\n    currentNavigation = signal(null, {\n      ...(ngDevMode ? {\n        debugName: \"currentNavigation\"\n      } : {}),\n      equal: () => false\n    });\n    currentTransition = null;\n    lastSuccessfulNavigation = signal(null, ...(ngDevMode ? [{\n      debugName: \"lastSuccessfulNavigation\"\n    }] : []));\n    events = new Subject();\n    transitionAbortWithErrorSubject = new Subject();\n    configLoader = inject(RouterConfigLoader);\n    environmentInjector = inject(EnvironmentInjector);\n    destroyRef = inject(DestroyRef);\n    urlSerializer = inject(UrlSerializer);\n    rootContexts = inject(ChildrenOutletContexts);\n    location = inject(Location);\n    inputBindingEnabled = inject(INPUT_BINDER, {\n      optional: true\n    }) !== null;\n    titleStrategy = inject(TitleStrategy);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    }) || {};\n    paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || 'emptyOnly';\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    createViewTransition = inject(CREATE_VIEW_TRANSITION, {\n      optional: true\n    });\n    navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {\n      optional: true\n    });\n    navigationId = 0;\n    get hasRequestedNavigation() {\n      return this.navigationId !== 0;\n    }\n    transitions;\n    afterPreactivation = () => of(void 0);\n    rootComponentType = null;\n    destroyed = false;\n    constructor() {\n      const onLoadStart = r => this.events.next(new RouteConfigLoadStart(r));\n      const onLoadEnd = r => this.events.next(new RouteConfigLoadEnd(r));\n      this.configLoader.onLoadEndListener = onLoadEnd;\n      this.configLoader.onLoadStartListener = onLoadStart;\n      this.destroyRef.onDestroy(() => {\n        this.destroyed = true;\n      });\n    }\n    complete() {\n      this.transitions?.complete();\n    }\n    handleNavigationRequest(request) {\n      const id = ++this.navigationId;\n      untracked(() => {\n        this.transitions?.next({\n          ...request,\n          extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n          targetSnapshot: null,\n          targetRouterState: null,\n          guards: {\n            canActivateChecks: [],\n            canDeactivateChecks: []\n          },\n          guardsResult: null,\n          id\n        });\n      });\n    }\n    setupNavigations(router) {\n      this.transitions = new BehaviorSubject(null);\n      return this.transitions.pipe(filter(t => t !== null), switchMap(overallTransitionState => {\n        let completedOrAborted = false;\n        const abortController = new AbortController();\n        return of(overallTransitionState).pipe(switchMap(t => {\n          if (this.navigationId > overallTransitionState.id) {\n            const cancellationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';\n            this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\n            return EMPTY;\n          }\n          this.currentTransition = overallTransitionState;\n          const lastSuccessfulNavigation = this.lastSuccessfulNavigation();\n          this.currentNavigation.set({\n            id: t.id,\n            initialUrl: t.rawUrl,\n            extractedUrl: t.extractedUrl,\n            targetBrowserUrl: typeof t.extras.browserUrl === 'string' ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,\n            trigger: t.source,\n            extras: t.extras,\n            previousNavigation: !lastSuccessfulNavigation ? null : {\n              ...lastSuccessfulNavigation,\n              previousNavigation: null\n            },\n            abort: () => abortController.abort()\n          });\n          const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n          const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n          if (!urlTransition && onSameUrlNavigation !== 'reload') {\n            const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : '';\n            this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\n            t.resolve(false);\n            return EMPTY;\n          }\n          if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n            return of(t).pipe(switchMap(t => {\n              this.events.next(new NavigationStart(t.id, this.urlSerializer.serialize(t.extractedUrl), t.source, t.restoredState));\n              if (t.id !== this.navigationId) {\n                return EMPTY;\n              }\n              return Promise.resolve(t);\n            }), recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy, abortController.signal), tap(t => {\n              overallTransitionState.targetSnapshot = t.targetSnapshot;\n              overallTransitionState.urlAfterRedirects = t.urlAfterRedirects;\n              this.currentNavigation.update(nav => {\n                nav.finalUrl = t.urlAfterRedirects;\n                return nav;\n              });\n              const routesRecognized = new RoutesRecognized(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n              this.events.next(routesRecognized);\n            }));\n          } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n            const {\n              id,\n              extractedUrl,\n              source,\n              restoredState,\n              extras\n            } = t;\n            const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\n            this.events.next(navStart);\n            const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n            this.currentTransition = overallTransitionState = {\n              ...t,\n              targetSnapshot,\n              urlAfterRedirects: extractedUrl,\n              extras: {\n                ...extras,\n                skipLocationChange: false,\n                replaceUrl: false\n              }\n            };\n            this.currentNavigation.update(nav => {\n              nav.finalUrl = extractedUrl;\n              return nav;\n            });\n            return of(overallTransitionState);\n          } else {\n            const reason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy` + ` indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : '';\n            this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n            t.resolve(false);\n            return EMPTY;\n          }\n        }), tap(t => {\n          const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n          this.events.next(guardsStart);\n        }), map(t => {\n          this.currentTransition = overallTransitionState = {\n            ...t,\n            guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)\n          };\n          return overallTransitionState;\n        }), checkGuards(this.environmentInjector, evt => this.events.next(evt)), tap(t => {\n          overallTransitionState.guardsResult = t.guardsResult;\n          if (t.guardsResult && typeof t.guardsResult !== 'boolean') {\n            throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n          }\n          const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n          this.events.next(guardsEnd);\n        }), filter(t => {\n          if (!t.guardsResult) {\n            this.cancelNavigationTransition(t, '', NavigationCancellationCode.GuardRejected);\n            return false;\n          }\n          return true;\n        }), switchTap(t => {\n          if (t.guards.canActivateChecks.length === 0) {\n            return undefined;\n          }\n          return of(t).pipe(tap(t => {\n            const resolveStart = new ResolveStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n            this.events.next(resolveStart);\n          }), switchMap(t => {\n            let dataResolved = false;\n            return of(t).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({\n              next: () => dataResolved = true,\n              complete: () => {\n                if (!dataResolved) {\n                  this.cancelNavigationTransition(t, typeof ngDevMode === 'undefined' || ngDevMode ? `At least one route resolver didn't emit any value.` : '', NavigationCancellationCode.NoDataFromResolver);\n                }\n              }\n            }));\n          }), tap(t => {\n            const resolveEnd = new ResolveEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n            this.events.next(resolveEnd);\n          }));\n        }), switchTap(t => {\n          const loadComponents = route => {\n            const loaders = [];\n            if (route.routeConfig?._loadedComponent) {\n              route.component = route.routeConfig?._loadedComponent;\n            } else if (route.routeConfig?.loadComponent) {\n              const injector = getClosestRouteInjector(route) ?? this.environmentInjector;\n              loaders.push(this.configLoader.loadComponent(injector, route.routeConfig).then(loadedComponent => {\n                route.component = loadedComponent;\n              }));\n            }\n            for (const child of route.children) {\n              loaders.push(...loadComponents(child));\n            }\n            return loaders;\n          };\n          const loaders = loadComponents(t.targetSnapshot.root);\n          return loaders.length === 0 ? of(t) : from(Promise.all(loaders).then(() => t));\n        }), switchTap(() => this.afterPreactivation()), switchMap(() => {\n          const {\n            currentSnapshot,\n            targetSnapshot\n          } = overallTransitionState;\n          const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\n          return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);\n        }), map(t => {\n          const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n          this.currentTransition = overallTransitionState = {\n            ...t,\n            targetRouterState\n          };\n          this.currentNavigation.update(nav => {\n            nav.targetRouterState = targetRouterState;\n            return nav;\n          });\n          return overallTransitionState;\n        }), tap(() => {\n          this.events.next(new BeforeActivateRoutes());\n        }), activateRoutes(this.rootContexts, router.routeReuseStrategy, evt => this.events.next(evt), this.inputBindingEnabled), take(1), takeUntil(abortSignalToObservable(abortController.signal).pipe(filter(() => !completedOrAborted && !overallTransitionState.targetRouterState), tap(() => {\n          this.cancelNavigationTransition(overallTransitionState, abortController.signal.reason + '', NavigationCancellationCode.Aborted);\n        }))), tap({\n          next: t => {\n            completedOrAborted = true;\n            this.currentNavigation.update(nav => {\n              nav.abort = noop;\n              return nav;\n            });\n            this.lastSuccessfulNavigation.set(untracked(this.currentNavigation));\n            this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\n            this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\n            t.resolve(true);\n          },\n          complete: () => {\n            completedOrAborted = true;\n          }\n        }), takeUntil(this.transitionAbortWithErrorSubject.pipe(tap(err => {\n          throw err;\n        }))), finalize(() => {\n          abortController.abort();\n          if (!completedOrAborted) {\n            const cancelationReason = typeof ngDevMode === 'undefined' || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : '';\n            this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\n          }\n          if (this.currentTransition?.id === overallTransitionState.id) {\n            this.currentNavigation.set(null);\n            this.currentTransition = null;\n          }\n        }), catchError(e => {\n          if (this.destroyed) {\n            overallTransitionState.resolve(false);\n            return EMPTY;\n          }\n          completedOrAborted = true;\n          if (isNavigationCancelingError(e)) {\n            this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\n            if (!isRedirectingNavigationCancelingError(e)) {\n              overallTransitionState.resolve(false);\n            } else {\n              this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n            }\n          } else {\n            const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? undefined);\n            try {\n              const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\n              if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                const {\n                  message,\n                  cancellationCode\n                } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\n                this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\n                this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\n              } else {\n                this.events.next(navigationError);\n                throw e;\n              }\n            } catch (ee) {\n              if (this.options.resolveNavigationPromiseOnError) {\n                overallTransitionState.resolve(false);\n              } else {\n                overallTransitionState.reject(ee);\n              }\n            }\n          }\n          return EMPTY;\n        }));\n      }));\n    }\n    cancelNavigationTransition(t, reason, code) {\n      const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n      this.events.next(navCancel);\n      t.resolve(false);\n    }\n    isUpdatingInternalState() {\n      return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();\n    }\n    isUpdatedBrowserUrl() {\n      const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n      const currentNavigation = untracked(this.currentNavigation);\n      const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;\n      return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !currentNavigation?.extras.skipLocationChange;\n    }\n    static ɵfac = function NavigationTransitions_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || NavigationTransitions)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NavigationTransitions,\n      factory: NavigationTransitions.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NavigationTransitions;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isBrowserTriggeredNavigation(source) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\nlet RouteReuseStrategy = /*#__PURE__*/(() => {\n  class RouteReuseStrategy {\n    static ɵfac = function RouteReuseStrategy_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || RouteReuseStrategy)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: RouteReuseStrategy,\n      factory: () => (() => inject(DefaultRouteReuseStrategy))(),\n      providedIn: 'root'\n    });\n  }\n  return RouteReuseStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass BaseRouteReuseStrategy {\n  shouldDetach(route) {\n    return false;\n  }\n  store(route, detachedTree) {}\n  shouldAttach(route) {\n    return false;\n  }\n  retrieve(route) {\n    return null;\n  }\n  shouldReuseRoute(future, curr) {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\nlet DefaultRouteReuseStrategy = /*#__PURE__*/(() => {\n  class DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵDefaultRouteReuseStrategy_BaseFactory;\n      return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {\n        return (ɵDefaultRouteReuseStrategy_BaseFactory || (ɵDefaultRouteReuseStrategy_BaseFactory = i0.ɵɵgetInheritedFactory(DefaultRouteReuseStrategy)))(__ngFactoryType__ || DefaultRouteReuseStrategy);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DefaultRouteReuseStrategy,\n      factory: DefaultRouteReuseStrategy.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DefaultRouteReuseStrategy;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet StateManager = /*#__PURE__*/(() => {\n  class StateManager {\n    urlSerializer = inject(UrlSerializer);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    }) || {};\n    canceledNavigationResolution = this.options.canceledNavigationResolution || 'replace';\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    currentUrlTree = new UrlTree();\n    getCurrentUrlTree() {\n      return this.currentUrlTree;\n    }\n    rawUrlTree = this.currentUrlTree;\n    getRawUrlTree() {\n      return this.rawUrlTree;\n    }\n    createBrowserPath({\n      finalUrl,\n      initialUrl,\n      targetBrowserUrl\n    }) {\n      const rawUrl = finalUrl !== undefined ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;\n      const url = targetBrowserUrl ?? rawUrl;\n      const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n      return path;\n    }\n    commitTransition({\n      targetRouterState,\n      finalUrl,\n      initialUrl\n    }) {\n      if (finalUrl && targetRouterState) {\n        this.currentUrlTree = finalUrl;\n        this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);\n        this.routerState = targetRouterState;\n      } else {\n        this.rawUrlTree = initialUrl;\n      }\n    }\n    routerState = createEmptyState(null);\n    getRouterState() {\n      return this.routerState;\n    }\n    stateMemento = this.createStateMemento();\n    updateStateMemento() {\n      this.stateMemento = this.createStateMemento();\n    }\n    createStateMemento() {\n      return {\n        rawUrlTree: this.rawUrlTree,\n        currentUrlTree: this.currentUrlTree,\n        routerState: this.routerState\n      };\n    }\n    resetInternalState({\n      finalUrl\n    }) {\n      this.routerState = this.stateMemento.routerState;\n      this.currentUrlTree = this.stateMemento.currentUrlTree;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);\n    }\n    static ɵfac = function StateManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || StateManager)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: StateManager,\n      factory: () => (() => inject(HistoryStateManager))(),\n      providedIn: 'root'\n    });\n  }\n  return StateManager;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HistoryStateManager = /*#__PURE__*/(() => {\n  class HistoryStateManager extends StateManager {\n    currentPageId = 0;\n    lastSuccessfulId = -1;\n    restoredState() {\n      return this.location.getState();\n    }\n    get browserPageId() {\n      if (this.canceledNavigationResolution !== 'computed') {\n        return this.currentPageId;\n      }\n      return this.restoredState()?.ɵrouterPageId ?? this.currentPageId;\n    }\n    registerNonRouterCurrentEntryChangeListener(listener) {\n      return this.location.subscribe(event => {\n        if (event['type'] === 'popstate') {\n          setTimeout(() => {\n            listener(event['url'], event.state, 'popstate');\n          });\n        }\n      });\n    }\n    handleRouterEvent(e, currentTransition) {\n      if (e instanceof NavigationStart) {\n        this.updateStateMemento();\n      } else if (e instanceof NavigationSkipped) {\n        this.commitTransition(currentTransition);\n      } else if (e instanceof RoutesRecognized) {\n        if (this.urlUpdateStrategy === 'eager') {\n          if (!currentTransition.extras.skipLocationChange) {\n            this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n          }\n        }\n      } else if (e instanceof BeforeActivateRoutes) {\n        this.commitTransition(currentTransition);\n        if (this.urlUpdateStrategy === 'deferred' && !currentTransition.extras.skipLocationChange) {\n          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);\n        }\n      } else if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.SupersededByNewNavigation && e.code !== NavigationCancellationCode.Redirect) {\n        this.restoreHistory(currentTransition);\n      } else if (e instanceof NavigationError) {\n        this.restoreHistory(currentTransition, true);\n      } else if (e instanceof NavigationEnd) {\n        this.lastSuccessfulId = e.id;\n        this.currentPageId = this.browserPageId;\n      }\n    }\n    setBrowserUrl(path, {\n      extras,\n      id\n    }) {\n      const {\n        replaceUrl,\n        state\n      } = extras;\n      if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {\n        const currentBrowserPageId = this.browserPageId;\n        const newState = {\n          ...state,\n          ...this.generateNgRouterState(id, currentBrowserPageId)\n        };\n        this.location.replaceState(path, '', newState);\n      } else {\n        const newState = {\n          ...state,\n          ...this.generateNgRouterState(id, this.browserPageId + 1)\n        };\n        this.location.go(path, '', newState);\n      }\n    }\n    restoreHistory(navigation, restoringFromCaughtError = false) {\n      if (this.canceledNavigationResolution === 'computed') {\n        const currentBrowserPageId = this.browserPageId;\n        const targetPagePosition = this.currentPageId - currentBrowserPageId;\n        if (targetPagePosition !== 0) {\n          this.location.historyGo(targetPagePosition);\n        } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {\n          this.resetInternalState(navigation);\n          this.resetUrlToCurrentUrlTree();\n        } else ;\n      } else if (this.canceledNavigationResolution === 'replace') {\n        if (restoringFromCaughtError) {\n          this.resetInternalState(navigation);\n        }\n        this.resetUrlToCurrentUrlTree();\n      }\n    }\n    resetUrlToCurrentUrlTree() {\n      this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), '', this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n    }\n    generateNgRouterState(navigationId, routerPageId) {\n      if (this.canceledNavigationResolution === 'computed') {\n        return {\n          navigationId,\n          ɵrouterPageId: routerPageId\n        };\n      }\n      return {\n        navigationId\n      };\n    }\n    static ɵfac = /* @__PURE__ */(() => {\n      let ɵHistoryStateManager_BaseFactory;\n      return function HistoryStateManager_Factory(__ngFactoryType__) {\n        return (ɵHistoryStateManager_BaseFactory || (ɵHistoryStateManager_BaseFactory = i0.ɵɵgetInheritedFactory(HistoryStateManager)))(__ngFactoryType__ || HistoryStateManager);\n      };\n    })();\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HistoryStateManager,\n      factory: HistoryStateManager.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return HistoryStateManager;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction afterNextNavigation(router, action) {\n  router.events.pipe(filter(e => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map(e => {\n    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n      return 0;\n    }\n    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;\n    return redirecting ? 2 : 1;\n  }), filter(result => result !== 2), take(1)).subscribe(() => {\n    action();\n  });\n}\nconst exactMatchOptions = {\n  paths: 'exact',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'exact'\n};\nconst subsetMatchOptions = {\n  paths: 'subset',\n  fragment: 'ignored',\n  matrixParams: 'ignored',\n  queryParams: 'subset'\n};\nlet Router = /*#__PURE__*/(() => {\n  class Router {\n    get currentUrlTree() {\n      return this.stateManager.getCurrentUrlTree();\n    }\n    get rawUrlTree() {\n      return this.stateManager.getRawUrlTree();\n    }\n    disposed = false;\n    nonRouterCurrentEntryChangeSubscription;\n    console = inject(_Console);\n    stateManager = inject(StateManager);\n    options = inject(ROUTER_CONFIGURATION, {\n      optional: true\n    }) || {};\n    pendingTasks = inject(_PendingTasksInternal);\n    urlUpdateStrategy = this.options.urlUpdateStrategy || 'deferred';\n    navigationTransitions = inject(NavigationTransitions);\n    urlSerializer = inject(UrlSerializer);\n    location = inject(Location);\n    urlHandlingStrategy = inject(UrlHandlingStrategy);\n    injector = inject(EnvironmentInjector);\n    _events = new Subject();\n    get events() {\n      return this._events;\n    }\n    get routerState() {\n      return this.stateManager.getRouterState();\n    }\n    navigated = false;\n    routeReuseStrategy = inject(RouteReuseStrategy);\n    onSameUrlNavigation = this.options.onSameUrlNavigation || 'ignore';\n    config = inject(ROUTES, {\n      optional: true\n    })?.flat() ?? [];\n    componentInputBindingEnabled = !!inject(INPUT_BINDER, {\n      optional: true\n    });\n    currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();\n    constructor() {\n      this.resetConfig(this.config);\n      this.navigationTransitions.setupNavigations(this).subscribe({\n        error: e => {\n          this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n        }\n      });\n      this.subscribeToNavigationEvents();\n    }\n    eventsSubscription = new Subscription();\n    subscribeToNavigationEvents() {\n      const subscription = this.navigationTransitions.events.subscribe(e => {\n        try {\n          const currentTransition = this.navigationTransitions.currentTransition;\n          const currentNavigation = untracked(this.navigationTransitions.currentNavigation);\n          if (currentTransition !== null && currentNavigation !== null) {\n            this.stateManager.handleRouterEvent(e, currentNavigation);\n            if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n              this.navigated = true;\n            } else if (e instanceof NavigationEnd) {\n              this.navigated = true;\n            } else if (e instanceof RedirectRequest) {\n              const opts = e.navigationBehaviorOptions;\n              const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n              const extras = {\n                browserUrl: currentTransition.extras.browserUrl,\n                info: currentTransition.extras.info,\n                skipLocationChange: currentTransition.extras.skipLocationChange,\n                replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === 'eager' || isBrowserTriggeredNavigation(currentTransition.source),\n                ...opts\n              };\n              this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n                resolve: currentTransition.resolve,\n                reject: currentTransition.reject,\n                promise: currentTransition.promise\n              });\n            }\n          }\n          if (isPublicRouterEvent(e)) {\n            this._events.next(e);\n          }\n        } catch (e) {\n          this.navigationTransitions.transitionAbortWithErrorSubject.next(e);\n        }\n      });\n      this.eventsSubscription.add(subscription);\n    }\n    resetRootComponentType(rootComponentType) {\n      this.routerState.root.component = rootComponentType;\n      this.navigationTransitions.rootComponentType = rootComponentType;\n    }\n    initialNavigation() {\n      this.setUpLocationChangeListener();\n      if (!this.navigationTransitions.hasRequestedNavigation) {\n        this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n      }\n    }\n    setUpLocationChangeListener() {\n      this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state, source) => {\n        this.navigateToSyncWithBrowser(url, source, state);\n      });\n    }\n    navigateToSyncWithBrowser(url, source, state) {\n      const extras = {\n        replaceUrl: true\n      };\n      const restoredState = state?.navigationId ? state : null;\n      if (state) {\n        const stateCopy = {\n          ...state\n        };\n        delete stateCopy.navigationId;\n        delete stateCopy.ɵrouterPageId;\n        if (Object.keys(stateCopy).length !== 0) {\n          extras.state = stateCopy;\n        }\n      }\n      const urlTree = this.parseUrl(url);\n      this.scheduleNavigation(urlTree, source, restoredState, extras).catch(e => {\n        if (this.disposed) {\n          return;\n        }\n        this.injector.get(_INTERNAL_APPLICATION_ERROR_HANDLER)(e);\n      });\n    }\n    get url() {\n      return this.serializeUrl(this.currentUrlTree);\n    }\n    getCurrentNavigation() {\n      return untracked(this.navigationTransitions.currentNavigation);\n    }\n    get lastSuccessfulNavigation() {\n      return this.navigationTransitions.lastSuccessfulNavigation;\n    }\n    resetConfig(config) {\n      (typeof ngDevMode === 'undefined' || ngDevMode) && validateConfig(config);\n      this.config = config.map(standardizeConfig);\n      this.navigated = false;\n    }\n    ngOnDestroy() {\n      this.dispose();\n    }\n    dispose() {\n      this._events.unsubscribe();\n      this.navigationTransitions.complete();\n      if (this.nonRouterCurrentEntryChangeSubscription) {\n        this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n        this.nonRouterCurrentEntryChangeSubscription = undefined;\n      }\n      this.disposed = true;\n      this.eventsSubscription.unsubscribe();\n    }\n    createUrlTree(commands, navigationExtras = {}) {\n      const {\n        relativeTo,\n        queryParams,\n        fragment,\n        queryParamsHandling,\n        preserveFragment\n      } = navigationExtras;\n      const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n      let q = null;\n      switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n        case 'merge':\n          q = {\n            ...this.currentUrlTree.queryParams,\n            ...queryParams\n          };\n          break;\n        case 'preserve':\n          q = this.currentUrlTree.queryParams;\n          break;\n        default:\n          q = queryParams || null;\n      }\n      if (q !== null) {\n        q = this.removeEmptyProps(q);\n      }\n      let relativeToUrlSegmentGroup;\n      try {\n        const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n        relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n      } catch (e) {\n        if (typeof commands[0] !== 'string' || commands[0][0] !== '/') {\n          commands = [];\n        }\n        relativeToUrlSegmentGroup = this.currentUrlTree.root;\n      }\n      return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null, this.urlSerializer);\n    }\n    navigateByUrl(url, extras = {\n      skipLocationChange: false\n    }) {\n      const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n      const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n      return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n    }\n    navigate(commands, extras = {\n      skipLocationChange: false\n    }) {\n      validateCommands(commands);\n      return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n    }\n    serializeUrl(url) {\n      return this.urlSerializer.serialize(url);\n    }\n    parseUrl(url) {\n      try {\n        return this.urlSerializer.parse(url);\n      } catch (e) {\n        this.console.warn(_formatRuntimeError(4018, ngDevMode && `Error parsing URL ${url}. Falling back to '/' instead. \\n` + e));\n        return this.urlSerializer.parse('/');\n      }\n    }\n    isActive(url, matchOptions) {\n      let options;\n      if (matchOptions === true) {\n        options = {\n          ...exactMatchOptions\n        };\n      } else if (matchOptions === false) {\n        options = {\n          ...subsetMatchOptions\n        };\n      } else {\n        options = matchOptions;\n      }\n      if (isUrlTree(url)) {\n        return containsTree(this.currentUrlTree, url, options);\n      }\n      const urlTree = this.parseUrl(url);\n      return containsTree(this.currentUrlTree, urlTree, options);\n    }\n    removeEmptyProps(params) {\n      return Object.entries(params).reduce((result, [key, value]) => {\n        if (value !== null && value !== undefined) {\n          result[key] = value;\n        }\n        return result;\n      }, {});\n    }\n    scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n      if (this.disposed) {\n        return Promise.resolve(false);\n      }\n      let resolve;\n      let reject;\n      let promise;\n      if (priorPromise) {\n        resolve = priorPromise.resolve;\n        reject = priorPromise.reject;\n        promise = priorPromise.promise;\n      } else {\n        promise = new Promise((res, rej) => {\n          resolve = res;\n          reject = rej;\n        });\n      }\n      const taskId = this.pendingTasks.add();\n      afterNextNavigation(this, () => {\n        queueMicrotask(() => this.pendingTasks.remove(taskId));\n      });\n      this.navigationTransitions.handleNavigationRequest({\n        source,\n        restoredState,\n        currentUrlTree: this.currentUrlTree,\n        currentRawUrl: this.currentUrlTree,\n        rawUrl,\n        extras,\n        resolve: resolve,\n        reject: reject,\n        promise,\n        currentSnapshot: this.routerState.snapshot,\n        currentRouterState: this.routerState\n      });\n      return promise.catch(e => {\n        return Promise.reject(e);\n      });\n    }\n    static ɵfac = function Router_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Router)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Router,\n      factory: Router.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Router;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction validateCommands(commands) {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new _RuntimeError(4008, (typeof ngDevMode === 'undefined' || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\nexport { ActivatedRoute, ActivatedRouteSnapshot, ActivationEnd, ActivationStart, BaseRouteReuseStrategy, CREATE_VIEW_TRANSITION, ChildActivationEnd, ChildActivationStart, ChildrenOutletContexts, DefaultTitleStrategy, DefaultUrlSerializer, EventType, GuardsCheckEnd, GuardsCheckStart, HistoryStateManager, IMPERATIVE_NAVIGATION, INPUT_BINDER, NAVIGATION_ERROR_HANDLER, NavigationCancel, NavigationCancellationCode, NavigationEnd, NavigationError, NavigationSkipped, NavigationSkippedCode, NavigationStart, NavigationTransitions, OutletContext, PRIMARY_OUTLET, ROUTER_CONFIGURATION, ROUTER_OUTLET_DATA, ROUTES, RedirectCommand, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RouteReuseStrategy, RoutedComponentInputBinder, Router, RouterConfigLoader, RouterEvent, RouterOutlet, RouterState, RouterStateSnapshot, RoutesRecognized, Scroll, StateManager, TitleStrategy, UrlHandlingStrategy, UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree, VIEW_TRANSITION_OPTIONS, afterNextNavigation, convertToParamMap, createUrlTreeFromSnapshot, createViewTransition, defaultUrlMatcher, isUrlTree, loadChildren, provideSometimesSyncRecognize, stringifyEvent, ɵEmptyOutletComponent };\n//# sourceMappingURL=_router-chunk.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}