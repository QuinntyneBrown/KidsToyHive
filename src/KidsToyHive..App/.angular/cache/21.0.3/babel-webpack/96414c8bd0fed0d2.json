{"ast":null,"code":"/**\n * @license Angular v21.0.5\n * (c) 2010-2025 Google LLC. https://angular.dev/\n * License: MIT\n */\n\nexport { BrowserModule, bootstrapApplication, createApplication, platformBrowser, provideProtractorTestingSupport, BrowserDomAdapter as ɵBrowserDomAdapter, BrowserGetTestability as ɵBrowserGetTestability, KeyEventsPlugin as ɵKeyEventsPlugin } from './_browser-chunk.mjs';\nimport { ɵgetDOM as _getDOM, DOCUMENT } from '@angular/common';\nexport { ɵgetDOM } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, ɵglobal as _global, ApplicationRef, InjectionToken, ɵConsole as _Console, Optional, Injector, NgModule, forwardRef, ɵRuntimeError as _RuntimeError, ɵXSS_SECURITY_URL as _XSS_SECURITY_URL, SecurityContext, ɵallowSanitizationBypassAndThrow as _allowSanitizationBypassAndThrow, ɵunwrapSafeValue as _unwrapSafeValue, ɵ_sanitizeUrl as __sanitizeUrl, ɵ_sanitizeHtml as __sanitizeHtml, ɵbypassSanitizationTrustHtml as _bypassSanitizationTrustHtml, ɵbypassSanitizationTrustStyle as _bypassSanitizationTrustStyle, ɵbypassSanitizationTrustScript as _bypassSanitizationTrustScript, ɵbypassSanitizationTrustUrl as _bypassSanitizationTrustUrl, ɵbypassSanitizationTrustResourceUrl as _bypassSanitizationTrustResourceUrl, ɵwithI18nSupport as _withI18nSupport, ɵwithEventReplay as _withEventReplay, ɵwithIncrementalHydration as _withIncrementalHydration, makeEnvironmentProviders, ɵwithDomHydration as _withDomHydration, ENVIRONMENT_INITIALIZER, inject, ɵIS_ENABLED_BLOCKING_INITIAL_NAVIGATION as _IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, ɵformatRuntimeError as _formatRuntimeError, Version } from '@angular/core';\nimport { EventManagerPlugin, EVENT_MANAGER_PLUGINS } from './_dom_renderer-chunk.mjs';\nexport { EventManager, REMOVE_STYLES_ON_COMPONENT_DESTROY, DomEventsPlugin as ɵDomEventsPlugin, DomRendererFactory2 as ɵDomRendererFactory2, SharedStylesHost as ɵSharedStylesHost } from './_dom_renderer-chunk.mjs';\nimport { ɵwithHttpTransferCache as _withHttpTransferCache } from '@angular/common/http';\nlet Meta = /*#__PURE__*/(() => {\n  class Meta {\n    _doc;\n    _dom;\n    constructor(_doc) {\n      this._doc = _doc;\n      this._dom = _getDOM();\n    }\n    addTag(tag, forceCreation = false) {\n      if (!tag) return null;\n      return this._getOrCreateElement(tag, forceCreation);\n    }\n    addTags(tags, forceCreation = false) {\n      if (!tags) return [];\n      return tags.reduce((result, tag) => {\n        if (tag) {\n          result.push(this._getOrCreateElement(tag, forceCreation));\n        }\n        return result;\n      }, []);\n    }\n    getTag(attrSelector) {\n      if (!attrSelector) return null;\n      return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n    }\n    getTags(attrSelector) {\n      if (!attrSelector) return [];\n      const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n      return list ? [].slice.call(list) : [];\n    }\n    updateTag(tag, selector) {\n      if (!tag) return null;\n      selector = selector || this._parseSelector(tag);\n      const meta = this.getTag(selector);\n      if (meta) {\n        return this._setMetaElementAttributes(tag, meta);\n      }\n      return this._getOrCreateElement(tag, true);\n    }\n    removeTag(attrSelector) {\n      this.removeTagElement(this.getTag(attrSelector));\n    }\n    removeTagElement(meta) {\n      if (meta) {\n        this._dom.remove(meta);\n      }\n    }\n    _getOrCreateElement(meta, forceCreation = false) {\n      if (!forceCreation) {\n        const selector = this._parseSelector(meta);\n        const elem = this.getTags(selector).filter(elem => this._containsAttributes(meta, elem))[0];\n        if (elem !== undefined) return elem;\n      }\n      const element = this._dom.createElement('meta');\n      this._setMetaElementAttributes(meta, element);\n      const head = this._doc.getElementsByTagName('head')[0];\n      head.appendChild(element);\n      return element;\n    }\n    _setMetaElementAttributes(tag, el) {\n      Object.keys(tag).forEach(prop => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));\n      return el;\n    }\n    _parseSelector(tag) {\n      const attr = tag.name ? 'name' : 'property';\n      return `${attr}=\"${tag[attr]}\"`;\n    }\n    _containsAttributes(tag, elem) {\n      return Object.keys(tag).every(key => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);\n    }\n    _getMetaKeyMap(prop) {\n      return META_KEYS_MAP[prop] || prop;\n    }\n    static ɵfac = function Meta_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Meta)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Meta,\n      factory: Meta.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Meta;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst META_KEYS_MAP = {\n  httpEquiv: 'http-equiv'\n};\nlet Title = /*#__PURE__*/(() => {\n  class Title {\n    _doc;\n    constructor(_doc) {\n      this._doc = _doc;\n    }\n    getTitle() {\n      return this._doc.title;\n    }\n    setTitle(newTitle) {\n      this._doc.title = newTitle || '';\n    }\n    static ɵfac = function Title_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || Title)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Title,\n      factory: Title.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Title;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction exportNgVar(name, value) {\n  if (typeof COMPILED === 'undefined' || !COMPILED) {\n    const ng = _global['ng'] = _global['ng'] || {};\n    ng[name] = value;\n  }\n}\nclass ChangeDetectionPerfRecord {\n  msPerTick;\n  numTicks;\n  constructor(msPerTick, numTicks) {\n    this.msPerTick = msPerTick;\n    this.numTicks = numTicks;\n  }\n}\nclass AngularProfiler {\n  appRef;\n  constructor(ref) {\n    this.appRef = ref.injector.get(ApplicationRef);\n  }\n  timeChangeDetection(config) {\n    const record = config && config['record'];\n    const profileName = 'Change Detection';\n    if (record && 'profile' in console && typeof console.profile === 'function') {\n      console.profile(profileName);\n    }\n    const start = performance.now();\n    let numTicks = 0;\n    while (numTicks < 5 || performance.now() - start < 500) {\n      this.appRef.tick();\n      numTicks++;\n    }\n    const end = performance.now();\n    if (record && 'profileEnd' in console && typeof console.profileEnd === 'function') {\n      console.profileEnd(profileName);\n    }\n    const msPerTick = (end - start) / numTicks;\n    console.log(`ran ${numTicks} change detection cycles`);\n    console.log(`${msPerTick.toFixed(2)} ms per check`);\n    return new ChangeDetectionPerfRecord(msPerTick, numTicks);\n  }\n}\nconst PROFILER_GLOBAL_NAME = 'profiler';\nfunction enableDebugTools(ref) {\n  exportNgVar(PROFILER_GLOBAL_NAME, new AngularProfiler(ref));\n  return ref;\n}\nfunction disableDebugTools() {\n  exportNgVar(PROFILER_GLOBAL_NAME, null);\n}\nclass By {\n  static all() {\n    return () => true;\n  }\n  static css(selector) {\n    return debugElement => {\n      return debugElement.nativeElement != null ? elementMatches(debugElement.nativeElement, selector) : false;\n    };\n  }\n  static directive(type) {\n    return debugNode => debugNode.providerTokens.indexOf(type) !== -1;\n  }\n}\nfunction elementMatches(n, selector) {\n  if (_getDOM().isElementNode(n)) {\n    return n.matches && n.matches(selector) || n.msMatchesSelector && n.msMatchesSelector(selector) || n.webkitMatchesSelector && n.webkitMatchesSelector(selector);\n  }\n  return false;\n}\nconst EVENT_NAMES = {\n  'pan': true,\n  'panstart': true,\n  'panmove': true,\n  'panend': true,\n  'pancancel': true,\n  'panleft': true,\n  'panright': true,\n  'panup': true,\n  'pandown': true,\n  'pinch': true,\n  'pinchstart': true,\n  'pinchmove': true,\n  'pinchend': true,\n  'pinchcancel': true,\n  'pinchin': true,\n  'pinchout': true,\n  'press': true,\n  'pressup': true,\n  'rotate': true,\n  'rotatestart': true,\n  'rotatemove': true,\n  'rotateend': true,\n  'rotatecancel': true,\n  'swipe': true,\n  'swipeleft': true,\n  'swiperight': true,\n  'swipeup': true,\n  'swipedown': true,\n  'tap': true,\n  'doubletap': true\n};\nconst HAMMER_GESTURE_CONFIG = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerGestureConfig' : '');\nconst HAMMER_LOADER = /*#__PURE__*/new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'HammerLoader' : '');\nlet HammerGestureConfig = /*#__PURE__*/(() => {\n  class HammerGestureConfig {\n    events = [];\n    overrides = {};\n    options;\n    buildHammer(element) {\n      const mc = new Hammer(element, this.options);\n      mc.get('pinch').set({\n        enable: true\n      });\n      mc.get('rotate').set({\n        enable: true\n      });\n      for (const eventName in this.overrides) {\n        mc.get(eventName).set(this.overrides[eventName]);\n      }\n      return mc;\n    }\n    static ɵfac = function HammerGestureConfig_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HammerGestureConfig)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HammerGestureConfig,\n      factory: HammerGestureConfig.ɵfac\n    });\n  }\n  return HammerGestureConfig;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HammerGesturesPlugin = /*#__PURE__*/(() => {\n  class HammerGesturesPlugin extends EventManagerPlugin {\n    _config;\n    _injector;\n    loader;\n    _loaderPromise = null;\n    constructor(doc, _config, _injector, loader) {\n      super(doc);\n      this._config = _config;\n      this._injector = _injector;\n      this.loader = loader;\n    }\n    supports(eventName) {\n      if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n        return false;\n      }\n      if (!window.Hammer && !this.loader) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n          const _console = this._injector.get(_Console);\n          _console.warn(`The \"${eventName}\" event cannot be bound because Hammer.JS is not ` + `loaded and no custom loader has been specified.`);\n        }\n        return false;\n      }\n      return true;\n    }\n    addEventListener(element, eventName, handler) {\n      const zone = this.manager.getZone();\n      eventName = eventName.toLowerCase();\n      if (!window.Hammer && this.loader) {\n        this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());\n        let cancelRegistration = false;\n        let deregister = () => {\n          cancelRegistration = true;\n        };\n        zone.runOutsideAngular(() => this._loaderPromise.then(() => {\n          if (!window.Hammer) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              const _console = this._injector.get(_Console);\n              _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n            }\n            deregister = () => {};\n            return;\n          }\n          if (!cancelRegistration) {\n            deregister = this.addEventListener(element, eventName, handler);\n          }\n        }).catch(() => {\n          if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const _console = this._injector.get(_Console);\n            _console.warn(`The \"${eventName}\" event cannot be bound because the custom ` + `Hammer.JS loader failed.`);\n          }\n          deregister = () => {};\n        }));\n        return () => {\n          deregister();\n        };\n      }\n      return zone.runOutsideAngular(() => {\n        const mc = this._config.buildHammer(element);\n        const callback = function (eventObj) {\n          zone.runGuarded(function () {\n            handler(eventObj);\n          });\n        };\n        mc.on(eventName, callback);\n        return () => {\n          mc.off(eventName, callback);\n          if (typeof mc.destroy === 'function') {\n            mc.destroy();\n          }\n        };\n      });\n    }\n    isCustomEvent(eventName) {\n      return this._config.events.indexOf(eventName) > -1;\n    }\n    static ɵfac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HammerGesturesPlugin)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(HAMMER_GESTURE_CONFIG), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(HAMMER_LOADER, 8));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: HammerGesturesPlugin,\n      factory: HammerGesturesPlugin.ɵfac\n    });\n  }\n  return HammerGesturesPlugin;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HammerModule = /*#__PURE__*/(() => {\n  class HammerModule {\n    static ɵfac = function HammerModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || HammerModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: HammerModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [{\n        provide: EVENT_MANAGER_PLUGINS,\n        useClass: HammerGesturesPlugin,\n        multi: true,\n        deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]\n      }, {\n        provide: HAMMER_GESTURE_CONFIG,\n        useClass: HammerGestureConfig\n      }]\n    });\n  }\n  return HammerModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DomSanitizer = /*#__PURE__*/(() => {\n  class DomSanitizer {\n    static ɵfac = function DomSanitizer_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DomSanitizer)();\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DomSanitizer,\n      factory: function DomSanitizer_Factory(__ngFactoryType__) {\n        let __ngConditionalFactory__ = null;\n        if (__ngFactoryType__) {\n          __ngConditionalFactory__ = new (__ngFactoryType__ || DomSanitizer)();\n        } else {\n          __ngConditionalFactory__ = i0.ɵɵinject(DomSanitizerImpl);\n        }\n        return __ngConditionalFactory__;\n      },\n      providedIn: 'root'\n    });\n  }\n  return DomSanitizer;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DomSanitizerImpl = /*#__PURE__*/(() => {\n  class DomSanitizerImpl extends DomSanitizer {\n    _doc;\n    constructor(_doc) {\n      super();\n      this._doc = _doc;\n    }\n    sanitize(ctx, value) {\n      if (value == null) return null;\n      switch (ctx) {\n        case SecurityContext.NONE:\n          return value;\n        case SecurityContext.HTML:\n          if (_allowSanitizationBypassAndThrow(value, \"HTML\")) {\n            return _unwrapSafeValue(value);\n          }\n          return __sanitizeHtml(this._doc, String(value)).toString();\n        case SecurityContext.STYLE:\n          if (_allowSanitizationBypassAndThrow(value, \"Style\")) {\n            return _unwrapSafeValue(value);\n          }\n          return value;\n        case SecurityContext.SCRIPT:\n          if (_allowSanitizationBypassAndThrow(value, \"Script\")) {\n            return _unwrapSafeValue(value);\n          }\n          throw new _RuntimeError(5200, (typeof ngDevMode === 'undefined' || ngDevMode) && 'unsafe value used in a script context');\n        case SecurityContext.URL:\n          if (_allowSanitizationBypassAndThrow(value, \"URL\")) {\n            return _unwrapSafeValue(value);\n          }\n          return __sanitizeUrl(String(value));\n        case SecurityContext.RESOURCE_URL:\n          if (_allowSanitizationBypassAndThrow(value, \"ResourceURL\")) {\n            return _unwrapSafeValue(value);\n          }\n          throw new _RuntimeError(5201, (typeof ngDevMode === 'undefined' || ngDevMode) && `unsafe value used in a resource URL context (see ${_XSS_SECURITY_URL})`);\n        default:\n          throw new _RuntimeError(5202, (typeof ngDevMode === 'undefined' || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${_XSS_SECURITY_URL})`);\n      }\n    }\n    bypassSecurityTrustHtml(value) {\n      return _bypassSanitizationTrustHtml(value);\n    }\n    bypassSecurityTrustStyle(value) {\n      return _bypassSanitizationTrustStyle(value);\n    }\n    bypassSecurityTrustScript(value) {\n      return _bypassSanitizationTrustScript(value);\n    }\n    bypassSecurityTrustUrl(value) {\n      return _bypassSanitizationTrustUrl(value);\n    }\n    bypassSecurityTrustResourceUrl(value) {\n      return _bypassSanitizationTrustResourceUrl(value);\n    }\n    static ɵfac = function DomSanitizerImpl_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || DomSanitizerImpl)(i0.ɵɵinject(DOCUMENT));\n    };\n    static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: DomSanitizerImpl,\n      factory: DomSanitizerImpl.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return DomSanitizerImpl;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar HydrationFeatureKind = /*#__PURE__*/function (HydrationFeatureKind) {\n  HydrationFeatureKind[HydrationFeatureKind[\"NoHttpTransferCache\"] = 0] = \"NoHttpTransferCache\";\n  HydrationFeatureKind[HydrationFeatureKind[\"HttpTransferCacheOptions\"] = 1] = \"HttpTransferCacheOptions\";\n  HydrationFeatureKind[HydrationFeatureKind[\"I18nSupport\"] = 2] = \"I18nSupport\";\n  HydrationFeatureKind[HydrationFeatureKind[\"EventReplay\"] = 3] = \"EventReplay\";\n  HydrationFeatureKind[HydrationFeatureKind[\"IncrementalHydration\"] = 4] = \"IncrementalHydration\";\n  return HydrationFeatureKind;\n}(HydrationFeatureKind || {});\nfunction hydrationFeature(ɵkind, ɵproviders = [], ɵoptions = {}) {\n  return {\n    ɵkind,\n    ɵproviders\n  };\n}\nfunction withNoHttpTransferCache() {\n  return hydrationFeature(HydrationFeatureKind.NoHttpTransferCache);\n}\nfunction withHttpTransferCacheOptions(options) {\n  return hydrationFeature(HydrationFeatureKind.HttpTransferCacheOptions, _withHttpTransferCache(options));\n}\nfunction withI18nSupport() {\n  return hydrationFeature(HydrationFeatureKind.I18nSupport, _withI18nSupport());\n}\nfunction withEventReplay() {\n  return hydrationFeature(HydrationFeatureKind.EventReplay, _withEventReplay());\n}\nfunction withIncrementalHydration() {\n  return hydrationFeature(HydrationFeatureKind.IncrementalHydration, _withIncrementalHydration());\n}\nfunction provideEnabledBlockingInitialNavigationDetector() {\n  return [{\n    provide: ENVIRONMENT_INITIALIZER,\n    useValue: () => {\n      const isEnabledBlockingInitialNavigation = inject(_IS_ENABLED_BLOCKING_INITIAL_NAVIGATION, {\n        optional: true\n      });\n      if (isEnabledBlockingInitialNavigation) {\n        const console = inject(_Console);\n        const message = _formatRuntimeError(5001, 'Configuration error: found both hydration and enabledBlocking initial navigation ' + 'in the same application, which is a contradiction.');\n        console.warn(message);\n      }\n    },\n    multi: true\n  }];\n}\nfunction provideClientHydration(...features) {\n  const providers = [];\n  const featuresKind = new Set();\n  for (const {\n    ɵproviders,\n    ɵkind\n  } of features) {\n    featuresKind.add(ɵkind);\n    if (ɵproviders.length) {\n      providers.push(ɵproviders);\n    }\n  }\n  const hasHttpTransferCacheOptions = featuresKind.has(HydrationFeatureKind.HttpTransferCacheOptions);\n  if (typeof ngDevMode !== 'undefined' && ngDevMode && featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) && hasHttpTransferCacheOptions) {\n    throw new _RuntimeError(5001, 'Configuration error: found both withHttpTransferCacheOptions() and withNoHttpTransferCache() in the same call to provideClientHydration(), which is a contradiction.');\n  }\n  return makeEnvironmentProviders([typeof ngDevMode !== 'undefined' && ngDevMode ? provideEnabledBlockingInitialNavigationDetector() : [], _withDomHydration(), featuresKind.has(HydrationFeatureKind.NoHttpTransferCache) || hasHttpTransferCacheOptions ? [] : _withHttpTransferCache({}), providers]);\n}\nconst VERSION = /* @__PURE__ */new Version('21.0.5');\nexport { By, DomSanitizer, EVENT_MANAGER_PLUGINS, EventManagerPlugin, HAMMER_GESTURE_CONFIG, HAMMER_LOADER, HammerGestureConfig, HammerModule, HydrationFeatureKind, Meta, Title, VERSION, disableDebugTools, enableDebugTools, provideClientHydration, withEventReplay, withHttpTransferCacheOptions, withI18nSupport, withIncrementalHydration, withNoHttpTransferCache, DomSanitizerImpl as ɵDomSanitizerImpl, HammerGesturesPlugin as ɵHammerGesturesPlugin };\n//# sourceMappingURL=platform-browser.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}